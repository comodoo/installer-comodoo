#!/usr/bin/env python2
# vim: ts=4:sw=4:et:sts=4:ai:tw=80
import errno
import sys
import os
import time
import subprocess
import tarfile
import shutil
import locale
import dialog
import optparse
import logging

from constants import *

__version__ = "0.0.1"

# import gettext
# _ = lambda x: gettext.ldgettext("anaconda", x)

# FIXME: move to constasts


log = None

fstype2tool = {"ext3": ("mkfs.ext3", "-v"), "swap": ("mkswap", "-V1")}


def setup_python_path():
    """
    Set real path or development paths for run in svn
    """

    if os.path.exists('../stage-2'):
        sys.path.insert(0, 'usr/lib/anaconda')
    else:
        sys.path.insert(0, '/usr/lib/anaconda')
        sys.path.append('/usr/share/system-config-date')


def setup_environment():
    locale.setlocale(locale.LC_ALL, '')

    os.environ['HOME'] = '/tmp'
    os.environ['LC_NUMERIC'] = 'C'

    # In theory, this gets rid of our LVM file descriptor warnings
    os.environ["LVM_SUPPRESS_FD_WARNINGS"] = "1"

    # make sure we have /sbin and /usr/sbin in our path
    os.environ["PATH"] += ":/sbin:/usr/sbin"

    # we can't let the LD_PRELOAD hang around because it will leak into
    # rpm %post and the like.  ick :/
    if "LD_PRELOAD" in os.environ:
        del os.environ["LD_PRELOAD"]


def parse_args():
    usage = "usage: %prog [options]"
    version = "Installer version: %s" % __version__

    parser = optparse.OptionParser(usage=usage, version=version)
    parser.add_option("-v", "--verbose",
                      action="store_true",
                      dest="verbose",
                      help="Set verbosity output")

    parser.add_option("-d", "--devel",
                      action="store_true",
                      dest="devel",
                      help="For simulations")

    (options, args) = parser.parse_args()

    return options


def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError, exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise


def strip_markup(text):
    if text.find("<") == -1:
        return text
    r = ""
    in_tag = False
    for c in text:
        if c == ">" and in_tag:
            in_tag = False
            continue
        elif c == "<" and not in_tag:
            in_tag = True
            continue
        elif not in_tag:
            r += c
    return r.encode("utf-8")


def setup_logging_from_opts(opts):
    if opts.loglevel and logLevelMap.has_key(opts.loglevel):
        log.setHandlersLevel(logLevelMap[opts.loglevel])

    if opts.syslog:
        if opts.syslog.find(":") != -1:
            (host, port) = opts.syslog.split(":")
            logger.addSysLogHandler(log, host, port=int(port))
        else:
            logger.addSysLogHandler(log, opts.syslog)


def exec_with_pulse_progress(command, argv, stdin=0, stdout=1, stderr=2,
                             progress=None):
    argv = list(argv)
    if type(stdin) == type("string"):
        if os.access(stdin, os.R_OK):
            stdin = open(stdin)
        else:
            stdin = 0

    if type(stdout) == type("string"):
        stdout = open(stdout, "w")
    if type(stderr) == type("string"):
        stderr = open(stderr, "w")
    if stdout is not None and type(stdout) != int:
        stdout.write("Running... %s\n" % ([command] + argv,))

    p = os.pipe()
    childpid = os.fork()
    if not childpid:
        os.close(p[0])
        os.dup2(p[1], 1)
        os.dup2(stderr.fileno(), 2)
        os.dup2(stdin, 0)
        os.close(stdin)
        os.close(p[1])
        stderr.close()

        os.execvp(command, [command] + argv)
        os._exit(1)

    os.close(p[1])

    while 1:
        try:
            s = os.read(p[0], 1)
        except OSError, args:
            (num, str) = args
            if (num != 4):
                raise IOError, args

        stdout.write(s)
        if progress:
            progress.pulse()

        if len(s) < 1:
            break

    try:
        (pid, status) = os.waitpid(childpid, 0)
    except OSError, (num, msg):
        log.critical("exception from waitpid: %s %s" % (num, msg))

    progress and progress.pop()

    # *shrug*  no clue why this would happen, but hope that things are fine
    if status is None:
        return 0

    if os.WIFEXITED(status):
        return os.WEXITSTATUS(status)

    return 1


class DiskSet:
    """The disks in the system."""

    def __init__(self):
        self.deviceFile = None

    def drive_list(self):
        for dev in minihal.get_devices_by_type("storage"):
            if dev['device'] is None:
                continue

            device = dev['device'].replace('/dev/', '')

            log.info("detected possible disk: %s" % (device,))
            log.info("device type: %s" % (dev['storage.drive_type'],))

            if device.startswith("sg"):
                log.info("ignoring st device %s" % (device,))
                continue

            if device.startswith("md"):
                log.info("ignoring sr device %s" % (device,))
                continue

            if device.startswith("sr"):
                log.info("ignoring sr device %s" % (device,))
                continue

            if dev['storage.drive_type'] == 'disk':
                self.deviceFile = dev['device']
                log.info("final disk selected: %s" % (self.deviceFile,))

        if not self.deviceFile:
            log.warning("no detected possible disks: %s" % (device,))

        return self.deviceFile

    def megabytes_to_sectors(self, mb, sector_bytes=512):
        return long(mb * MEGABYTE / sector_bytes)

    def sectors_to_megabytes(self, sectors, sector_bytes=512):
        return float((float(sectors) * sector_bytes) / float(MEGABYTE))

    def convert_bytes(self, bytes):
        bytes = float(bytes)
        if bytes >= 1099511627776:
            terabytes = bytes / 1099511627776
            size = '%.2fT' % terabytes
        elif bytes >= 1073741824:
            gigabytes = bytes / 1073741824
            size = '%.2fG' % gigabytes
        elif bytes >= 1048576:
            megabytes = bytes / 1048576
            size = '%.2fM' % megabytes
        elif bytes >= 1024:
            kilobytes = bytes / 1024
            size = '%.2fK' % kilobytes
        else:
            size = '%.2fb' % bytes
        return size

    def create_partitions_v1(self):
        '''Up to now, the partition layout is fixed to conservative
        values. The current layout is:
        /dev/sda1    boot partition -> 100MB
        /dev/sda2    swap partition -> 1.5 size of RAM
        /dev/sda3    root partition -> remaining disk space
        '''
        parted_dev = parted.PedDevice.get(self.deviceFile)

        try:
            parted_disk = parted.PedDisk.new(parted_dev)
        except parted.error, msg:
            '''A entire zero disk hasn't partition table.
            Parted open() need a disk label for normal operation'''
            log.error("ivalid partition table: %s" % msg)
            label = label = parted.disk_type_get('msdos')
            disk = parted_dev.disk_new_fresh(label)
            disk.commit()
            parted_disk = parted.PedDisk.new(parted_dev)

        fstypeParted = parted.file_system_type_get('ext3')
        fsswapParted = parted.file_system_type_get('linux-swap')

        # partition new values startSec, endSec, I mean sectors.
        sizeMB = float(
            parted_dev.heads * parted_dev.cylinders * parted_dev.sectors) \
                 / (1024 * 1024) * parted_dev.sector_size

        bootsize = self.megabytes_to_sectors(100)
        partitionBoot = \
            parted_disk.partition_new(parted.PARTITION_PRIMARY,
                                      fstypeParted,
                                      1,
                                      bootsize)
        swapsize = self.megabytes_to_sectors(500)
        partitionSwap = \
            parted_disk.partition_new(parted.PARTITION_PRIMARY,
                                      fsswapParted,
                                      bootsize + 1,
                                      bootsize + swapsize)
        partitionRoot = \
            parted_disk.partition_new(parted.PARTITION_PRIMARY,
                                      fstypeParted,
                                      bootsize + swapsize + 1,
                                      parted_dev.length - 1)
        parted_disk.dev.open()
        parted_disk.delete_all()
        entireDisk = parted.PedDevice.get(self.deviceFile).constraint_any()
        parted_disk.add_partition(partitionBoot, entireDisk)
        parted_disk.add_partition(partitionSwap, entireDisk)
        parted_disk.add_partition(partitionRoot, entireDisk)
        parted_disk.commit()

        # set boot flag in this point
        partition = parted_disk.get_partition(BOOTPARTITION)
        partition.set_flag(parted.PARTITION_BOOT, 1)
        parted_disk.commit()

        return 0

    def create_partitions_v2(self):
        '''Up to now, the partition layout is fixed to conservative
        values. The current layout is:
        /dev/sda1    boot partition -> 100MB
        /dev/sda2    swap partition -> 1.5 size of RAM
        /dev/sda3    root partition -> remaining disk space
        '''
        target_device = parted.Device(path=self.deviceFile)

        # log diskinformation for debug
        (cylinders, heads, sectors) = target_device.biosGeometry
        sizeInBytes = target_device.length * target_device.sectorSize
        geometry_cad = "%d heads, %d sectors/track, %d cylinders\n" % (
        heads, sectors, cylinders,)
        size_cad = "Disk /dev/sdb size: %s\n" % (
        self.convert_bytes(sizeInBytes),)
        log.info(geometry_cad)
        log.info(size_cad)

        # Create Disk object
        target_disk = parted.freshDisk(target_device, "msdos")

        target_constraint = parted.Constraint(device=target_device)

        # Create geometry for 100MB from sector 1 - boot partition
        bootsize = self.megabytes_to_sectors(100)

        boot_partition_geom = parted.Geometry(device=target_device, start=1,
                                              end=bootsize)
        filesystem_target = parted.FileSystem(type="ext3",
                                              geometry=boot_partition_geom)
        boot_partition = parted.Partition(disk=target_disk,
                                          fs=filesystem_target,
                                          type=parted.PARTITION_NORMAL,
                                          geometry=boot_partition_geom)

        # Create geometry for 500MB of swap partition
        swapsize = self.megabytes_to_sectors(500)

        swap_partition_geom = parted.Geometry(device=target_device,
                                              start=bootsize + 1,
                                              end=bootsize + swapsize)
        filesystem_target = parted.FileSystem(type="linux-swap(v1)",
                                              geometry=swap_partition_geom)
        swap_partition = parted.Partition(disk=target_disk,
                                          fs=filesystem_target,
                                          type=parted.PARTITION_NORMAL,
                                          geometry=swap_partition_geom)

        root_partition_geom = parted.Geometry(device=target_device,
                                              start=bootsize + swapsize + 1,
                                              end=target_device.length - 1)
        filesystem_target = parted.FileSystem(type="ext3",
                                              geometry=root_partition_geom)
        root_partition = parted.Partition(disk=target_disk,
                                          fs=filesystem_target,
                                          type=parted.PARTITION_NORMAL,
                                          geometry=root_partition_geom)

        # Delete all partitions in the drive
        target_disk.deleteAllPartitions()
        # Add new partitions
        target_disk.addPartition(partition=boot_partition,
                                 constraint=target_constraint)
        target_disk.addPartition(partition=swap_partition,
                                 constraint=target_constraint)
        target_disk.addPartition(partition=root_partition,
                                 constraint=target_constraint)
        # All the stuff we just did needs to be committed to the disk.
        target_disk.commit()

        return 0

    def format_disk(self, w, devicePath, formattool):

        rc = exec_with_pulse_progress(formattool[0],
                                      [formattool[1],
                                       devicePath],
                                      stdout="/tmp/resize.out",
                                      stderr="/tmp/resize.out",
                                      progress=w);


class BspImage:
    def __init__(self, filename, destdir, disk):
        self.bspfile = "/mnt/stage2/bsp/" + filename
        self.outputdir = destdir
        self.total = 0
        self.list_of_names = ()
        self.tar = None
        self.disk = disk

    def load_bsp(self):
        self.tar = tarfile.open(self.bspfile, "r:gz")
        self.list_of_names = self.tar.getnames()

        self.total = len(self.list_of_names)

    def transfer_files(self, w):
        os.mkdir(INSTALLDEST)
        # FIXME: hard coded
        isys.mount(self.disk + "3", INSTALLDEST, fstype="ext3")
        os.mkdir(INSTALLDEST + "/boot")
        # FIXME: hard coded
        isys.mount(self.disk + "1", INSTALLDEST + "/boot", fstype="ext3")

        for filename in self.list_of_names:
            try:
                f = self.tar.extract(filename, self.outputdir)
                w.set_label(filename)
                w.pulse()
            except KeyError:
                print 'ERROR: Did not find %s in tar archive' % filename

    def get_total_files(self):
        return self.total


class Installer:
    def __init__(self, opt):
        self.options = opt
        self.targetdisk = None
        self.screen = dialog.Dialog(dialog="dialog")
        self.drawMainFrame()
        self.displayWellcome()
        self.prepareDisk()
        self.transferBSP()
        self.installGRUB()
        self.finalSteps()

    def displayWellcome(self):
        self.screen.msgbox(MSG_WELCOME, None, None)

    def drawMainFrame(self):
        '''
        Just the title of main window
        '''
        self.screen.set_background_title(MSG_ROOT)

    def prepareDisk(self):
        #
        # Main Device disk detection
        #
        if self.options.devel:
            self.targetdisk = "/dev/sda"
        else:
            ds = DiskSet()
            self.targetdisk = ds.drive_list()

        self.screen.pause(MSG_DISK_SET % self.targetdisk, None, None, 2)
        #
        # Main device disk partitioning
        #
        if not self.options.devel:
            ds.create_partitions_v2()

        self.screen.gauge_start(MSG_PARTITION, None, None, 1)
        self.screen.gauge_update(10)
        time.sleep(3)
        self.screen.gauge_update(50)
        time.sleep(3)
        self.screen.gauge_update(100, MSG_PART_DONE)
        self.screen.gauge_stop()

        # Format
        self.screen.pause(MSG_BOOTPART_READY, None, None, 2)
        self.screen.gauge_start(MSG_FORMAT_BOOT, None, None, 1)
        self.screen.gauge_update(10)

        if not self.options.devel:
            ds.format_disk(w, self.targetdisk + "1", fstype2tool["ext3"])
        else:
            time.sleep(3)

        self.screen.gauge_update(50)
        time.sleep(3)
        self.screen.gauge_update(100, MSG_FORMAT_OK)
        time.sleep(2)
        self.screen.gauge_stop()

        self.screen.gauge_start(MSG_FORMAT_ROOT, None, None, 1)
        self.screen.gauge_update(10)

        if not self.options.devel:
            ds.format_disk(w, self.targetdisk + "3", fstype2tool["ext3"])
        else:
            time.sleep(3)

        self.screen.gauge_update(50)
        time.sleep(3)
        self.screen.gauge_update(100, MSG_FORMAT_OK)
        time.sleep(2)
        self.screen.gauge_stop()

        self.screen.gauge_start(MSG_FORMAT_SWAP, None, None, 1)
        self.screen.gauge_update(10)
        if not self.options.devel:
            ds.format_disk(w, self.targetdisk + "2", fstype2tool["swap"])
        else:
            time.sleep(3)

        self.screen.gauge_update(50)
        time.sleep(3)
        self.screen.gauge_update(100, MSG_FORMAT_OK)
        time.sleep(2)
        self.screen.gauge_stop()

        return 0

    def transferBSP(self):
        self.screen.gauge_start(MSG_LOADING_BSP, None, None, 1)
        self.screen.gauge_update(10)

        if not self.options.devel:
            tb = BspImage(BSPFILE, INSTALLDEST, self.targetdisk)
            tb.load_bsp()
            total = tb.get_total_files()

        self.screen.gauge_update(10)

        if not self.options.devel:
            tb.transfer_files(w)

        self.screen.gauge_update(10)
        time.sleep(2)
        self.screen.gauge_update(100, MSG_BSP_OK)
        time.sleep(2)
        self.screen.gauge_stop()

        return 0

    def installGRUB(self):
        self.screen.gauge_start(MSG_GRUB, None, None, 1)
        time.sleep(2)
        self.screen.gauge_update(10)

        if not self.options.devel:
            mkdir_p(INSTALLDEST + "/boot/grub/")
            grub_file = INSTALLDEST + "/boot/grub/menu.lst"
            shutil.copy("/usr/share/grub/stage1", "/mnt/disk/boot/grub/stage1")
            shutil.copy("/usr/share/grub/stage2", "/mnt/disk/boot/grub/stage2")

            # FIXME: hard coded
            grubconf = GRUB % (self.targetdisk)
            f = open(grub_file, 'w')
            f.write(grubconf)
            f.close()

            # grub-install here.
            try:
                process = subprocess.Popen('/usr/bin/grub-install',
                                           stdout=subprocess.PIPE,
                                           stderr=subprocess.STDOUT,
                                           shell=True)
                process.wait()
            except:
                os.system("/bin/bash")

        self.screen.gauge_update(50)
        time.sleep(2)
        self.screen.gauge_stop()

    def finalSteps(self):
        self.screen.msgbox(MSG_REBOOT, None, None)
        if self.options.devel:
            print("End of simulation (Dev mode). Bye!")


def main():
    setup_python_path()
    options = parse_args()

    # Custom imports here after custom paths enabled
    if not options.devel:
        import product
        import iutil
        import isys
        import parted
        import minihal

    if options.devel:
        print("Devel mode enabled!")

    if options.verbose:
        print("Verbose mode enabled!")
        print("logging file: /tmp/anaconda.log")

    logging.basicConfig(filename='/tmp/anaconda.log', level=logging.DEBUG)
    log = logging.getLogger("anaconda")

    log.info("Installer runnting, good luck!")

    installer = Installer(options)

    return 0


if __name__ == "__main__":
    sys.exit(main())
