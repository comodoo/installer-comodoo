     1                                  	[map all memdisk_iso_512.map]
     2                                  %define EDD 1
     3                                  %define ELTORITO 1
     4                                  %define SECTORSIZE_LG2 9	; log2(sector size)
     5                                  %include "memdisk.inc"
     1                              <1> ; -*- fundamental -*- (asm-mode sucks)
     2                              <1> ; ****************************************************************************
     3                              <1> ;
     4                              <1> ;  memdisk.inc
     5                              <1> ;
     6                              <1> ;  A program to emulate an INT 13h disk BIOS from a "disk" in extended
     7                              <1> ;  memory.
     8                              <1> ;
     9                              <1> ;   Copyright 2001-2009 H. Peter Anvin - All Rights Reserved
    10                              <1> ;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
    11                              <1> ;   Portions copyright 2009 Shao Miller [El Torito code, mBFT, safe hook]
    12                              <1> ;
    13                              <1> ;  This program is free software; you can redistribute it and/or modify
    14                              <1> ;  it under the terms of the GNU General Public License as published by
    15                              <1> ;  the Free Software Foundation, Inc., 53 Temple Place Ste 330,
    16                              <1> ;  Boston MA 02111-1307, USA; either version 2 of the License, or
    17                              <1> ;  (at your option) any later version; incorporated herein by reference.
    18                              <1> ;
    19                              <1> ; ****************************************************************************
    20                              <1> 
    21                              <1> %include "../version.gen"
     1                              <2> %define VERSION 6.04
     2                              <2> %define VERSION_STR "6.04"
     3                              <2> %define VERSION_MAJOR 6
     4                              <2> %define VERSION_MINOR 4
     5                              <2> %define YEAR 2015
     6                              <2> %define YEAR_STR "2015"
    22                              <1> 
    23                              <1> ; %define DEBUG_TRACERS			; Uncomment to get debugging tracers
    24                              <1> 
    25                              <1> %ifdef DEBUG_TRACERS
    26                              <1> 
    27                              <1> %macro TRACER	1
    28                              <1> 	call debug_tracer
    29                              <1> 	db %1
    30                              <1> %endmacro
    31                              <1> %macro WRITEHEX2 0-1 al
    32                              <1> %ifnidni %1,al
    33                              <1> 	push ax
    34                              <1> 	mov al,%1
    35                              <1> 	call writehex2
    36                              <1> 	pop ax
    37                              <1> %else
    38                              <1> 	call writehex2
    39                              <1> %endif
    40                              <1> %endmacro
    41                              <1> %macro WRITEHEX4 0-1 ax
    42                              <1> %ifnidni %1,ax
    43                              <1> 	push ax
    44                              <1> 	mov ax,%1
    45                              <1> 	call writehex4
    46                              <1> 	pop ax
    47                              <1> %else
    48                              <1> 	call writehex4
    49                              <1> %endif
    50                              <1> %endmacro
    51                              <1> %macro WRITEHEX8 0-1 eax
    52                              <1> %ifnidni %1,eax
    53                              <1> 	push eax
    54                              <1> 	mov eax,%1
    55                              <1> 	call writehex8
    56                              <1> 	pop eax
    57                              <1> %else
    58                              <1> 	call writehex8
    59                              <1> %endif
    60                              <1> %endmacro
    61                              <1> 
    62                              <1> %else	; DEBUG_TRACERS
    63                              <1> 
    64                              <1> %macro	TRACER	1
    65                              <1> %endmacro
    66                              <1> %macro WRITEHEX2 0-1
    67                              <1> %endmacro
    68                              <1> %macro WRITEHEX4 0-1
    69                              <1> %endmacro
    70                              <1> %macro WRITEHEX8 0-1
    71                              <1> %endmacro
    72                              <1> 
    73                              <1> %endif	; DEBUG_TRACERS
    74                              <1> 
    75                              <1> ; Flags we test our configuration against
    76                              <1> %define CONFIG_READONLY	0x01
    77                              <1> %define CONFIG_RAW	0x02
    78                              <1> %define CONFIG_SAFEINT	0x04
    79                              <1> %define CONFIG_BIGRAW	0x08		; MUST be 8!
    80                              <1> 
    81                              <1> 		org 0h
    82                              <1> 
    83                              <1> %define	SECTORSIZE	(1 << SECTORSIZE_LG2)
    84                              <1> 
    85                              <1> 		; Parameter registers definition; this is the definition
    86                              <1> 		; of the stack frame.
    87                              <1> %define		P_DS		word [bp+34]
    88                              <1> %define		P_ES		word [bp+32]
    89                              <1> %define		P_EAX		dword [bp+28]
    90                              <1> %define		P_HAX		word [bp+30]
    91                              <1> %define		P_AX		word [bp+28]
    92                              <1> %define		P_AL		byte [bp+28]
    93                              <1> %define		P_AH		byte [bp+29]
    94                              <1> %define		P_ECX		dword [bp+24]
    95                              <1> %define		P_HCX		word [bp+26]
    96                              <1> %define		P_CX		word [bp+24]
    97                              <1> %define		P_CL		byte [bp+24]
    98                              <1> %define		P_CH		byte [bp+25]
    99                              <1> %define		P_EDX		dword [bp+20]
   100                              <1> %define		P_HDX		word [bp+22]
   101                              <1> %define		P_DX		word [bp+20]
   102                              <1> %define		P_DL		byte [bp+20]
   103                              <1> %define		P_DH		byte [bp+21]
   104                              <1> %define		P_EBX		dword [bp+16]
   105                              <1> %define		P_HBX		word [bp+18]
   106                              <1> %define		P_HBXL		byte [bp+18]
   107                              <1> %define		P_BX		word [bp+16]
   108                              <1> %define		P_BL		byte [bp+16]
   109                              <1> %define		P_BH		byte [bp+17]
   110                              <1> %define		P_EBP		dword [bp+8]
   111                              <1> %define		P_BP		word [bp+8]
   112                              <1> %define		P_ESI		dword [bp+4]
   113                              <1> %define		P_SI		word [bp+4]
   114                              <1> %define		P_EDI		dword [bp]
   115                              <1> %define		P_DI		word [bp]
   116                              <1> 
   117                              <1> 		section .text
   118                              <1> 		; These pointers are used by the installer and
   119                              <1> 		; must be first in the binary
   120 00000000 [0A00]              <1> Pointers:	dw Int13Start
   121 00000002 [FD03]              <1> 		dw Int15Start
   122 00000004 [1801]              <1> 		dw MemDisk_Info		; Portions are patched by installer
   123 00000006 [D401]              <1> 		dw TotalSize
   124 00000008 [BD00]              <1> 		dw IretPtr
   125                              <1> 
   126                              <1> IretPtr		equ Int13Start.iret
   127                              <1> Int13Start:
   128 0000000A E91C00              <1> 		jmp strict near .SafeHookEnd ; 3-byte jump
   129 0000000D 24494E5431335346    <1> 		db '$INT13SF'		; Signature for "safe hook"
   130 00000015 4D454D4449534B20    <1> 		db 'MEMDISK '		; Vendor ID
   131 0000001D 00000000            <1> 		dd 0			; SEG:OFF of previous INT 13h hook
   132                              <1> 					; Must be filled in by installer
   133 00000021 00000000            <1> 		dd 0			; "Safe hook" flags
   134                              <1> ; ---- "Safe hook" structure ends here ---
   135                              <1> 
   136                              <1> ; This next field should be guaranteed at this position after the
   137                              <1> ; "safe hook" structure.  This allows for a MEMDISK OS driver to
   138                              <1> ; immediately find out the particular parameters using the mBFT
   139                              <1> ; and MDI structures.  This binary will have the offset to the mBFT
   140                              <1> ; in this field to begin with, so the installer knows where the mBFT
   141                              <1> ; is.  This is akin to the "Pointers" section above.  The installer
   142                              <1> ; will refill this field with the physical address of the mBFT for
   143                              <1> ; future consumers, such as OS drivers.
   144 00000025 [F0000000]          <1> 		dd mBFT			; Offset from hook to the mBFT
   145                              <1> 
   146                              <1> .SafeHookEnd:
   147 00000029 2E833E[D001]00      <1> 		cmp word [cs:Recursive],0
   148 0000002F 0F858B00            <1> 		jne recursive
   149                              <1> 
   150                              <1> 		; Swap stack
   151 00000033 2E668926[C801]      <1> 		mov [cs:Stack],esp
   152 00000039 2E8C16[CC01]        <1> 		mov [cs:Stack+4],ss
   153 0000003E 2EA3[CE01]          <1> 		mov [cs:SavedAX],ax
   154 00000042 8CC8                <1> 		mov ax,cs
   155 00000044 8ED0                <1> 		mov ss,ax
   156 00000046 2E8B26[5001]        <1> 		mov sp,[cs:MyStack]
   157                              <1> 
   158                              <1> %if ELTORITO
   159 0000004B 2E813E[CE01]004A    <1> 		cmp word [cs:SavedAX],4a00h	; El Torito function?
   160 00000052 736F                <1> 		jae our_drive			; We grab it
   161                              <1> %endif
   162                              <1> 		; See if DL points to our class of device (FD, HD)
   163 00000054 52                  <1> 		push dx
   164 00000055 52                  <1> 		push dx
   165 00000056 2E3216[4C01]        <1> 		xor dl,[cs:DriveNo]
   166 0000005B 5A                  <1> 		pop dx
   167 0000005C 7812                <1> 		js .nomatch		; If SF=0, we have a class match here
   168                              <1> 					; 0x00 the sign bit for FD
   169                              <1> 					; 0x80 the sign bit for HD
   170 0000005E 7463                <1> 		jz our_drive		; If ZF=1, we have an exact match
   171 00000060 2E3A16[4C01]        <1> 		cmp dl,[cs:DriveNo]
   172 00000065 7209                <1> 		jb .nomatch		; Drive < Our drive
   173 00000067 2E3A16[3601]        <1> 		cmp dl,[cs:DriveShiftLimit]
   174 0000006C 7302                <1> 		jae .nomatch		; Drive > The maximum drive
   175                              <1> 					; number that we will shift for.
   176                              <1> 					; This leaves any higher-up BIOS
   177                              <1> 					; drives alone, such as an optical
   178                              <1> 					; disc drive 0xA0 or 0xE0
   179 0000006E FECA                <1> 		dec dl			; Drive > Our drive, adjust drive #
   180                              <1> .nomatch:
   181                              <1> 		TRACER '!'
   182                              <1> 		WRITEHEX2 dl
   183                              <1> 		TRACER ','
   184 00000070 2EA1[CE01]          <1> 		mov ax,[cs:SavedAX]
   185                              <1> 		WRITEHEX4
   186 00000074 2EFF06[D001]        <1> 		inc word [cs:Recursive]
   187 00000079 9C                  <1> 		pushf
   188 0000007A 2EFF1E[2801]        <1> 		call far [cs:OldInt13]
   189 0000007F 9C                  <1> 		pushf
   190 00000080 2EFF0E[D001]        <1> 		dec word [cs:Recursive]
   191 00000085 55                  <1> 		push bp
   192 00000086 89E5                <1> 		mov bp,sp
   193 00000088 2E803E[CF01]08      <1> 		cmp byte [cs:SavedAX+1],08h	; Get drive params function?
   194 0000008E 7411                <1> 		je .norestoredl			; DL = number of drives
   195 00000090 2E803E[CF01]15      <1> 		cmp byte [cs:SavedAX+1],15h	; Get disk type function?
   196 00000096 7506                <1> 		jne .restoredl
   197 00000098 F6460480            <1> 		test byte [bp+4],80h		; Hard disk?
   198 0000009C 7503                <1> 		jnz .norestoredl		; CX:DX = size of device
   199                              <1> .restoredl:
   200 0000009E 8A5604              <1> 		mov dl,[bp+4]
   201                              <1> .norestoredl:
   202 000000A1 50                  <1> 		push ax
   203 000000A2 6653                <1> 		push ebx
   204 000000A4 1E                  <1> 		push ds
   205 000000A5 8B4602              <1> 		mov ax,[bp+2]		; Flags
   206 000000A8 2E66C51E[C801]      <1> 		lds ebx,[cs:Stack]
   207 000000AE 884704              <1> 		mov [bx+4],al		; Arithmetic flags
   208 000000B1 1F                  <1> 		pop ds
   209 000000B2 665B                <1> 		pop ebx
   210 000000B4 58                  <1> 		pop ax
   211 000000B5 5D                  <1> 		pop bp
   212 000000B6 2E660FB226[C801]    <1> 		lss esp,[cs:Stack]
   213 000000BD CF                  <1> .iret:		iret
   214                              <1> 
   215                              <1> recursive:
   216                              <1> 		TRACER '@'
   217                              <1> jmp_oldint13:
   218 000000BE 2EFF2E[2801]        <1> 		jmp far [cs:OldInt13]
   219                              <1> 
   220                              <1> our_drive:
   221                              <1> 		; Set up standard entry frame
   222 000000C3 1E                  <1> 		push ds
   223 000000C4 06                  <1> 		push es
   224 000000C5 8ED8                <1> 		mov ds,ax
   225 000000C7 8EC0                <1> 		mov es,ax
   226 000000C9 A1[CE01]            <1> 		mov ax,[SavedAX]
   227 000000CC 6660                <1> 		pushad
   228 000000CE 89E5                <1> 		mov bp,sp		; Point BP to the entry stack frame
   229                              <1> 		TRACER 'F'
   230                              <1> 		WRITEHEX4
   231                              <1> 		; Note: AX == P_AX here
   232 000000D0 80FC4D              <1> 		cmp ah,Int13FuncsCnt-1
   233 000000D3 7768                <1> 		ja Invalid_jump
   234                              <1> %if ELTORITO
   235 000000D5 A0[B301]            <1> 		mov al,[CD_PKT.type]	; Check if we are in
   236 000000D8 3C00                <1> 		cmp al,0		; El Torito no emulation mode
   237 000000DA 7705                <1> 		ja .emulation		; No.  We support the function
   238 000000DC 80FC3F              <1> 		cmp ah,3fh		; Yes.  We must not support functions
   239 000000DF 765C                <1> 		jbe Invalid_jump	; 0 through 3Fh.  Check and decide
   240                              <1> .emulation:
   241                              <1> %endif
   242 000000E1 30C0                <1> 		xor al,al		; AL = 0 is standard entry condition
   243 000000E3 89C7                <1> 		mov di,ax
   244 000000E5 C1EF07              <1> 		shr di,7		; Convert AH to an offset in DI
   245 000000E8 FF95[0000]          <1> 		call [Int13Funcs+di]
   246                              <1> 
   247                              <1> Done:		; Standard routine for return
   248 000000EC 89461C              <1> 		mov P_AX,ax
   249                              <1> DoneWeird:
   250                              <1> 		TRACER 'D'
   251 000000EF 31DB                <1> 		xor bx,bx
   252 000000F1 8EC3                <1> 		mov es,bx
   253 000000F3 8B1E[5201]          <1> 		mov bx,[StatusPtr]
   254 000000F7 268827              <1> 		mov [es:bx],ah		; Save status
   255 000000FA 20E4                <1> 		and ah,ah
   256                              <1> 
   257 000000FC 66C51E[C801]        <1> 		lds ebx,[Stack]
   258                              <1> 		; This sets the low byte (the arithmetic flags) of the
   259                              <1> 		; FLAGS on stack to either 00h (no flags) or 01h (CF)
   260                              <1> 		; depending on if AH was zero or not.
   261 00000101 0F954704            <1> 		setnz [bx+4]		; Set CF iff error
   262 00000105 6661                <1> 		popad
   263 00000107 07                  <1> 		pop es
   264 00000108 1F                  <1> 		pop ds
   265 00000109 2E660FB226[C801]    <1> 		lss esp,[cs:Stack]
   266 00000110 CF                  <1> 		iret
   267                              <1> 
   268                              <1> Reset:
   269                              <1> 		; Reset affects multiple drives, so we need to pass it on
   270                              <1> 		TRACER 'R'
   271 00000111 31C0                <1> 		xor ax,ax		; Bottom of memory
   272 00000113 8EC0                <1> 		mov es,ax
   273 00000115 84D2                <1> 		test dl,dl		; Always pass it on if we are
   274                              <1> 					; resetting HD
   275 00000117 780A                <1> 		js .hard_disk		; Bit 7 set
   276                              <1> 		; Some BIOSes get very unhappy if we pass a reset floppy
   277                              <1> 		; command to them and don't actually have any floppies.
   278                              <1> 		; This is a bug, but we have to deal with it nontheless.
   279                              <1> 		; Therefore, if we are the *ONLY* floppy drive, and the
   280                              <1> 		; user didn't request HD reset, then just drop the command.
   281                              <1> 		; BIOS equipment byte, top two bits + 1 == total # of floppies
   282 00000119 26F6061004C0        <1> 		test byte [es:0x410],0C0h
   283 0000011F 746B                <1> 		jz success
   284 00000121 EB08                <1> 		jmp .pass_on		; ... otherwise pass it to the BIOS
   285                              <1> .hard_disk:
   286                              <1> 		; ... same thing for hard disks, sigh ...
   287 00000123 26803E750401        <1> 		cmp byte [es:0x475],1	; BIOS variable for number of hard
   288                              <1> 					; disks
   289 00000129 7661                <1> 		jbe success
   290                              <1> 
   291                              <1> .pass_on:
   292 0000012B 58                  <1> 		pop ax			; Drop return address
   293 0000012C 6661                <1> 		popad			; Restore all registers
   294 0000012E 07                  <1> 		pop es
   295 0000012F 1F                  <1> 		pop ds
   296 00000130 2E660FB226[C801]    <1> 		lss esp,[cs:Stack]	; Restore the stack
   297 00000137 80E280              <1> 		and dl,80h		; Clear all but the type bit
   298 0000013A EB82                <1> 		jmp jmp_oldint13
   299                              <1> 
   300                              <1> 
   301                              <1> Invalid:
   302 0000013C 5A                  <1> 		pop dx			; Drop return address
   303                              <1> Invalid_jump:
   304                              <1> 		TRACER 'I'
   305 0000013D B401                <1> 		mov ah,01h		; Unsupported function
   306 0000013F EBAB                <1> 		jmp short Done
   307                              <1> 
   308                              <1> GetDriveType:
   309 00000141 F606[4C01]80        <1> 		test byte [DriveNo],80h
   310 00000146 B302                <1> 		mov bl,02h		; Type 02h = floppy with changeline
   311 00000148 740F                <1> 		jz .floppy
   312                              <1> 		; Hard disks only!  DO NOT set CX:DX for floppies...
   313                              <1> 		; it apparently causes Win98SE DOS to go into an loop
   314                              <1> 		; resetting the drive over and over.  Sigh.
   315 0000014A 43                  <1> 		inc bx			; Type = 03h
   316 0000014B 8B16[2001]          <1> 		mov dx,[DiskSize]	; Return the disk size in sectors
   317 0000014F 895614              <1> 		mov P_DX,dx
   318 00000152 8B0E[2201]          <1> 		mov cx,[DiskSize+2]
   319 00000156 894E18              <1> 		mov P_CX,cx
   320                              <1> .floppy:
   321 00000159 885E1D              <1> 		mov P_AH,bl		; 02h floppy, 03h hard disk
   322 0000015C 58                  <1> 		pop ax			; Drop return address
   323 0000015D 31C0                <1> 		xor ax,ax		; Success...
   324 0000015F EB8E                <1> 		jmp DoneWeird		; But don't stick it into P_AX
   325                              <1> 
   326                              <1> GetStatus:
   327 00000161 31C0                <1> 		xor ax,ax
   328 00000163 8EC0                <1> 		mov es,ax
   329 00000165 8B1E[5201]          <1> 		mov bx,[StatusPtr]
   330 00000169 8A27                <1> 		mov ah,[bx]		; Copy last status
   331 0000016B C3                  <1> 		ret
   332                              <1> 
   333                              <1> ReadMult:
   334                              <1> 		TRACER 'm'
   335                              <1> Read:
   336                              <1> 		TRACER 'R'
   337 0000016C E8EE00              <1> 		call setup_regs
   338                              <1> do_copy:
   339                              <1> 		TRACER '<'
   340 0000016F E8D202              <1> 		call bcopy
   341                              <1> 		TRACER '>'
   342 00000172 0FB6461C            <1> 		movzx ax,P_AL		; AH = 0, AL = transfer count
   343 00000176 C3                  <1> 		ret
   344                              <1> 
   345                              <1> WriteMult:
   346                              <1> 		TRACER 'M'
   347                              <1> Write:
   348                              <1> 		TRACER 'W'
   349 00000177 F606[4F01]01        <1> 		test byte [ConfigFlags],CONFIG_READONLY
   350 0000017C 7508                <1> 		jnz .readonly
   351 0000017E E8DC00              <1> 		call setup_regs
   352 00000181 6687F7              <1> 		xchg esi,edi		; Opposite direction of a Read!
   353 00000184 EBE9                <1> 		jmp short do_copy
   354 00000186 B403                <1> .readonly:	mov ah,03h		; Write protected medium
   355 00000188 C3                  <1> 		ret
   356                              <1> 
   357                              <1> 		; Verify integrity; just bounds-check
   358                              <1> Seek:
   359                              <1> Verify:
   360 00000189 E8D100              <1> 		call setup_regs		; Returns error if appropriate
   361                              <1> 		; And fall through to success
   362                              <1> 
   363                              <1> CheckIfReady:				; These are always-successful noop functions
   364                              <1> Recalibrate:
   365                              <1> InitWithParms:
   366                              <1> DetectChange:
   367                              <1> EDDDetectChange:
   368                              <1> EDDLock:
   369                              <1> SetMode:
   370                              <1> success:
   371 0000018C 31C0                <1> 		xor ax,ax		; Always successful
   372 0000018E C3                  <1> 		ret
   373                              <1> 
   374                              <1> GetParms:
   375                              <1> 		TRACER 'G'
   376 0000018F 8A16[4E01]          <1> 		mov dl,[DriveCnt]	; Cached data
   377 00000193 885614              <1> 		mov P_DL,dl
   378 00000196 F606[4C01]80        <1> 		test byte [DriveNo],80h
   379 0000019B 750F                <1> 		jnz .hd
   380 0000019D C74600[5401]        <1> 		mov P_DI,DPT
   381 000001A2 8C4E20              <1> 		mov P_ES,cs
   382 000001A5 8A1E[4D01]          <1> 		mov bl,[DriveType]
   383 000001A9 885E10              <1> 		mov P_BL,bl
   384                              <1> .hd:
   385 000001AC A1[3C01]            <1> 		mov ax,[Cylinders]
   386 000001AF 48                  <1> 		dec ax			; We report the highest #, not the count
   387 000001B0 86C4                <1> 		xchg al,ah
   388 000001B2 C0E006              <1> 		shl al,6
   389 000001B5 0A06[4001]          <1> 		or al,[Sectors]
   390 000001B9 894618              <1> 		mov P_CX,ax
   391 000001BC A1[3E01]            <1> 		mov ax,[Heads]
   392 000001BF 48                  <1> 		dec ax
   393 000001C0 884615              <1> 		mov P_DH,al
   394                              <1> 
   395                              <1> 		;
   396                              <1> 		; Is this MEMDISK installation check?
   397                              <1> 		;
   398 000001C3 817E1E4D45          <1> 		cmp P_HAX,'ME'
   399 000001C8 7531                <1> 		jne .notic
   400 000001CA 817E1A4D44          <1> 		cmp P_HCX,'MD'
   401 000001CF 752A                <1> 		jne .notic
   402 000001D1 817E164953          <1> 		cmp P_HDX,'IS'
   403 000001D6 7523                <1> 		jne .notic
   404 000001D8 817E124B3F          <1> 		cmp P_HBX,'K?'
   405 000001DD 751C                <1> 		jne .notic
   406                              <1> 
   407                              <1> 		; MEMDISK installation check...
   408 000001DF C7461E214D          <1> 		mov P_HAX,'!M'
   409 000001E4 C7461A454D          <1> 		mov P_HCX,'EM'
   410 000001E9 C746164449          <1> 		mov P_HDX,'DI'
   411 000001EE C74612534B          <1> 		mov P_HBX,'SK'
   412 000001F3 8C4E20              <1> 		mov P_ES,cs
   413 000001F6 C74600[1801]        <1> 		mov P_DI,MemDisk_Info
   414                              <1> 
   415                              <1> .notic:
   416 000001FB 31C0                <1> 		xor ax,ax
   417 000001FD C3                  <1> 		ret
   418                              <1> ;
   419                              <1> ; EDD functions -- only if enabled
   420                              <1> ;
   421                              <1> %if EDD
   422                              <1> EDDPresence:
   423                              <1> 		TRACER 'E'
   424                              <1> 		TRACER 'c'
   425                              <1> 
   426 000001FE 817E10AA55          <1> 		cmp P_BX,55AAh
   427 00000203 0F8535FF            <1> 		jne Invalid
   428 00000207 C7461055AA          <1> 		mov P_BX,0AA55h		; EDD signature
   429 0000020C C7461C0030          <1> 		mov P_AX,03000h		; EDD 3.0
   430 00000211 C746180700          <1> 		mov P_CX,0007h		; Bit 0 - Fixed disk access subset
   431                              <1> 					; Bit 1 - Locking and ejecting subset
   432                              <1> 					; Bit 2 - EDD subset
   433 00000216 58                  <1> 		pop ax			; Drop return address
   434 00000217 31C0                <1> 		xor ax,ax		; Success
   435 00000219 E9D3FE              <1> 		jmp DoneWeird		; Success, but AH != 0, sigh...
   436                              <1> 
   437                              <1> EDDRead:
   438                              <1> 		TRACER 'E'
   439                              <1> 		TRACER 'r'
   440                              <1> 
   441 0000021C E8A600              <1> 		call edd_setup_regs
   442 0000021F E82202              <1> 		call bcopy
   443 00000222 31C0                <1> 		xor ax,ax
   444 00000224 C3                  <1> 		ret
   445                              <1> 
   446                              <1> EDDWrite:
   447                              <1> 		TRACER 'E'
   448                              <1> 		TRACER 'w'
   449                              <1> 
   450 00000225 E89D00              <1> 		call edd_setup_regs
   451 00000228 6687F7              <1> 		xchg esi,edi		; Opposite direction of a Read!
   452 0000022B E81602              <1> 		call bcopy
   453 0000022E 31C0                <1> 		xor ax,ax
   454 00000230 C3                  <1> 		ret
   455                              <1> 
   456                              <1> EDDVerify:
   457                              <1> EDDSeek:
   458 00000231 E89100              <1> 		call edd_setup_regs	; Just bounds checking
   459 00000234 31C0                <1> 		xor ax,ax
   460 00000236 C3                  <1> 		ret
   461                              <1> 
   462                              <1> EDDGetParms:
   463                              <1> 		TRACER 'E'
   464                              <1> 		TRACER 'p'
   465                              <1> 
   466 00000237 8E4622              <1> 		mov es,P_DS
   467 0000023A 8B7E04              <1> 		mov di,P_SI
   468 0000023D BE[6801]            <1> 		mov si,EDD_DPT
   469                              <1> 
   470 00000240 AD                  <1> 		lodsw			; Length of our DPT
   471 00000241 268B0D              <1> 		mov cx,[es:di]
   472 00000244 83F91A              <1> 		cmp cx,26		; Minimum size
   473 00000247 7210                <1> 		jb .overrun
   474                              <1> 
   475 00000249 39C1                <1> 		cmp cx,ax
   476 0000024B 7202                <1> 		jb .oksize
   477 0000024D 89C1                <1> 		mov cx,ax
   478                              <1> 
   479                              <1> .oksize:
   480 0000024F 89C8                <1> 		mov ax,cx
   481 00000251 AB                  <1> 		stosw
   482 00000252 49                  <1> 		dec cx
   483 00000253 49                  <1> 		dec cx
   484 00000254 F3A4                <1> 		rep movsb
   485                              <1> 
   486 00000256 31C0                <1> 		xor ax,ax
   487 00000258 C3                  <1> 		ret
   488                              <1> 
   489                              <1> .overrun:
   490 00000259 B80001              <1> 		mov ax,0100h
   491 0000025C C3                  <1> 		ret
   492                              <1> %endif ; EDD
   493                              <1> 
   494                              <1> 		; Set up registers as for a "Read", and compares against disk
   495                              <1> 		; size.
   496                              <1> 		; WARNING: This fails immediately, even if we can transfer some
   497                              <1> 		; sectors.  This isn't really the correct behaviour.
   498                              <1> setup_regs:
   499                              <1> 
   500                              <1> 		; Convert a CHS address in P_CX/P_DH into an LBA in eax
   501                              <1> 		; CH = cyl[7:0]
   502                              <1> 		; CL[0:5] = sector (1-based)  CL[7:6] = cyl[9:8]
   503                              <1> 		; DH = head
   504 0000025D 660FB74E18          <1> 		movzx ecx,P_CX
   505 00000262 660FB6D9            <1> 		movzx ebx,cl		; Sector number
   506 00000266 80E33F              <1> 		and bl,3Fh
   507 00000269 664B                <1> 		dec ebx			; Sector number is 1-based
   508 0000026B 3B1E[4001]          <1> 		cmp bx,[Sectors]
   509 0000026F 734F                <1> 		jae .overrun
   510 00000271 660FB67E15          <1> 		movzx edi,P_DH		; Head number
   511 00000276 660FB706[3E01]      <1> 		movzx eax,word [Heads]
   512 0000027C 39C7                <1> 		cmp di,ax
   513 0000027E 7340                <1> 		jae .overrun
   514 00000280 C0E906              <1> 		shr cl,6
   515 00000283 86CD                <1> 		xchg cl,ch		; Now (E)CX <- cylinder number
   516 00000285 66F7E1              <1> 		mul ecx			; eax <- Heads*cyl# (edx <- 0)
   517 00000288 6601F8              <1> 		add eax,edi
   518 0000028B 66F726[4001]        <1> 		mul dword [Sectors]
   519 00000290 6601D8              <1> 		add eax,ebx
   520                              <1> 		; Now eax = LBA, edx = 0
   521                              <1> 
   522                              <1> 		;
   523                              <1> 		; setup_regs continues...
   524                              <1> 		;
   525                              <1> 		; Note: edi[31:16] and ecx[31:16] = 0 already
   526 00000293 8B7E10              <1> 		mov di,P_BX		; Get linear address of target buffer
   527 00000296 8B4E20              <1> 		mov cx,P_ES
   528 00000299 66C1E104            <1> 		shl ecx,4
   529 0000029D 6601CF              <1> 		add edi,ecx		; EDI = address to fetch to
   530 000002A0 660FB64E1C          <1> 		movzx ecx,P_AL		; Sector count
   531 000002A5 6689C6              <1> 		mov esi,eax
   532 000002A8 6601C8              <1> 		add eax,ecx		; LBA of final sector + 1
   533 000002AB 66C1E609            <1> 		shl esi,SECTORSIZE_LG2	; LBA -> byte offset
   534 000002AF 660336[1C01]        <1> 		add esi,[DiskBuf]	; Get address in high memory
   535 000002B4 663B06[2001]        <1> 		cmp eax,[DiskSize]	; Check the high mark against limit
   536 000002B9 7705                <1> 		ja .overrun
   537 000002BB 66C1E107            <1> 		shl ecx,SECTORSIZE_LG2-2 ; Convert count to dwords
   538 000002BF C3                  <1> 		ret
   539                              <1> 
   540 000002C0 58                  <1> .overrun:	pop ax			; Drop setup_regs return address
   541 000002C1 B80002              <1> 		mov ax,0200h		; Missing address mark
   542 000002C4 C3                  <1> 		ret			; Return to Done
   543                              <1> 
   544                              <1> 		; Set up registers as for an EDD Read, and compares against disk size.
   545                              <1> %if EDD
   546                              <1> edd_setup_regs:
   547 000002C5 06                  <1> 		push es
   548 000002C6 8B7604              <1> 		mov si,P_SI		; DS:SI -> DAPA
   549 000002C9 8E4622              <1> 		mov es,P_DS
   550                              <1> 
   551 000002CC 268B14              <1> 		mov dx,[es:si]
   552 000002CF 83FA10              <1> 		cmp dx,16
   553 000002D2 7266                <1> 		jb .baddapa
   554                              <1> 
   555 000002D4 2666837C04FF        <1> 		cmp dword [es:si+4],-1
   556 000002DA 7415                <1> 		je .linear_address
   557                              <1> 
   558 000002DC 26660FB75C04        <1> 		movzx ebx,word [es:si+4]	; Offset
   559 000002E2 26660FB77C06        <1> 		movzx edi,word [es:si+6]	; Segment
   560 000002E8 66C1E704            <1> 		shl edi,4
   561 000002EC 6601FB              <1> 		add ebx,edi
   562 000002EF EB15                <1> 		jmp .got_address
   563                              <1> 
   564                              <1> .linear_address:
   565 000002F1 83FA18              <1> 		cmp dx,24		; Must be large enough to hold
   566                              <1> 					; linear address
   567 000002F4 7244                <1> 		jb .baddapa
   568                              <1> 
   569 000002F6 2666837C1400        <1> 		cmp dword [es:si+20],0	; > 4 GB addresses not supported
   570 000002FC B80009              <1> 		mov ax,0900h		; "Data boundary error" - bogus, but
   571                              <1> 					; no really better code available
   572 000002FF 7542                <1> 		jne .error
   573                              <1> 
   574 00000301 26668B5C10          <1> 		mov ebx,[es:si+16]
   575                              <1> 
   576                              <1> .got_address:
   577 00000306 2666837C0C00        <1> 		cmp dword [es:si+12],0		; LBA too large?
   578 0000030C 7532                <1> 		jne .overrun
   579                              <1> 
   580 0000030E 26660FB74C02        <1> 		movzx ecx, word [es:si+2]	; Sectors to transfer
   581 00000314 26668B7408          <1> 		mov esi,[es:si+8]		; Starting sector
   582 00000319 6689F0              <1> 		mov eax,esi
   583 0000031C 6601C8              <1> 		add eax,ecx
   584 0000031F 721F                <1> 		jc .overrun
   585 00000321 663B06[2001]        <1> 		cmp eax,[DiskSize]
   586 00000326 7718                <1> 		ja .overrun
   587                              <1> 
   588 00000328 66C1E107            <1> 		shl ecx,SECTORSIZE_LG2-2	; Convert to dwords
   589 0000032C 66C1E609            <1> 		shl esi,SECTORSIZE_LG2		; Convert to an offset
   590 00000330 660336[1C01]        <1> 		add esi,[DiskBuf]
   591 00000335 6689DF              <1> 		mov edi,ebx
   592 00000338 07                  <1> 		pop es
   593 00000339 C3                  <1> 		ret
   594                              <1> 
   595                              <1> .baddapa:
   596 0000033A B80001              <1> 		mov ax,0100h		; Invalid command
   597 0000033D 07                  <1> 		pop es
   598 0000033E 58                  <1> 		pop ax			; Drop setup_regs return address
   599 0000033F C3                  <1> 		ret
   600                              <1> 
   601                              <1> .overrun:
   602 00000340 B80002              <1> 		mov ax,0200h		; "Address mark not found" =
   603                              <1> 					; LBA beyond end of disk
   604                              <1> .error:
   605 00000343 2683640200          <1> 		and word [es:si+2],0	; No sectors transferred
   606 00000348 07                  <1> 		pop es
   607 00000349 58                  <1> 		pop ax
   608 0000034A C3                  <1> 		ret
   609                              <1> 
   610                              <1> EDDEject:
   611 0000034B B800B2              <1> 		mov ax,0B200h		; Volume Not Removable
   612 0000034E C3                  <1> 		ret
   613                              <1> %if ELTORITO
   614                              <1> ElToritoTerminate:
   615                              <1> 		TRACER 'T'
   616 0000034F 2EA1[CE01]          <1> 		mov ax,[cs:SavedAX]
   617 00000353 3C01                <1> 		cmp al,1		; We only support query, not terminate
   618 00000355 7522                <1> 		jne ElToritoErr		; Fail
   619 00000357 80FA7F              <1> 		cmp dl,7fh		; Terminate all?
   620 0000035A 7409                <1> 		je .doit
   621 0000035C 2E3A16[4C01]        <1> 		cmp dl,[cs:DriveNo]	; Terminate our drive?
   622 00000361 7402                <1> 		je .doit
   623 00000363 EB14                <1> 		jmp ElToritoErr		; Fail
   624 00000365 8E4622              <1> .doit:		mov es,P_DS		; Caller's DS:SI pointed to packet
   625 00000368 8B7E04              <1> 		mov di,P_SI		; We'll use ES:DI
   626 0000036B BE[B201]            <1> 		mov si,CD_PKT.size	; First byte is packet size
   627 0000036E 83F100              <1> 		xor cx,0		; Empty our count
   628                              <1> 		;mov cl,[ds:si]		; We'll copy that many bytes
   629 00000371 B113                <1> 		mov cl,13h
   630 00000373 F3A4                <1> 		rep movsb		; Copy until CX is zero
   631 00000375 B80000              <1> 		mov ax,0		; Success
   632 00000378 C3                  <1> 		ret
   633                              <1> ElToritoEmulate:
   634                              <1> ElToritoBoot:
   635                              <1> ElToritoCatalog:
   636                              <1> ElToritoErr:
   637                              <1> 		TRACER '!'
   638 00000379 B80001              <1> 		mov ax,100h		; Invalid parameter
   639 0000037C C3                  <1> 		ret
   640                              <1> %endif ; ELTORITO
   641                              <1> %endif ; EDD
   642                              <1> 
   643                              <1> ;
   644                              <1> ; INT 15h intercept routines
   645                              <1> ;
   646                              <1> int15_e820:
   647 0000037D 6681FA50414D53      <1> 		cmp edx,534D4150h	; "SMAP"
   648 00000384 0F858E00            <1> 		jne oldint15
   649 00000388 6683F914            <1> 		cmp ecx,20		; Need 20 bytes
   650 0000038C 7267                <1> 		jb err86
   651 0000038E 1E                  <1> 		push ds
   652 0000038F 0E                  <1> 		push cs
   653 00000390 1F                  <1> 		pop ds
   654 00000391 6652                <1> 		push edx		; "SMAP"
   655 00000393 6621DB              <1> 		and ebx,ebx
   656 00000396 7506                <1> 		jne .renew
   657 00000398 66BB[D4010000]      <1> 		mov ebx,E820Table
   658                              <1> .renew:
   659 0000039E 83C30C              <1> 		add bx,12		; Advance to next
   660 000003A1 668B47FC            <1> 		mov eax,[bx-4]		; Type
   661 000003A5 6621C0              <1> 		and eax,eax		; Null type?
   662 000003A8 74F4                <1> 		jz .renew		; If so advance to next
   663 000003AA 2666894510          <1> 		mov [es:di+16],eax
   664 000003AF 668B47F4            <1> 		mov eax,[bx-12]		; Start addr (low)
   665 000003B3 668B57F8            <1> 		mov edx,[bx-8]		; Start addr (high)
   666 000003B7 26668905            <1> 		mov [es:di],eax
   667 000003BB 2666895504          <1> 		mov [es:di+4],edx
   668 000003C0 668B07              <1> 		mov eax,[bx]		; End addr (low)
   669 000003C3 668B5704            <1> 		mov edx,[bx+4]		; End addr (high)
   670 000003C7 662B47F4            <1> 		sub eax,[bx-12]		; Derive the length
   671 000003CB 661B57F8            <1> 		sbb edx,[bx-8]
   672 000003CF 2666894508          <1> 		mov [es:di+8],eax	; Length (low)
   673 000003D4 266689550C          <1> 		mov [es:di+12],edx	; Length (high)
   674 000003D9 66837F08FF          <1> 		cmp dword [bx+8],-1	; Type of next = end?
   675 000003DE 7503                <1> 		jne .notdone
   676 000003E0 6631DB              <1> 		xor ebx,ebx		; Done with table
   677                              <1> .notdone:
   678 000003E3 6658                <1> 		pop eax			; "SMAP"
   679 000003E5 6689C2              <1> 		mov edx,eax		; Some systems expect eax = edx = SMAP
   680 000003E8 66B914000000        <1> 		mov ecx,20		; Bytes loaded
   681 000003EE 1F                  <1> 		pop ds
   682                              <1> int15_success:
   683 000003EF C6460602            <1> 		mov byte [bp+6], 02h	; Clear CF
   684 000003F3 5D                  <1> 		pop bp
   685 000003F4 CF                  <1> 		iret
   686                              <1> 
   687                              <1> err86:
   688 000003F5 C6460603            <1> 		mov byte [bp+6], 03h	; Set CF
   689 000003F9 B486                <1> 		mov ah,86h
   690 000003FB 5D                  <1> 		pop bp
   691 000003FC CF                  <1> 		iret
   692                              <1> 
   693                              <1> Int15Start:
   694 000003FD 55                  <1> 		push bp
   695 000003FE 89E5                <1> 		mov bp,sp
   696 00000400 3D20E8              <1> 		cmp ax,0E820h
   697 00000403 0F8476FF            <1> 		je near int15_e820
   698 00000407 3D01E8              <1> 		cmp ax,0E801h
   699 0000040A 7410                <1> 		je int15_e801
   700 0000040C 3D81E8              <1> 		cmp ax,0E881h
   701 0000040F 741A                <1> 		je int15_e881
   702 00000411 80FC88              <1> 		cmp ah,88h
   703 00000414 7428                <1> 		je int15_88
   704 00000416 5D                  <1> oldint15:	pop bp
   705 00000417 2EFF2E[2C01]        <1> 		jmp far [cs:OldInt15]
   706                              <1> 
   707                              <1> int15_e801:				; Get mem size for > 64 MB config
   708 0000041C 2EA1[4401]          <1> 		mov ax,[cs:Mem1MB]
   709 00000420 89C1                <1> 		mov cx,ax
   710 00000422 2E8B1E[4801]        <1> 		mov bx,[cs:Mem16MB]
   711 00000427 89DA                <1> 		mov dx,bx
   712 00000429 EBC4                <1> 		jmp short int15_success
   713                              <1> 
   714                              <1> int15_e881:				; Get mem size for > 64 MB config
   715                              <1> 					; 32-bit code
   716 0000042B 2E66A1[4401]        <1> 		mov eax,[cs:Mem1MB]
   717 00000430 6689C1              <1> 		mov ecx,eax
   718 00000433 2E668B1E[4801]      <1> 		mov ebx,[cs:Mem16MB]
   719 00000439 6689DA              <1> 		mov edx,ebx
   720 0000043C EBB1                <1> 		jmp short int15_success
   721                              <1> 
   722                              <1> int15_88:				; Get extended mem size
   723 0000043E 2EA1[3A01]          <1> 		mov ax,[cs:MemInt1588]
   724 00000442 EBAB                <1> 		jmp short int15_success
   725                              <1> 
   726                              <1> ;
   727                              <1> ; Routine to copy in/out of high memory
   728                              <1> ; esi = linear source address
   729                              <1> ; edi = linear target address
   730                              <1> ; ecx = 32-bit word count
   731                              <1> ;
   732                              <1> ; Assumes cs = ds = es
   733                              <1> ;
   734                              <1> bcopy:
   735 00000444 6650                <1> 		push eax
   736 00000446 6653                <1> 		push ebx
   737 00000448 6652                <1> 		push edx
   738 0000044A 6655                <1> 		push ebp
   739                              <1> 
   740 0000044C BB[5705]            <1> 		mov bx, real_int15_stub
   741                              <1> 
   742 0000044F F606[4F01]06        <1> 		test byte [ConfigFlags], CONFIG_RAW|CONFIG_SAFEINT
   743 00000454 0F849900            <1> 		jz .anymode		; Always do the real INT 15h
   744                              <1> 
   745 00000458 0F01E0              <1> 		smsw ax			; Unprivileged!
   746 0000045B A801                <1> 		test al,01h
   747 0000045D 0F859000            <1> 		jnz .protmode		; Protmode -> do real INT 15h
   748                              <1> 
   749                              <1> .realmode:
   750                              <1> 		; Raw or Safeint mode, and we're in real mode...
   751                              <1> 
   752 00000461 F606[4F01]04        <1> 		test byte [ConfigFlags], CONFIG_SAFEINT
   753 00000466 0F858400            <1> 		jnz .fakeint15
   754                              <1> 
   755                              <1> .raw:
   756                              <1> 		TRACER 'r'
   757                              <1> 		; We're in real mode, do it outselves
   758                              <1> 
   759 0000046A 669C                <1> 		pushfd			; <A>
   760 0000046C 1E                  <1> 		push ds			; <B>
   761 0000046D 06                  <1> 		push es			; <C>
   762                              <1> 
   763 0000046E FA                  <1> 		cli
   764 0000046F FC                  <1> 		cld
   765                              <1> 
   766 00000470 6631DB              <1> 		xor ebx,ebx
   767 00000473 8CCB                <1> 		mov bx,cs
   768 00000475 66C1E304            <1> 		shl ebx,4
   769 00000479 66678D93[A0000000]  <1> 		lea edx,[Shaker+ebx]
   770 00000481 668916[A200]        <1> 		mov [Shaker+2],edx
   771                              <1> 
   772                              <1> 		; Test to see if A20 is enabled or not
   773 00000486 31C0                <1> 		xor ax,ax
   774 00000488 8ED8                <1> 		mov ds,ax
   775 0000048A 48                  <1> 		dec ax
   776 0000048B 8EC0                <1> 		mov es,ax
   777                              <1> 
   778 0000048D A10000              <1> 		mov ax,[0]
   779 00000490 89C3                <1> 		mov bx,ax
   780 00000492 26331E1000          <1> 		xor bx,[es:10h]
   781 00000497 F7D0                <1> 		not ax
   782 00000499 A30000              <1> 		mov [0],ax
   783 0000049C 89C2                <1> 		mov dx,ax
   784 0000049E 2633161000          <1> 		xor dx,[es:10h]
   785 000004A3 F7D0                <1> 		not ax
   786 000004A5 A30000              <1> 		mov [0],ax
   787                              <1> 
   788 000004A8 09DA                <1> 		or dx,bx
   789 000004AA 52                  <1> 		push dx			; <D> Save A20 status
   790 000004AB 7505                <1> 		jnz .skip_a20e
   791                              <1> 
   792 000004AD B80124              <1> 		mov ax,2401h		; Enable A20
   793 000004B0 CD15                <1> 		int 15h
   794                              <1> .skip_a20e:
   795 000004B2 8A16[4F01]          <1> 		mov dl,[ConfigFlags]
   796 000004B6 83E208              <1> 		and dx,CONFIG_BIGRAW
   797 000004B9 83C208              <1> 		add dx,8
   798                              <1> 		; DX = 16 for BIGRAW, 8 for RAW
   799                              <1> 		;  8 is selector for a 64K flat segment,
   800                              <1> 		; 16 is selector for a 4GB flat segment.
   801                              <1> 
   802 000004BC 2E0F0116[A000]      <1> 		lgdt [cs:Shaker]
   803 000004C2 0F20C0              <1> 		mov eax,cr0
   804 000004C5 0C01                <1> 		or al,01h
   805 000004C7 0F22C0              <1> 		mov cr0,eax
   806                              <1> 
   807 000004CA BB1000              <1> 		mov bx,16		; Large flat segment
   808 000004CD 8EDB                <1> 		mov ds,bx
   809 000004CF 8EC3                <1> 		mov es,bx
   810                              <1> 
   811 000004D1 F36667A5            <1> 		a32 rep movsd
   812                              <1> 
   813                              <1> 		; DX has the appropriate value to put in
   814                              <1> 		; the registers on return
   815 000004D5 8EDA                <1> 		mov ds,dx
   816 000004D7 8EC2                <1> 		mov es,dx
   817                              <1> 
   818 000004D9 24FE                <1> 		and al,~01h
   819 000004DB 0F22C0              <1> 		mov cr0,eax
   820                              <1> 
   821 000004DE 5A                  <1> 		pop dx			; <D> A20 status
   822 000004DF 07                  <1> 		pop es			; <C>
   823 000004E0 1F                  <1> 		pop ds			; <B>
   824                              <1> 
   825 000004E1 21D2                <1> 		and dx,dx
   826 000004E3 7505                <1> 		jnz .skip_a20d
   827 000004E5 B80024              <1> 		mov ax,2400h		; Disable A20
   828 000004E8 CD15                <1> 		int 15h
   829                              <1> .skip_a20d:
   830 000004EA 669D                <1> 		popfd			; <A>
   831 000004EC EB60                <1> 		jmp .done
   832                              <1> 
   833                              <1> .fakeint15:
   834                              <1> 		; We're in real mode with CONFIG_SAFEINT, invoke the
   835                              <1> 		; original INT 15h vector.  We used to test for the
   836                              <1> 		; INT 15h vector being unchanged here, but that is
   837                              <1> 		; *us*; however, the test was wrong for years (always
   838                              <1> 		; negative) so instead of fixing the test do what we
   839                              <1> 		; tested and don't bother probing.
   840 000004EE BB[5B05]            <1> 		mov bx, fake_int15_stub
   841                              <1> 
   842                              <1> .protmode:
   843                              <1> 		TRACER 'p'
   844                              <1> .anymode:
   845                              <1> 
   846                              <1> .copy_loop:
   847 000004F1 6656                <1> 		push esi
   848 000004F3 6657                <1> 		push edi
   849 000004F5 6651                <1> 		push ecx
   850 000004F7 6681F900400000      <1> 		cmp ecx,4000h
   851 000004FE 7606                <1> 		jna .safe_size
   852 00000500 66B900400000        <1> 		mov ecx,4000h
   853                              <1> .safe_size:
   854 00000506 6651                <1> 		push ecx	; Transfer size this cycle
   855 00000508 6689F0              <1> 		mov eax, esi
   856 0000050B 8936[CA00]          <1> 		mov [Mover_src1], si
   857 0000050F 66C1E810            <1> 		shr eax, 16
   858 00000513 A2[CC00]            <1> 		mov [Mover_src1+2], al
   859 00000516 8826[CF00]          <1> 		mov [Mover_src2], ah
   860 0000051A 6689F8              <1> 		mov eax, edi
   861 0000051D 893E[D200]          <1> 		mov [Mover_dst1], di
   862 00000521 66C1E810            <1> 		shr eax, 16
   863 00000525 A2[D400]            <1> 		mov [Mover_dst1+2], al
   864 00000528 8826[D700]          <1> 		mov [Mover_dst2], ah
   865 0000052C BE[B800]            <1> 		mov si,Mover
   866 0000052F B487                <1> 		mov ah, 87h
   867 00000531 D1E1                <1> 		shl cx,1	; Convert to 16-bit words
   868 00000533 FFD3                <1> 		call bx		; INT 15h stub
   869 00000535 6658                <1> 		pop eax		; Transfer size this cycle
   870 00000537 6659                <1> 		pop ecx
   871 00000539 665F                <1> 		pop edi
   872 0000053B 665E                <1> 		pop esi
   873 0000053D 720F                <1> 		jc .error
   874 0000053F 66678D3486          <1> 		lea esi,[esi+4*eax]
   875 00000544 66678D3C87          <1> 		lea edi,[edi+4*eax]
   876 00000549 6629C1              <1> 		sub ecx, eax
   877 0000054C 75A3                <1> 		jnz .copy_loop
   878                              <1> 		; CF = 0
   879                              <1> .error:
   880                              <1> .done:
   881 0000054E 665D                <1> 		pop ebp
   882 00000550 665A                <1> 		pop edx
   883 00000552 665B                <1> 		pop ebx
   884 00000554 6658                <1> 		pop eax
   885 00000556 C3                  <1> 		ret
   886                              <1> 
   887                              <1> real_int15_stub:
   888 00000557 CD15                <1> 		int 15h
   889 00000559 FA                  <1> 		cli		; Some BIOSes enable interrupts on INT 15h
   890 0000055A C3                  <1> 		ret
   891                              <1> 
   892                              <1> fake_int15_stub:
   893 0000055B 9C                  <1> 		pushf
   894 0000055C FF1E[2C01]          <1> 		call far [OldInt15]
   895 00000560 FA                  <1> 		cli
   896 00000561 C3                  <1> 		ret
   897                              <1> 
   898                              <1> %ifdef DEBUG_TRACERS
   899                              <1> debug_tracer:	pushad
   900                              <1> 		pushfd
   901                              <1> 		mov bp,sp
   902                              <1> 		mov bx,[bp+9*4]
   903                              <1> 		mov al,[cs:bx]
   904                              <1> 		inc word [bp+9*4]
   905                              <1> 		mov ah,0Eh
   906                              <1> 		mov bx,7
   907                              <1> 		int 10h
   908                              <1> 		popfd
   909                              <1> 		popad
   910                              <1> 		ret
   911                              <1> 
   912                              <1> writehex2:	pushad
   913                              <1> 		pushfd
   914                              <1> 		mov cx,2
   915                              <1> 		ror eax,4
   916                              <1> 		jmp writehex_common
   917                              <1> writehex4:	pushad
   918                              <1> 		pushfd
   919                              <1> 		mov cx,4
   920                              <1> 		ror eax,12
   921                              <1> 		jmp writehex_common
   922                              <1> writehex8:	pushad
   923                              <1> 		pushfd
   924                              <1> 		mov cx,8
   925                              <1> 		ror eax,28
   926                              <1> writehex_common:
   927                              <1> .loop:		push cx
   928                              <1> 		push eax
   929                              <1> 		and al,0Fh
   930                              <1> 		cmp al,10
   931                              <1> 		jb .isdec
   932                              <1> 		add al,'a'-'0'-10
   933                              <1> .isdec:		add al,'0'
   934                              <1> 		mov ah,0Eh
   935                              <1> 		mov bx,7
   936                              <1> 		int 10h
   937                              <1> 		pop eax
   938                              <1> 		rol eax,4
   939                              <1> 		pop cx
   940                              <1> 		loop .loop
   941                              <1> 		popfd
   942                              <1> 		popad
   943                              <1> 		ret
   944                              <1> %endif
   945                              <1> 
   946                              <1> 		section .data align=16
   947                              <1> 		alignb 2
   948 00000000 [1101]              <1> Int13Funcs	dw Reset		; 00h - RESET
   949 00000002 [6101]              <1> 		dw GetStatus		; 01h - GET STATUS
   950 00000004 [6C01]              <1> 		dw Read			; 02h - READ
   951 00000006 [7701]              <1> 		dw Write		; 03h - WRITE
   952 00000008 [8901]              <1> 		dw Verify		; 04h - VERIFY
   953 0000000A [3C01]              <1> 		dw Invalid		; 05h - FORMAT TRACK
   954 0000000C [3C01]              <1> 		dw Invalid		; 06h - FORMAT TRACK AND SET BAD FLAGS
   955 0000000E [3C01]              <1> 		dw Invalid		; 07h - FORMAT DRIVE AT TRACK
   956 00000010 [8F01]              <1> 		dw GetParms		; 08h - GET PARAMETERS
   957 00000012 [8C01]              <1> 		dw InitWithParms	; 09h - INITIALIZE CONTROLLER WITH
   958                              <1> 					;	DRIVE PARAMETERS
   959 00000014 [3C01]              <1> 		dw Invalid		; 0Ah
   960 00000016 [3C01]              <1> 		dw Invalid		; 0Bh
   961 00000018 [8901]              <1> 		dw Seek			; 0Ch - SEEK TO CYLINDER
   962 0000001A [1101]              <1> 		dw Reset		; 0Dh - RESET HARD DISKS
   963 0000001C [3C01]              <1> 		dw Invalid		; 0Eh
   964 0000001E [3C01]              <1> 		dw Invalid		; 0Fh
   965 00000020 [8C01]              <1> 		dw CheckIfReady		; 10h - CHECK IF READY
   966 00000022 [8C01]              <1> 		dw Recalibrate		; 11h - RECALIBRATE
   967 00000024 [3C01]              <1> 		dw Invalid		; 12h
   968 00000026 [3C01]              <1> 		dw Invalid		; 13h
   969 00000028 [3C01]              <1> 		dw Invalid		; 14h
   970 0000002A [4101]              <1> 		dw GetDriveType		; 15h - GET DRIVE TYPE
   971 0000002C [8C01]              <1> 		dw DetectChange		; 16h - DETECT DRIVE CHANGE
   972                              <1> %if EDD
   973 0000002E [3C01]              <1> 		dw Invalid		; 17h
   974 00000030 [3C01]              <1> 		dw Invalid		; 18h
   975 00000032 [3C01]              <1> 		dw Invalid		; 19h
   976 00000034 [3C01]              <1> 		dw Invalid		; 1Ah
   977 00000036 [3C01]              <1> 		dw Invalid		; 1Bh
   978 00000038 [3C01]              <1> 		dw Invalid		; 1Ch
   979 0000003A [3C01]              <1> 		dw Invalid		; 1Dh
   980 0000003C [3C01]              <1> 		dw Invalid		; 1Eh
   981 0000003E [3C01]              <1> 		dw Invalid		; 1Fh
   982 00000040 [3C01]              <1> 		dw Invalid		; 20h
   983 00000042 [6C01]              <1> 		dw ReadMult		; 21h - READ MULTIPLE
   984 00000044 [7701]              <1> 		dw WriteMult		; 22h - WRITE MULTIPLE
   985 00000046 [8C01]              <1> 		dw SetMode		; 23h - SET CONTROLLER FEATURES
   986 00000048 [8C01]              <1> 		dw SetMode		; 24h - SET MULTIPLE MODE
   987 0000004A [3C01]              <1> 		dw Invalid		; 25h - IDENTIFY DRIVE
   988 0000004C [3C01]              <1> 		dw Invalid		; 26h
   989 0000004E [3C01]              <1> 		dw Invalid		; 27h
   990 00000050 [3C01]              <1> 		dw Invalid		; 28h
   991 00000052 [3C01]              <1> 		dw Invalid		; 29h
   992 00000054 [3C01]              <1> 		dw Invalid		; 2Ah
   993 00000056 [3C01]              <1> 		dw Invalid		; 2Bh
   994 00000058 [3C01]              <1> 		dw Invalid		; 2Ch
   995 0000005A [3C01]              <1> 		dw Invalid		; 2Dh
   996 0000005C [3C01]              <1> 		dw Invalid		; 2Eh
   997 0000005E [3C01]              <1> 		dw Invalid		; 2Fh
   998 00000060 [3C01]              <1> 		dw Invalid		; 30h
   999 00000062 [3C01]              <1> 		dw Invalid		; 31h
  1000 00000064 [3C01]              <1> 		dw Invalid		; 32h
  1001 00000066 [3C01]              <1> 		dw Invalid		; 33h
  1002 00000068 [3C01]              <1> 		dw Invalid		; 34h
  1003 0000006A [3C01]              <1> 		dw Invalid		; 35h
  1004 0000006C [3C01]              <1> 		dw Invalid		; 36h
  1005 0000006E [3C01]              <1> 		dw Invalid		; 37h
  1006 00000070 [3C01]              <1> 		dw Invalid		; 38h
  1007 00000072 [3C01]              <1> 		dw Invalid		; 39h
  1008 00000074 [3C01]              <1> 		dw Invalid		; 3Ah
  1009 00000076 [3C01]              <1> 		dw Invalid		; 3Bh
  1010 00000078 [3C01]              <1> 		dw Invalid		; 3Ch
  1011 0000007A [3C01]              <1> 		dw Invalid		; 3Dh
  1012 0000007C [3C01]              <1> 		dw Invalid		; 3Eh
  1013 0000007E [3C01]              <1> 		dw Invalid		; 3Fh
  1014 00000080 [3C01]              <1> 		dw Invalid		; 40h
  1015 00000082 [FE01]              <1> 		dw EDDPresence		; 41h - EDD PRESENCE DETECT
  1016 00000084 [1C02]              <1> 		dw EDDRead		; 42h - EDD READ
  1017 00000086 [2502]              <1> 		dw EDDWrite		; 43h - EDD WRITE
  1018 00000088 [3102]              <1> 		dw EDDVerify		; 44h - EDD VERIFY
  1019 0000008A [8C01]              <1> 		dw EDDLock		; 45h - EDD LOCK/UNLOCK MEDIA
  1020 0000008C [4B03]              <1> 		dw EDDEject		; 46h - EDD EJECT
  1021 0000008E [3102]              <1> 		dw EDDSeek		; 47h - EDD SEEK
  1022 00000090 [3702]              <1> 		dw EDDGetParms		; 48h - EDD GET PARAMETERS
  1023 00000092 [8C01]              <1> 		dw EDDDetectChange	; 49h - EDD MEDIA CHANGE STATUS
  1024                              <1> %if ELTORITO				; EDD El Torito Functions
  1025                              <1> 					; ELTORITO _must_ also have EDD
  1026 00000094 [7903]              <1> 		dw ElToritoEmulate	; 4Ah - Initiate Disk Emulation
  1027 00000096 [4F03]              <1> 		dw ElToritoTerminate	; 4Bh - Terminate Disk Emulation
  1028 00000098 [7903]              <1> 		dw ElToritoBoot		; 4Ch - Initiate Disk Emu. and Reboot
  1029 0000009A [7903]              <1> 		dw ElToritoCatalog	; 4Dh - Return Boot Catalog
  1030                              <1> %endif ; ELTORITO
  1031                              <1> %endif ; EDD
  1032                              <1> 
  1033                              <1> Int13FuncsEnd	equ $
  1034                              <1> Int13FuncsCnt	equ (Int13FuncsEnd-Int13Funcs) >> 1
  1035                              <1> 
  1036                              <1> 
  1037 0000009C 00<rept>            <1> 		alignb 8, db 0
  1038 000000A0 1700                <1> Shaker		dw ShakerEnd-$-1	; Descriptor table limit
  1039 000000A2 00000000            <1> 		dd 0			; Pointer to self
  1040 000000A6 0000                <1> 		dw 0
  1041                              <1> 
  1042 000000A8 FFFF0000            <1> Shaker_RMDS:	dd 0x0000ffff		; 64K data segment
  1043 000000AC 00930000            <1> 		dd 0x00009300
  1044                              <1> 
  1045 000000B0 FFFF0000            <1> Shaker_DS:	dd 0x0000ffff		; 4GB data segment
  1046 000000B4 00938F00            <1> 		dd 0x008f9300
  1047                              <1> 
  1048                              <1> ShakerEnd	equ $
  1049                              <1> 
  1050                              <1> 		alignb 8, db 0
  1051                              <1> 
  1052 000000B8 000000000000000000- <1> Mover		dd 0, 0, 0, 0		; Must be zero
  1052 000000C1 00000000000000      <1>
  1053 000000C8 FFFF                <1> 		dw 0ffffh		; 64 K segment size
  1054 000000CA 000000              <1> Mover_src1:	db 0, 0, 0		; Low 24 bits of source addy
  1055 000000CD 93                  <1> 		db 93h			; Access rights
  1056 000000CE 00                  <1> 		db 00h			; Extended access rights
  1057 000000CF 00                  <1> Mover_src2:	db 0			; High 8 bits of source addy
  1058 000000D0 FFFF                <1> 		dw 0ffffh		; 64 K segment size
  1059 000000D2 000000              <1> Mover_dst1:	db 0, 0, 0		; Low 24 bits of target addy
  1060 000000D5 93                  <1> 		db 93h			; Access rights
  1061 000000D6 00                  <1> 		db 00h			; Extended access rights
  1062 000000D7 00                  <1> Mover_dst2:	db 0			; High 8 bits of source addy
  1063 000000D8 000000000000000000- <1> Mover_dummy2:	dd 0, 0, 0, 0		; More space for the BIOS
  1063 000000E1 00000000000000      <1>
  1064                              <1> 
  1065 000000E8 00<rept>            <1> 		alignb 16, db 0
  1066                              <1> mBFT:
  1067                              <1> ; Fields common to all ACPI tables
  1068 000000F0 20202020            <1> 		dd '    '		; ACPI signature ("mBFT")
  1069                              <1> 					; This is filled-in by the installer
  1070                              <1> 					; to avoid an accidentally valid mBFT
  1071 000000F4 46000000            <1> 		dd mBFT_Len		; ACPI table length
  1072 000000F8 01                  <1> 		db 1			; ACPI revision
  1073 000000F9 00                  <1> 		db 0			; ACPI table checksum
  1074 000000FA 4D454D44534B        <1> 		db 'MEMDSK'		; ACPI OEM ID
  1075 00000100 5379736C696E7578    <1> 		db 'Syslinux'		; ACPI OEM table ID
  1076 00000108 00000000            <1> 		dd 0			; ACPI OEM revision
  1077 0000010C 00000000            <1> 		dd 0			; ACPI ASL compiler vendor ID
  1078 00000110 00000000            <1> 		dd 0			; ACPI ASL compiler revision
  1079                              <1> ; The next field is mBFT-specific and filled-in by the installer
  1080 00000114 00000000            <1> 		dd 0			; "Safe hook" physical address
  1081                              <1> 
  1082                              <1> ; Note that the above ends on a DWORD boundary.
  1083                              <1> ; The MDI has always started at such a boundary.
  1084                              <1> ; Portions of the MDI are patched by the installer
  1085                              <1> MemDisk_Info	equ $			; Pointed to by installation check
  1086 00000118 1E00                <1> MDI_Bytes	dw MDI_Len		; Total bytes in MDI structure
  1087 0000011A 0406                <1> MDI_Version	db VERSION_MINOR, VERSION_MAJOR	; MEMDISK version
  1088                              <1> 
  1089 0000011C 00000000            <1> DiskBuf		dd 0			; Linear address of high memory disk
  1090 00000120 00000000            <1> DiskSize	dd 0			; Size of disk in blocks
  1091 00000124 00000000            <1> CommandLine	dw 0, 0			; Far pointer to saved command line
  1092                              <1> 
  1093 00000128 00000000            <1> OldInt13	dd 0			; INT 13h in chain
  1094 0000012C 00000000            <1> OldInt15	dd 0			; INT 15h in chain
  1095                              <1> 
  1096 00000130 0000                <1> OldDosMem	dw 0			; Old position of DOS mem end
  1097 00000132 00                  <1> BootLoaderID	db 0			; Boot loader ID from header
  1098 00000133 00                  <1> 		db 0			; pad
  1099                              <1> 
  1100 00000134 0000                <1> DPT_ptr		dw 0			; If nonzero, pointer to DPT
  1101                              <1> 					; Original DPT pointer follows
  1102                              <1> 
  1103                              <1> MDI_Len		equ $-MemDisk_Info
  1104                              <1> mBFT_Len	equ $-mBFT		; mBFT includes the MDI
  1105                              <1> 
  1106                              <1> ; ---- MDI structure ends here ---
  1107 00000136 FF                  <1> DriveShiftLimit	db 0ffh			; Installer will probe for
  1108                              <1> 					; a range of contiguous drives.
  1109                              <1> 					; Any BIOS drives above this region
  1110                              <1> 					; shall not be impacted by our
  1111                              <1> 					; shifting behaviour
  1112 00000137 00                  <1> 		db 0			; pad to a DWORD
  1113 00000138 0000                <1> 		dw 0			; pad to a QWORD
  1114 0000013A 0000                <1> MemInt1588	dw 0			; 1MB-65MB memory amount (1K)
  1115                              <1> 
  1116 0000013C 0000                <1> Cylinders	dw 0			; Cylinder count
  1117 0000013E 0000                <1> Heads		dw 0			; Head count
  1118 00000140 00000000            <1> Sectors		dd 0			; Sector count (zero-extended)
  1119                              <1> 
  1120 00000144 00000000            <1> Mem1MB		dd 0			; 1MB-16MB memory amount (1K)
  1121 00000148 00000000            <1> Mem16MB		dd 0			; 16MB-4G memory amount (64K)
  1122                              <1> 
  1123 0000014C 00                  <1> DriveNo		db 0			; Our drive number
  1124 0000014D 00                  <1> DriveType	db 0			; Our drive type (floppies)
  1125 0000014E 00                  <1> DriveCnt	db 0			; Drive count (from the BIOS)
  1126                              <1> 
  1127 0000014F 00                  <1> ConfigFlags	db 0			; Bit 0 - readonly
  1128                              <1> 
  1129 00000150 0000                <1> MyStack		dw 0			; Offset of stack
  1130 00000152 0000                <1> StatusPtr	dw 0			; Where to save status (zeroseg ptr)
  1131                              <1> 
  1132 00000154 00<rept>            <1> DPT		times 16 db 0		; BIOS parameter table pointer (floppies)
  1133 00000164 00000000            <1> OldInt1E	dd 0			; Previous INT 1E pointer (DPT)
  1134                              <1> 
  1135                              <1> %if EDD
  1136                              <1> EDD_DPT:
  1137 00000168 1E00                <1> .length		dw 30
  1138 0000016A 2900                <1> .info		dw 0029h
  1139                              <1> 		; Bit 0 - DMA boundaries handled transparently
  1140                              <1> 		; Bit 3 - Device supports write verify
  1141                              <1> 		; Bit 5 - Media is lockable
  1142 0000016C 00000000            <1> .cylinders	dd 0			; Filled in by installer
  1143 00000170 00000000            <1> .heads		dd 0			; Filled in by installer
  1144 00000174 00000000            <1> .sectors	dd 0			; Filled in by installer
  1145 00000178 0000000000000000    <1> .totalsize	dd 0, 0			; Filled in by installer
  1146 00000180 0002                <1> .bytespersec	dw SECTORSIZE
  1147 00000182 FFFFFFFF            <1> .eddtable	dw -1, -1		; Invalid DPTE pointer
  1148 00000186 DDBE                <1> .dpikey		dw 0BEDDh		; Device Path Info magic
  1149 00000188 2C                  <1> .dpilen		db 2ch			; DPI len
  1150 00000189 00                  <1> .res1		db 0			; Reserved
  1151 0000018A 0000                <1> .res2		dw 0			; Reserved
  1152 0000018C 4D454D20            <1> .bustype	dd 'MEM '		; Host bus type (4 bytes, space padded)
  1153 00000190 4D454D4F52592020    <1> .inttype	dd 'MEMORY  '		; Interface type (8 bytes, spc. padded)
  1154 00000198 0000000000000000    <1> .intpath	dd 0, 0			; Interface path
  1155 000001A0 000000000000000000- <1> .devpath	dd 0, 0, 0, 0		; Device path
  1155 000001A9 00000000000000      <1>
  1156 000001B0 00                  <1> .res3		db 0			; Reserved
  1157 000001B1 00                  <1> .chksum		db 0			; DPI checksum
  1158                              <1> 
  1159                              <1> %if ELTORITO
  1160                              <1> ; El Torito CD Specification Packet - mostly filled in by installer
  1161                              <1> CD_PKT:
  1162 000001B2 13                  <1> .size		db 13h	; Packet size (19 bytes)
  1163 000001B3 00                  <1> .type		db 0	; Boot media type (flags)
  1164 000001B4 E0                  <1> .driveno	db 0E0h	; INT 13h drive number
  1165 000001B5 00                  <1> .controller	db 0	; Controller index
  1166 000001B6 00000000            <1> .start		dd 0	; Starting LBA of image
  1167 000001BA 0000                <1> .devno		dw 0	; Device number
  1168 000001BC 0000                <1> .user_buf	dw 0	; User buffer segment
  1169 000001BE 0000                <1> .load_seg	dw 0	; Load segment
  1170 000001C0 0000                <1> .sect_count	dw 0	; Emulated sectors to load
  1171 000001C2 00                  <1> .geom1		db 0	; Cylinders bits 0 thru 7
  1172 000001C3 00                  <1> .geom2		db 0	; Sects/track 0 thru 5, cyls 8, 9
  1173 000001C4 00                  <1> .geom3		db 0	; Heads
  1174                              <1> %endif ; ELTORITO
  1175                              <1> 
  1176                              <1> %endif ; EDD
  1177                              <1> 
  1178                              <1> ; End patch area
  1179                              <1> 
  1180 000001C5 00<rept>            <1> 		alignb 4, db 0
  1181 000001C8 00000000            <1> Stack		dd 0			; Saved SS:ESP on invocation
  1182 000001CC 0000                <1> 		dw 0
  1183 000001CE 0000                <1> SavedAX		dw 0			; AX saved on invocation
  1184 000001D0 0000                <1> Recursive	dw 0			; Recursion counter
  1185                              <1> 
  1186 000001D2 00<rept>            <1> 		alignb 4, db 0		; We *MUST* end on a dword boundary
  1187                              <1> 
  1188                              <1> E820Table	equ $			; The installer loads the E820 table here
  1189                              <1> TotalSize	equ $			; End pointer
