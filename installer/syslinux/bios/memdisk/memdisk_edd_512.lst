     1                                  	[map all memdisk_edd_512.map]
     2                                  %define EDD 1
     3                                  %define ELTORITO 0
     4                                  %define SECTORSIZE_LG2 9	; log2(sector size)
     5                                  %include "memdisk.inc"
     1                              <1> ; -*- fundamental -*- (asm-mode sucks)
     2                              <1> ; ****************************************************************************
     3                              <1> ;
     4                              <1> ;  memdisk.inc
     5                              <1> ;
     6                              <1> ;  A program to emulate an INT 13h disk BIOS from a "disk" in extended
     7                              <1> ;  memory.
     8                              <1> ;
     9                              <1> ;   Copyright 2001-2009 H. Peter Anvin - All Rights Reserved
    10                              <1> ;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
    11                              <1> ;   Portions copyright 2009 Shao Miller [El Torito code, mBFT, safe hook]
    12                              <1> ;
    13                              <1> ;  This program is free software; you can redistribute it and/or modify
    14                              <1> ;  it under the terms of the GNU General Public License as published by
    15                              <1> ;  the Free Software Foundation, Inc., 53 Temple Place Ste 330,
    16                              <1> ;  Boston MA 02111-1307, USA; either version 2 of the License, or
    17                              <1> ;  (at your option) any later version; incorporated herein by reference.
    18                              <1> ;
    19                              <1> ; ****************************************************************************
    20                              <1> 
    21                              <1> %include "../version.gen"
     1                              <2> %define VERSION 6.04
     2                              <2> %define VERSION_STR "6.04"
     3                              <2> %define VERSION_MAJOR 6
     4                              <2> %define VERSION_MINOR 4
     5                              <2> %define YEAR 2015
     6                              <2> %define YEAR_STR "2015"
    22                              <1> 
    23                              <1> ; %define DEBUG_TRACERS			; Uncomment to get debugging tracers
    24                              <1> 
    25                              <1> %ifdef DEBUG_TRACERS
    26                              <1> 
    27                              <1> %macro TRACER	1
    28                              <1> 	call debug_tracer
    29                              <1> 	db %1
    30                              <1> %endmacro
    31                              <1> %macro WRITEHEX2 0-1 al
    32                              <1> %ifnidni %1,al
    33                              <1> 	push ax
    34                              <1> 	mov al,%1
    35                              <1> 	call writehex2
    36                              <1> 	pop ax
    37                              <1> %else
    38                              <1> 	call writehex2
    39                              <1> %endif
    40                              <1> %endmacro
    41                              <1> %macro WRITEHEX4 0-1 ax
    42                              <1> %ifnidni %1,ax
    43                              <1> 	push ax
    44                              <1> 	mov ax,%1
    45                              <1> 	call writehex4
    46                              <1> 	pop ax
    47                              <1> %else
    48                              <1> 	call writehex4
    49                              <1> %endif
    50                              <1> %endmacro
    51                              <1> %macro WRITEHEX8 0-1 eax
    52                              <1> %ifnidni %1,eax
    53                              <1> 	push eax
    54                              <1> 	mov eax,%1
    55                              <1> 	call writehex8
    56                              <1> 	pop eax
    57                              <1> %else
    58                              <1> 	call writehex8
    59                              <1> %endif
    60                              <1> %endmacro
    61                              <1> 
    62                              <1> %else	; DEBUG_TRACERS
    63                              <1> 
    64                              <1> %macro	TRACER	1
    65                              <1> %endmacro
    66                              <1> %macro WRITEHEX2 0-1
    67                              <1> %endmacro
    68                              <1> %macro WRITEHEX4 0-1
    69                              <1> %endmacro
    70                              <1> %macro WRITEHEX8 0-1
    71                              <1> %endmacro
    72                              <1> 
    73                              <1> %endif	; DEBUG_TRACERS
    74                              <1> 
    75                              <1> ; Flags we test our configuration against
    76                              <1> %define CONFIG_READONLY	0x01
    77                              <1> %define CONFIG_RAW	0x02
    78                              <1> %define CONFIG_SAFEINT	0x04
    79                              <1> %define CONFIG_BIGRAW	0x08		; MUST be 8!
    80                              <1> 
    81                              <1> 		org 0h
    82                              <1> 
    83                              <1> %define	SECTORSIZE	(1 << SECTORSIZE_LG2)
    84                              <1> 
    85                              <1> 		; Parameter registers definition; this is the definition
    86                              <1> 		; of the stack frame.
    87                              <1> %define		P_DS		word [bp+34]
    88                              <1> %define		P_ES		word [bp+32]
    89                              <1> %define		P_EAX		dword [bp+28]
    90                              <1> %define		P_HAX		word [bp+30]
    91                              <1> %define		P_AX		word [bp+28]
    92                              <1> %define		P_AL		byte [bp+28]
    93                              <1> %define		P_AH		byte [bp+29]
    94                              <1> %define		P_ECX		dword [bp+24]
    95                              <1> %define		P_HCX		word [bp+26]
    96                              <1> %define		P_CX		word [bp+24]
    97                              <1> %define		P_CL		byte [bp+24]
    98                              <1> %define		P_CH		byte [bp+25]
    99                              <1> %define		P_EDX		dword [bp+20]
   100                              <1> %define		P_HDX		word [bp+22]
   101                              <1> %define		P_DX		word [bp+20]
   102                              <1> %define		P_DL		byte [bp+20]
   103                              <1> %define		P_DH		byte [bp+21]
   104                              <1> %define		P_EBX		dword [bp+16]
   105                              <1> %define		P_HBX		word [bp+18]
   106                              <1> %define		P_HBXL		byte [bp+18]
   107                              <1> %define		P_BX		word [bp+16]
   108                              <1> %define		P_BL		byte [bp+16]
   109                              <1> %define		P_BH		byte [bp+17]
   110                              <1> %define		P_EBP		dword [bp+8]
   111                              <1> %define		P_BP		word [bp+8]
   112                              <1> %define		P_ESI		dword [bp+4]
   113                              <1> %define		P_SI		word [bp+4]
   114                              <1> %define		P_EDI		dword [bp]
   115                              <1> %define		P_DI		word [bp]
   116                              <1> 
   117                              <1> 		section .text
   118                              <1> 		; These pointers are used by the installer and
   119                              <1> 		; must be first in the binary
   120 00000000 [0A00]              <1> Pointers:	dw Int13Start
   121 00000002 [BA03]              <1> 		dw Int15Start
   122 00000004 [0801]              <1> 		dw MemDisk_Info		; Portions are patched by installer
   123 00000006 [B001]              <1> 		dw TotalSize
   124 00000008 [B400]              <1> 		dw IretPtr
   125                              <1> 
   126                              <1> IretPtr		equ Int13Start.iret
   127                              <1> Int13Start:
   128 0000000A E91C00              <1> 		jmp strict near .SafeHookEnd ; 3-byte jump
   129 0000000D 24494E5431335346    <1> 		db '$INT13SF'		; Signature for "safe hook"
   130 00000015 4D454D4449534B20    <1> 		db 'MEMDISK '		; Vendor ID
   131 0000001D 00000000            <1> 		dd 0			; SEG:OFF of previous INT 13h hook
   132                              <1> 					; Must be filled in by installer
   133 00000021 00000000            <1> 		dd 0			; "Safe hook" flags
   134                              <1> ; ---- "Safe hook" structure ends here ---
   135                              <1> 
   136                              <1> ; This next field should be guaranteed at this position after the
   137                              <1> ; "safe hook" structure.  This allows for a MEMDISK OS driver to
   138                              <1> ; immediately find out the particular parameters using the mBFT
   139                              <1> ; and MDI structures.  This binary will have the offset to the mBFT
   140                              <1> ; in this field to begin with, so the installer knows where the mBFT
   141                              <1> ; is.  This is akin to the "Pointers" section above.  The installer
   142                              <1> ; will refill this field with the physical address of the mBFT for
   143                              <1> ; future consumers, such as OS drivers.
   144 00000025 [E0000000]          <1> 		dd mBFT			; Offset from hook to the mBFT
   145                              <1> 
   146                              <1> .SafeHookEnd:
   147 00000029 2E833E[AC01]00      <1> 		cmp word [cs:Recursive],0
   148 0000002F 0F858200            <1> 		jne recursive
   149                              <1> 
   150                              <1> 		; Swap stack
   151 00000033 2E668926[A401]      <1> 		mov [cs:Stack],esp
   152 00000039 2E8C16[A801]        <1> 		mov [cs:Stack+4],ss
   153 0000003E 2EA3[AA01]          <1> 		mov [cs:SavedAX],ax
   154 00000042 8CC8                <1> 		mov ax,cs
   155 00000044 8ED0                <1> 		mov ss,ax
   156 00000046 2E8B26[4001]        <1> 		mov sp,[cs:MyStack]
   157                              <1> 
   158                              <1> %if ELTORITO
   159                              <1> 		cmp word [cs:SavedAX],4a00h	; El Torito function?
   160                              <1> 		jae our_drive			; We grab it
   161                              <1> %endif
   162                              <1> 		; See if DL points to our class of device (FD, HD)
   163 0000004B 52                  <1> 		push dx
   164 0000004C 52                  <1> 		push dx
   165 0000004D 2E3216[3C01]        <1> 		xor dl,[cs:DriveNo]
   166 00000052 5A                  <1> 		pop dx
   167 00000053 7812                <1> 		js .nomatch		; If SF=0, we have a class match here
   168                              <1> 					; 0x00 the sign bit for FD
   169                              <1> 					; 0x80 the sign bit for HD
   170 00000055 7463                <1> 		jz our_drive		; If ZF=1, we have an exact match
   171 00000057 2E3A16[3C01]        <1> 		cmp dl,[cs:DriveNo]
   172 0000005C 7209                <1> 		jb .nomatch		; Drive < Our drive
   173 0000005E 2E3A16[2601]        <1> 		cmp dl,[cs:DriveShiftLimit]
   174 00000063 7302                <1> 		jae .nomatch		; Drive > The maximum drive
   175                              <1> 					; number that we will shift for.
   176                              <1> 					; This leaves any higher-up BIOS
   177                              <1> 					; drives alone, such as an optical
   178                              <1> 					; disc drive 0xA0 or 0xE0
   179 00000065 FECA                <1> 		dec dl			; Drive > Our drive, adjust drive #
   180                              <1> .nomatch:
   181                              <1> 		TRACER '!'
   182                              <1> 		WRITEHEX2 dl
   183                              <1> 		TRACER ','
   184 00000067 2EA1[AA01]          <1> 		mov ax,[cs:SavedAX]
   185                              <1> 		WRITEHEX4
   186 0000006B 2EFF06[AC01]        <1> 		inc word [cs:Recursive]
   187 00000070 9C                  <1> 		pushf
   188 00000071 2EFF1E[1801]        <1> 		call far [cs:OldInt13]
   189 00000076 9C                  <1> 		pushf
   190 00000077 2EFF0E[AC01]        <1> 		dec word [cs:Recursive]
   191 0000007C 55                  <1> 		push bp
   192 0000007D 89E5                <1> 		mov bp,sp
   193 0000007F 2E803E[AB01]08      <1> 		cmp byte [cs:SavedAX+1],08h	; Get drive params function?
   194 00000085 7411                <1> 		je .norestoredl			; DL = number of drives
   195 00000087 2E803E[AB01]15      <1> 		cmp byte [cs:SavedAX+1],15h	; Get disk type function?
   196 0000008D 7506                <1> 		jne .restoredl
   197 0000008F F6460480            <1> 		test byte [bp+4],80h		; Hard disk?
   198 00000093 7503                <1> 		jnz .norestoredl		; CX:DX = size of device
   199                              <1> .restoredl:
   200 00000095 8A5604              <1> 		mov dl,[bp+4]
   201                              <1> .norestoredl:
   202 00000098 50                  <1> 		push ax
   203 00000099 6653                <1> 		push ebx
   204 0000009B 1E                  <1> 		push ds
   205 0000009C 8B4602              <1> 		mov ax,[bp+2]		; Flags
   206 0000009F 2E66C51E[A401]      <1> 		lds ebx,[cs:Stack]
   207 000000A5 884704              <1> 		mov [bx+4],al		; Arithmetic flags
   208 000000A8 1F                  <1> 		pop ds
   209 000000A9 665B                <1> 		pop ebx
   210 000000AB 58                  <1> 		pop ax
   211 000000AC 5D                  <1> 		pop bp
   212 000000AD 2E660FB226[A401]    <1> 		lss esp,[cs:Stack]
   213 000000B4 CF                  <1> .iret:		iret
   214                              <1> 
   215                              <1> recursive:
   216                              <1> 		TRACER '@'
   217                              <1> jmp_oldint13:
   218 000000B5 2EFF2E[1801]        <1> 		jmp far [cs:OldInt13]
   219                              <1> 
   220                              <1> our_drive:
   221                              <1> 		; Set up standard entry frame
   222 000000BA 1E                  <1> 		push ds
   223 000000BB 06                  <1> 		push es
   224 000000BC 8ED8                <1> 		mov ds,ax
   225 000000BE 8EC0                <1> 		mov es,ax
   226 000000C0 A1[AA01]            <1> 		mov ax,[SavedAX]
   227 000000C3 6660                <1> 		pushad
   228 000000C5 89E5                <1> 		mov bp,sp		; Point BP to the entry stack frame
   229                              <1> 		TRACER 'F'
   230                              <1> 		WRITEHEX4
   231                              <1> 		; Note: AX == P_AX here
   232 000000C7 80FC49              <1> 		cmp ah,Int13FuncsCnt-1
   233 000000CA 775C                <1> 		ja Invalid_jump
   234                              <1> %if ELTORITO
   235                              <1> 		mov al,[CD_PKT.type]	; Check if we are in
   236                              <1> 		cmp al,0		; El Torito no emulation mode
   237                              <1> 		ja .emulation		; No.  We support the function
   238                              <1> 		cmp ah,3fh		; Yes.  We must not support functions
   239                              <1> 		jbe Invalid_jump	; 0 through 3Fh.  Check and decide
   240                              <1> .emulation:
   241                              <1> %endif
   242 000000CC 30C0                <1> 		xor al,al		; AL = 0 is standard entry condition
   243 000000CE 89C7                <1> 		mov di,ax
   244 000000D0 C1EF07              <1> 		shr di,7		; Convert AH to an offset in DI
   245 000000D3 FF95[0000]          <1> 		call [Int13Funcs+di]
   246                              <1> 
   247                              <1> Done:		; Standard routine for return
   248 000000D7 89461C              <1> 		mov P_AX,ax
   249                              <1> DoneWeird:
   250                              <1> 		TRACER 'D'
   251 000000DA 31DB                <1> 		xor bx,bx
   252 000000DC 8EC3                <1> 		mov es,bx
   253 000000DE 8B1E[4201]          <1> 		mov bx,[StatusPtr]
   254 000000E2 268827              <1> 		mov [es:bx],ah		; Save status
   255 000000E5 20E4                <1> 		and ah,ah
   256                              <1> 
   257 000000E7 66C51E[A401]        <1> 		lds ebx,[Stack]
   258                              <1> 		; This sets the low byte (the arithmetic flags) of the
   259                              <1> 		; FLAGS on stack to either 00h (no flags) or 01h (CF)
   260                              <1> 		; depending on if AH was zero or not.
   261 000000EC 0F954704            <1> 		setnz [bx+4]		; Set CF iff error
   262 000000F0 6661                <1> 		popad
   263 000000F2 07                  <1> 		pop es
   264 000000F3 1F                  <1> 		pop ds
   265 000000F4 2E660FB226[A401]    <1> 		lss esp,[cs:Stack]
   266 000000FB CF                  <1> 		iret
   267                              <1> 
   268                              <1> Reset:
   269                              <1> 		; Reset affects multiple drives, so we need to pass it on
   270                              <1> 		TRACER 'R'
   271 000000FC 31C0                <1> 		xor ax,ax		; Bottom of memory
   272 000000FE 8EC0                <1> 		mov es,ax
   273 00000100 84D2                <1> 		test dl,dl		; Always pass it on if we are
   274                              <1> 					; resetting HD
   275 00000102 780A                <1> 		js .hard_disk		; Bit 7 set
   276                              <1> 		; Some BIOSes get very unhappy if we pass a reset floppy
   277                              <1> 		; command to them and don't actually have any floppies.
   278                              <1> 		; This is a bug, but we have to deal with it nontheless.
   279                              <1> 		; Therefore, if we are the *ONLY* floppy drive, and the
   280                              <1> 		; user didn't request HD reset, then just drop the command.
   281                              <1> 		; BIOS equipment byte, top two bits + 1 == total # of floppies
   282 00000104 26F6061004C0        <1> 		test byte [es:0x410],0C0h
   283 0000010A 746B                <1> 		jz success
   284 0000010C EB08                <1> 		jmp .pass_on		; ... otherwise pass it to the BIOS
   285                              <1> .hard_disk:
   286                              <1> 		; ... same thing for hard disks, sigh ...
   287 0000010E 26803E750401        <1> 		cmp byte [es:0x475],1	; BIOS variable for number of hard
   288                              <1> 					; disks
   289 00000114 7661                <1> 		jbe success
   290                              <1> 
   291                              <1> .pass_on:
   292 00000116 58                  <1> 		pop ax			; Drop return address
   293 00000117 6661                <1> 		popad			; Restore all registers
   294 00000119 07                  <1> 		pop es
   295 0000011A 1F                  <1> 		pop ds
   296 0000011B 2E660FB226[A401]    <1> 		lss esp,[cs:Stack]	; Restore the stack
   297 00000122 80E280              <1> 		and dl,80h		; Clear all but the type bit
   298 00000125 EB8E                <1> 		jmp jmp_oldint13
   299                              <1> 
   300                              <1> 
   301                              <1> Invalid:
   302 00000127 5A                  <1> 		pop dx			; Drop return address
   303                              <1> Invalid_jump:
   304                              <1> 		TRACER 'I'
   305 00000128 B401                <1> 		mov ah,01h		; Unsupported function
   306 0000012A EBAB                <1> 		jmp short Done
   307                              <1> 
   308                              <1> GetDriveType:
   309 0000012C F606[3C01]80        <1> 		test byte [DriveNo],80h
   310 00000131 B302                <1> 		mov bl,02h		; Type 02h = floppy with changeline
   311 00000133 740F                <1> 		jz .floppy
   312                              <1> 		; Hard disks only!  DO NOT set CX:DX for floppies...
   313                              <1> 		; it apparently causes Win98SE DOS to go into an loop
   314                              <1> 		; resetting the drive over and over.  Sigh.
   315 00000135 43                  <1> 		inc bx			; Type = 03h
   316 00000136 8B16[1001]          <1> 		mov dx,[DiskSize]	; Return the disk size in sectors
   317 0000013A 895614              <1> 		mov P_DX,dx
   318 0000013D 8B0E[1201]          <1> 		mov cx,[DiskSize+2]
   319 00000141 894E18              <1> 		mov P_CX,cx
   320                              <1> .floppy:
   321 00000144 885E1D              <1> 		mov P_AH,bl		; 02h floppy, 03h hard disk
   322 00000147 58                  <1> 		pop ax			; Drop return address
   323 00000148 31C0                <1> 		xor ax,ax		; Success...
   324 0000014A EB8E                <1> 		jmp DoneWeird		; But don't stick it into P_AX
   325                              <1> 
   326                              <1> GetStatus:
   327 0000014C 31C0                <1> 		xor ax,ax
   328 0000014E 8EC0                <1> 		mov es,ax
   329 00000150 8B1E[4201]          <1> 		mov bx,[StatusPtr]
   330 00000154 8A27                <1> 		mov ah,[bx]		; Copy last status
   331 00000156 C3                  <1> 		ret
   332                              <1> 
   333                              <1> ReadMult:
   334                              <1> 		TRACER 'm'
   335                              <1> Read:
   336                              <1> 		TRACER 'R'
   337 00000157 E8EE00              <1> 		call setup_regs
   338                              <1> do_copy:
   339                              <1> 		TRACER '<'
   340 0000015A E8A402              <1> 		call bcopy
   341                              <1> 		TRACER '>'
   342 0000015D 0FB6461C            <1> 		movzx ax,P_AL		; AH = 0, AL = transfer count
   343 00000161 C3                  <1> 		ret
   344                              <1> 
   345                              <1> WriteMult:
   346                              <1> 		TRACER 'M'
   347                              <1> Write:
   348                              <1> 		TRACER 'W'
   349 00000162 F606[3F01]01        <1> 		test byte [ConfigFlags],CONFIG_READONLY
   350 00000167 7508                <1> 		jnz .readonly
   351 00000169 E8DC00              <1> 		call setup_regs
   352 0000016C 6687F7              <1> 		xchg esi,edi		; Opposite direction of a Read!
   353 0000016F EBE9                <1> 		jmp short do_copy
   354 00000171 B403                <1> .readonly:	mov ah,03h		; Write protected medium
   355 00000173 C3                  <1> 		ret
   356                              <1> 
   357                              <1> 		; Verify integrity; just bounds-check
   358                              <1> Seek:
   359                              <1> Verify:
   360 00000174 E8D100              <1> 		call setup_regs		; Returns error if appropriate
   361                              <1> 		; And fall through to success
   362                              <1> 
   363                              <1> CheckIfReady:				; These are always-successful noop functions
   364                              <1> Recalibrate:
   365                              <1> InitWithParms:
   366                              <1> DetectChange:
   367                              <1> EDDDetectChange:
   368                              <1> EDDLock:
   369                              <1> SetMode:
   370                              <1> success:
   371 00000177 31C0                <1> 		xor ax,ax		; Always successful
   372 00000179 C3                  <1> 		ret
   373                              <1> 
   374                              <1> GetParms:
   375                              <1> 		TRACER 'G'
   376 0000017A 8A16[3E01]          <1> 		mov dl,[DriveCnt]	; Cached data
   377 0000017E 885614              <1> 		mov P_DL,dl
   378 00000181 F606[3C01]80        <1> 		test byte [DriveNo],80h
   379 00000186 750F                <1> 		jnz .hd
   380 00000188 C74600[4401]        <1> 		mov P_DI,DPT
   381 0000018D 8C4E20              <1> 		mov P_ES,cs
   382 00000190 8A1E[3D01]          <1> 		mov bl,[DriveType]
   383 00000194 885E10              <1> 		mov P_BL,bl
   384                              <1> .hd:
   385 00000197 A1[2C01]            <1> 		mov ax,[Cylinders]
   386 0000019A 48                  <1> 		dec ax			; We report the highest #, not the count
   387 0000019B 86C4                <1> 		xchg al,ah
   388 0000019D C0E006              <1> 		shl al,6
   389 000001A0 0A06[3001]          <1> 		or al,[Sectors]
   390 000001A4 894618              <1> 		mov P_CX,ax
   391 000001A7 A1[2E01]            <1> 		mov ax,[Heads]
   392 000001AA 48                  <1> 		dec ax
   393 000001AB 884615              <1> 		mov P_DH,al
   394                              <1> 
   395                              <1> 		;
   396                              <1> 		; Is this MEMDISK installation check?
   397                              <1> 		;
   398 000001AE 817E1E4D45          <1> 		cmp P_HAX,'ME'
   399 000001B3 7531                <1> 		jne .notic
   400 000001B5 817E1A4D44          <1> 		cmp P_HCX,'MD'
   401 000001BA 752A                <1> 		jne .notic
   402 000001BC 817E164953          <1> 		cmp P_HDX,'IS'
   403 000001C1 7523                <1> 		jne .notic
   404 000001C3 817E124B3F          <1> 		cmp P_HBX,'K?'
   405 000001C8 751C                <1> 		jne .notic
   406                              <1> 
   407                              <1> 		; MEMDISK installation check...
   408 000001CA C7461E214D          <1> 		mov P_HAX,'!M'
   409 000001CF C7461A454D          <1> 		mov P_HCX,'EM'
   410 000001D4 C746164449          <1> 		mov P_HDX,'DI'
   411 000001D9 C74612534B          <1> 		mov P_HBX,'SK'
   412 000001DE 8C4E20              <1> 		mov P_ES,cs
   413 000001E1 C74600[0801]        <1> 		mov P_DI,MemDisk_Info
   414                              <1> 
   415                              <1> .notic:
   416 000001E6 31C0                <1> 		xor ax,ax
   417 000001E8 C3                  <1> 		ret
   418                              <1> ;
   419                              <1> ; EDD functions -- only if enabled
   420                              <1> ;
   421                              <1> %if EDD
   422                              <1> EDDPresence:
   423                              <1> 		TRACER 'E'
   424                              <1> 		TRACER 'c'
   425                              <1> 
   426 000001E9 817E10AA55          <1> 		cmp P_BX,55AAh
   427 000001EE 0F8535FF            <1> 		jne Invalid
   428 000001F2 C7461055AA          <1> 		mov P_BX,0AA55h		; EDD signature
   429 000001F7 C7461C0030          <1> 		mov P_AX,03000h		; EDD 3.0
   430 000001FC C746180700          <1> 		mov P_CX,0007h		; Bit 0 - Fixed disk access subset
   431                              <1> 					; Bit 1 - Locking and ejecting subset
   432                              <1> 					; Bit 2 - EDD subset
   433 00000201 58                  <1> 		pop ax			; Drop return address
   434 00000202 31C0                <1> 		xor ax,ax		; Success
   435 00000204 E9D3FE              <1> 		jmp DoneWeird		; Success, but AH != 0, sigh...
   436                              <1> 
   437                              <1> EDDRead:
   438                              <1> 		TRACER 'E'
   439                              <1> 		TRACER 'r'
   440                              <1> 
   441 00000207 E8A600              <1> 		call edd_setup_regs
   442 0000020A E8F401              <1> 		call bcopy
   443 0000020D 31C0                <1> 		xor ax,ax
   444 0000020F C3                  <1> 		ret
   445                              <1> 
   446                              <1> EDDWrite:
   447                              <1> 		TRACER 'E'
   448                              <1> 		TRACER 'w'
   449                              <1> 
   450 00000210 E89D00              <1> 		call edd_setup_regs
   451 00000213 6687F7              <1> 		xchg esi,edi		; Opposite direction of a Read!
   452 00000216 E8E801              <1> 		call bcopy
   453 00000219 31C0                <1> 		xor ax,ax
   454 0000021B C3                  <1> 		ret
   455                              <1> 
   456                              <1> EDDVerify:
   457                              <1> EDDSeek:
   458 0000021C E89100              <1> 		call edd_setup_regs	; Just bounds checking
   459 0000021F 31C0                <1> 		xor ax,ax
   460 00000221 C3                  <1> 		ret
   461                              <1> 
   462                              <1> EDDGetParms:
   463                              <1> 		TRACER 'E'
   464                              <1> 		TRACER 'p'
   465                              <1> 
   466 00000222 8E4622              <1> 		mov es,P_DS
   467 00000225 8B7E04              <1> 		mov di,P_SI
   468 00000228 BE[5801]            <1> 		mov si,EDD_DPT
   469                              <1> 
   470 0000022B AD                  <1> 		lodsw			; Length of our DPT
   471 0000022C 268B0D              <1> 		mov cx,[es:di]
   472 0000022F 83F91A              <1> 		cmp cx,26		; Minimum size
   473 00000232 7210                <1> 		jb .overrun
   474                              <1> 
   475 00000234 39C1                <1> 		cmp cx,ax
   476 00000236 7202                <1> 		jb .oksize
   477 00000238 89C1                <1> 		mov cx,ax
   478                              <1> 
   479                              <1> .oksize:
   480 0000023A 89C8                <1> 		mov ax,cx
   481 0000023C AB                  <1> 		stosw
   482 0000023D 49                  <1> 		dec cx
   483 0000023E 49                  <1> 		dec cx
   484 0000023F F3A4                <1> 		rep movsb
   485                              <1> 
   486 00000241 31C0                <1> 		xor ax,ax
   487 00000243 C3                  <1> 		ret
   488                              <1> 
   489                              <1> .overrun:
   490 00000244 B80001              <1> 		mov ax,0100h
   491 00000247 C3                  <1> 		ret
   492                              <1> %endif ; EDD
   493                              <1> 
   494                              <1> 		; Set up registers as for a "Read", and compares against disk
   495                              <1> 		; size.
   496                              <1> 		; WARNING: This fails immediately, even if we can transfer some
   497                              <1> 		; sectors.  This isn't really the correct behaviour.
   498                              <1> setup_regs:
   499                              <1> 
   500                              <1> 		; Convert a CHS address in P_CX/P_DH into an LBA in eax
   501                              <1> 		; CH = cyl[7:0]
   502                              <1> 		; CL[0:5] = sector (1-based)  CL[7:6] = cyl[9:8]
   503                              <1> 		; DH = head
   504 00000248 660FB74E18          <1> 		movzx ecx,P_CX
   505 0000024D 660FB6D9            <1> 		movzx ebx,cl		; Sector number
   506 00000251 80E33F              <1> 		and bl,3Fh
   507 00000254 664B                <1> 		dec ebx			; Sector number is 1-based
   508 00000256 3B1E[3001]          <1> 		cmp bx,[Sectors]
   509 0000025A 734F                <1> 		jae .overrun
   510 0000025C 660FB67E15          <1> 		movzx edi,P_DH		; Head number
   511 00000261 660FB706[2E01]      <1> 		movzx eax,word [Heads]
   512 00000267 39C7                <1> 		cmp di,ax
   513 00000269 7340                <1> 		jae .overrun
   514 0000026B C0E906              <1> 		shr cl,6
   515 0000026E 86CD                <1> 		xchg cl,ch		; Now (E)CX <- cylinder number
   516 00000270 66F7E1              <1> 		mul ecx			; eax <- Heads*cyl# (edx <- 0)
   517 00000273 6601F8              <1> 		add eax,edi
   518 00000276 66F726[3001]        <1> 		mul dword [Sectors]
   519 0000027B 6601D8              <1> 		add eax,ebx
   520                              <1> 		; Now eax = LBA, edx = 0
   521                              <1> 
   522                              <1> 		;
   523                              <1> 		; setup_regs continues...
   524                              <1> 		;
   525                              <1> 		; Note: edi[31:16] and ecx[31:16] = 0 already
   526 0000027E 8B7E10              <1> 		mov di,P_BX		; Get linear address of target buffer
   527 00000281 8B4E20              <1> 		mov cx,P_ES
   528 00000284 66C1E104            <1> 		shl ecx,4
   529 00000288 6601CF              <1> 		add edi,ecx		; EDI = address to fetch to
   530 0000028B 660FB64E1C          <1> 		movzx ecx,P_AL		; Sector count
   531 00000290 6689C6              <1> 		mov esi,eax
   532 00000293 6601C8              <1> 		add eax,ecx		; LBA of final sector + 1
   533 00000296 66C1E609            <1> 		shl esi,SECTORSIZE_LG2	; LBA -> byte offset
   534 0000029A 660336[0C01]        <1> 		add esi,[DiskBuf]	; Get address in high memory
   535 0000029F 663B06[1001]        <1> 		cmp eax,[DiskSize]	; Check the high mark against limit
   536 000002A4 7705                <1> 		ja .overrun
   537 000002A6 66C1E107            <1> 		shl ecx,SECTORSIZE_LG2-2 ; Convert count to dwords
   538 000002AA C3                  <1> 		ret
   539                              <1> 
   540 000002AB 58                  <1> .overrun:	pop ax			; Drop setup_regs return address
   541 000002AC B80002              <1> 		mov ax,0200h		; Missing address mark
   542 000002AF C3                  <1> 		ret			; Return to Done
   543                              <1> 
   544                              <1> 		; Set up registers as for an EDD Read, and compares against disk size.
   545                              <1> %if EDD
   546                              <1> edd_setup_regs:
   547 000002B0 06                  <1> 		push es
   548 000002B1 8B7604              <1> 		mov si,P_SI		; DS:SI -> DAPA
   549 000002B4 8E4622              <1> 		mov es,P_DS
   550                              <1> 
   551 000002B7 268B14              <1> 		mov dx,[es:si]
   552 000002BA 83FA10              <1> 		cmp dx,16
   553 000002BD 7266                <1> 		jb .baddapa
   554                              <1> 
   555 000002BF 2666837C04FF        <1> 		cmp dword [es:si+4],-1
   556 000002C5 7415                <1> 		je .linear_address
   557                              <1> 
   558 000002C7 26660FB75C04        <1> 		movzx ebx,word [es:si+4]	; Offset
   559 000002CD 26660FB77C06        <1> 		movzx edi,word [es:si+6]	; Segment
   560 000002D3 66C1E704            <1> 		shl edi,4
   561 000002D7 6601FB              <1> 		add ebx,edi
   562 000002DA EB15                <1> 		jmp .got_address
   563                              <1> 
   564                              <1> .linear_address:
   565 000002DC 83FA18              <1> 		cmp dx,24		; Must be large enough to hold
   566                              <1> 					; linear address
   567 000002DF 7244                <1> 		jb .baddapa
   568                              <1> 
   569 000002E1 2666837C1400        <1> 		cmp dword [es:si+20],0	; > 4 GB addresses not supported
   570 000002E7 B80009              <1> 		mov ax,0900h		; "Data boundary error" - bogus, but
   571                              <1> 					; no really better code available
   572 000002EA 7542                <1> 		jne .error
   573                              <1> 
   574 000002EC 26668B5C10          <1> 		mov ebx,[es:si+16]
   575                              <1> 
   576                              <1> .got_address:
   577 000002F1 2666837C0C00        <1> 		cmp dword [es:si+12],0		; LBA too large?
   578 000002F7 7532                <1> 		jne .overrun
   579                              <1> 
   580 000002F9 26660FB74C02        <1> 		movzx ecx, word [es:si+2]	; Sectors to transfer
   581 000002FF 26668B7408          <1> 		mov esi,[es:si+8]		; Starting sector
   582 00000304 6689F0              <1> 		mov eax,esi
   583 00000307 6601C8              <1> 		add eax,ecx
   584 0000030A 721F                <1> 		jc .overrun
   585 0000030C 663B06[1001]        <1> 		cmp eax,[DiskSize]
   586 00000311 7718                <1> 		ja .overrun
   587                              <1> 
   588 00000313 66C1E107            <1> 		shl ecx,SECTORSIZE_LG2-2	; Convert to dwords
   589 00000317 66C1E609            <1> 		shl esi,SECTORSIZE_LG2		; Convert to an offset
   590 0000031B 660336[0C01]        <1> 		add esi,[DiskBuf]
   591 00000320 6689DF              <1> 		mov edi,ebx
   592 00000323 07                  <1> 		pop es
   593 00000324 C3                  <1> 		ret
   594                              <1> 
   595                              <1> .baddapa:
   596 00000325 B80001              <1> 		mov ax,0100h		; Invalid command
   597 00000328 07                  <1> 		pop es
   598 00000329 58                  <1> 		pop ax			; Drop setup_regs return address
   599 0000032A C3                  <1> 		ret
   600                              <1> 
   601                              <1> .overrun:
   602 0000032B B80002              <1> 		mov ax,0200h		; "Address mark not found" =
   603                              <1> 					; LBA beyond end of disk
   604                              <1> .error:
   605 0000032E 2683640200          <1> 		and word [es:si+2],0	; No sectors transferred
   606 00000333 07                  <1> 		pop es
   607 00000334 58                  <1> 		pop ax
   608 00000335 C3                  <1> 		ret
   609                              <1> 
   610                              <1> EDDEject:
   611 00000336 B800B2              <1> 		mov ax,0B200h		; Volume Not Removable
   612 00000339 C3                  <1> 		ret
   613                              <1> %if ELTORITO
   614                              <1> ElToritoTerminate:
   615                              <1> 		TRACER 'T'
   616                              <1> 		mov ax,[cs:SavedAX]
   617                              <1> 		cmp al,1		; We only support query, not terminate
   618                              <1> 		jne ElToritoErr		; Fail
   619                              <1> 		cmp dl,7fh		; Terminate all?
   620                              <1> 		je .doit
   621                              <1> 		cmp dl,[cs:DriveNo]	; Terminate our drive?
   622                              <1> 		je .doit
   623                              <1> 		jmp ElToritoErr		; Fail
   624                              <1> .doit:		mov es,P_DS		; Caller's DS:SI pointed to packet
   625                              <1> 		mov di,P_SI		; We'll use ES:DI
   626                              <1> 		mov si,CD_PKT.size	; First byte is packet size
   627                              <1> 		xor cx,0		; Empty our count
   628                              <1> 		;mov cl,[ds:si]		; We'll copy that many bytes
   629                              <1> 		mov cl,13h
   630                              <1> 		rep movsb		; Copy until CX is zero
   631                              <1> 		mov ax,0		; Success
   632                              <1> 		ret
   633                              <1> ElToritoEmulate:
   634                              <1> ElToritoBoot:
   635                              <1> ElToritoCatalog:
   636                              <1> ElToritoErr:
   637                              <1> 		TRACER '!'
   638                              <1> 		mov ax,100h		; Invalid parameter
   639                              <1> 		ret
   640                              <1> %endif ; ELTORITO
   641                              <1> %endif ; EDD
   642                              <1> 
   643                              <1> ;
   644                              <1> ; INT 15h intercept routines
   645                              <1> ;
   646                              <1> int15_e820:
   647 0000033A 6681FA50414D53      <1> 		cmp edx,534D4150h	; "SMAP"
   648 00000341 0F858E00            <1> 		jne oldint15
   649 00000345 6683F914            <1> 		cmp ecx,20		; Need 20 bytes
   650 00000349 7267                <1> 		jb err86
   651 0000034B 1E                  <1> 		push ds
   652 0000034C 0E                  <1> 		push cs
   653 0000034D 1F                  <1> 		pop ds
   654 0000034E 6652                <1> 		push edx		; "SMAP"
   655 00000350 6621DB              <1> 		and ebx,ebx
   656 00000353 7506                <1> 		jne .renew
   657 00000355 66BB[B0010000]      <1> 		mov ebx,E820Table
   658                              <1> .renew:
   659 0000035B 83C30C              <1> 		add bx,12		; Advance to next
   660 0000035E 668B47FC            <1> 		mov eax,[bx-4]		; Type
   661 00000362 6621C0              <1> 		and eax,eax		; Null type?
   662 00000365 74F4                <1> 		jz .renew		; If so advance to next
   663 00000367 2666894510          <1> 		mov [es:di+16],eax
   664 0000036C 668B47F4            <1> 		mov eax,[bx-12]		; Start addr (low)
   665 00000370 668B57F8            <1> 		mov edx,[bx-8]		; Start addr (high)
   666 00000374 26668905            <1> 		mov [es:di],eax
   667 00000378 2666895504          <1> 		mov [es:di+4],edx
   668 0000037D 668B07              <1> 		mov eax,[bx]		; End addr (low)
   669 00000380 668B5704            <1> 		mov edx,[bx+4]		; End addr (high)
   670 00000384 662B47F4            <1> 		sub eax,[bx-12]		; Derive the length
   671 00000388 661B57F8            <1> 		sbb edx,[bx-8]
   672 0000038C 2666894508          <1> 		mov [es:di+8],eax	; Length (low)
   673 00000391 266689550C          <1> 		mov [es:di+12],edx	; Length (high)
   674 00000396 66837F08FF          <1> 		cmp dword [bx+8],-1	; Type of next = end?
   675 0000039B 7503                <1> 		jne .notdone
   676 0000039D 6631DB              <1> 		xor ebx,ebx		; Done with table
   677                              <1> .notdone:
   678 000003A0 6658                <1> 		pop eax			; "SMAP"
   679 000003A2 6689C2              <1> 		mov edx,eax		; Some systems expect eax = edx = SMAP
   680 000003A5 66B914000000        <1> 		mov ecx,20		; Bytes loaded
   681 000003AB 1F                  <1> 		pop ds
   682                              <1> int15_success:
   683 000003AC C6460602            <1> 		mov byte [bp+6], 02h	; Clear CF
   684 000003B0 5D                  <1> 		pop bp
   685 000003B1 CF                  <1> 		iret
   686                              <1> 
   687                              <1> err86:
   688 000003B2 C6460603            <1> 		mov byte [bp+6], 03h	; Set CF
   689 000003B6 B486                <1> 		mov ah,86h
   690 000003B8 5D                  <1> 		pop bp
   691 000003B9 CF                  <1> 		iret
   692                              <1> 
   693                              <1> Int15Start:
   694 000003BA 55                  <1> 		push bp
   695 000003BB 89E5                <1> 		mov bp,sp
   696 000003BD 3D20E8              <1> 		cmp ax,0E820h
   697 000003C0 0F8476FF            <1> 		je near int15_e820
   698 000003C4 3D01E8              <1> 		cmp ax,0E801h
   699 000003C7 7410                <1> 		je int15_e801
   700 000003C9 3D81E8              <1> 		cmp ax,0E881h
   701 000003CC 741A                <1> 		je int15_e881
   702 000003CE 80FC88              <1> 		cmp ah,88h
   703 000003D1 7428                <1> 		je int15_88
   704 000003D3 5D                  <1> oldint15:	pop bp
   705 000003D4 2EFF2E[1C01]        <1> 		jmp far [cs:OldInt15]
   706                              <1> 
   707                              <1> int15_e801:				; Get mem size for > 64 MB config
   708 000003D9 2EA1[3401]          <1> 		mov ax,[cs:Mem1MB]
   709 000003DD 89C1                <1> 		mov cx,ax
   710 000003DF 2E8B1E[3801]        <1> 		mov bx,[cs:Mem16MB]
   711 000003E4 89DA                <1> 		mov dx,bx
   712 000003E6 EBC4                <1> 		jmp short int15_success
   713                              <1> 
   714                              <1> int15_e881:				; Get mem size for > 64 MB config
   715                              <1> 					; 32-bit code
   716 000003E8 2E66A1[3401]        <1> 		mov eax,[cs:Mem1MB]
   717 000003ED 6689C1              <1> 		mov ecx,eax
   718 000003F0 2E668B1E[3801]      <1> 		mov ebx,[cs:Mem16MB]
   719 000003F6 6689DA              <1> 		mov edx,ebx
   720 000003F9 EBB1                <1> 		jmp short int15_success
   721                              <1> 
   722                              <1> int15_88:				; Get extended mem size
   723 000003FB 2EA1[2A01]          <1> 		mov ax,[cs:MemInt1588]
   724 000003FF EBAB                <1> 		jmp short int15_success
   725                              <1> 
   726                              <1> ;
   727                              <1> ; Routine to copy in/out of high memory
   728                              <1> ; esi = linear source address
   729                              <1> ; edi = linear target address
   730                              <1> ; ecx = 32-bit word count
   731                              <1> ;
   732                              <1> ; Assumes cs = ds = es
   733                              <1> ;
   734                              <1> bcopy:
   735 00000401 6650                <1> 		push eax
   736 00000403 6653                <1> 		push ebx
   737 00000405 6652                <1> 		push edx
   738 00000407 6655                <1> 		push ebp
   739                              <1> 
   740 00000409 BB[1405]            <1> 		mov bx, real_int15_stub
   741                              <1> 
   742 0000040C F606[3F01]06        <1> 		test byte [ConfigFlags], CONFIG_RAW|CONFIG_SAFEINT
   743 00000411 0F849900            <1> 		jz .anymode		; Always do the real INT 15h
   744                              <1> 
   745 00000415 0F01E0              <1> 		smsw ax			; Unprivileged!
   746 00000418 A801                <1> 		test al,01h
   747 0000041A 0F859000            <1> 		jnz .protmode		; Protmode -> do real INT 15h
   748                              <1> 
   749                              <1> .realmode:
   750                              <1> 		; Raw or Safeint mode, and we're in real mode...
   751                              <1> 
   752 0000041E F606[3F01]04        <1> 		test byte [ConfigFlags], CONFIG_SAFEINT
   753 00000423 0F858400            <1> 		jnz .fakeint15
   754                              <1> 
   755                              <1> .raw:
   756                              <1> 		TRACER 'r'
   757                              <1> 		; We're in real mode, do it outselves
   758                              <1> 
   759 00000427 669C                <1> 		pushfd			; <A>
   760 00000429 1E                  <1> 		push ds			; <B>
   761 0000042A 06                  <1> 		push es			; <C>
   762                              <1> 
   763 0000042B FA                  <1> 		cli
   764 0000042C FC                  <1> 		cld
   765                              <1> 
   766 0000042D 6631DB              <1> 		xor ebx,ebx
   767 00000430 8CCB                <1> 		mov bx,cs
   768 00000432 66C1E304            <1> 		shl ebx,4
   769 00000436 66678D93[98000000]  <1> 		lea edx,[Shaker+ebx]
   770 0000043E 668916[9A00]        <1> 		mov [Shaker+2],edx
   771                              <1> 
   772                              <1> 		; Test to see if A20 is enabled or not
   773 00000443 31C0                <1> 		xor ax,ax
   774 00000445 8ED8                <1> 		mov ds,ax
   775 00000447 48                  <1> 		dec ax
   776 00000448 8EC0                <1> 		mov es,ax
   777                              <1> 
   778 0000044A A10000              <1> 		mov ax,[0]
   779 0000044D 89C3                <1> 		mov bx,ax
   780 0000044F 26331E1000          <1> 		xor bx,[es:10h]
   781 00000454 F7D0                <1> 		not ax
   782 00000456 A30000              <1> 		mov [0],ax
   783 00000459 89C2                <1> 		mov dx,ax
   784 0000045B 2633161000          <1> 		xor dx,[es:10h]
   785 00000460 F7D0                <1> 		not ax
   786 00000462 A30000              <1> 		mov [0],ax
   787                              <1> 
   788 00000465 09DA                <1> 		or dx,bx
   789 00000467 52                  <1> 		push dx			; <D> Save A20 status
   790 00000468 7505                <1> 		jnz .skip_a20e
   791                              <1> 
   792 0000046A B80124              <1> 		mov ax,2401h		; Enable A20
   793 0000046D CD15                <1> 		int 15h
   794                              <1> .skip_a20e:
   795 0000046F 8A16[3F01]          <1> 		mov dl,[ConfigFlags]
   796 00000473 83E208              <1> 		and dx,CONFIG_BIGRAW
   797 00000476 83C208              <1> 		add dx,8
   798                              <1> 		; DX = 16 for BIGRAW, 8 for RAW
   799                              <1> 		;  8 is selector for a 64K flat segment,
   800                              <1> 		; 16 is selector for a 4GB flat segment.
   801                              <1> 
   802 00000479 2E0F0116[9800]      <1> 		lgdt [cs:Shaker]
   803 0000047F 0F20C0              <1> 		mov eax,cr0
   804 00000482 0C01                <1> 		or al,01h
   805 00000484 0F22C0              <1> 		mov cr0,eax
   806                              <1> 
   807 00000487 BB1000              <1> 		mov bx,16		; Large flat segment
   808 0000048A 8EDB                <1> 		mov ds,bx
   809 0000048C 8EC3                <1> 		mov es,bx
   810                              <1> 
   811 0000048E F36667A5            <1> 		a32 rep movsd
   812                              <1> 
   813                              <1> 		; DX has the appropriate value to put in
   814                              <1> 		; the registers on return
   815 00000492 8EDA                <1> 		mov ds,dx
   816 00000494 8EC2                <1> 		mov es,dx
   817                              <1> 
   818 00000496 24FE                <1> 		and al,~01h
   819 00000498 0F22C0              <1> 		mov cr0,eax
   820                              <1> 
   821 0000049B 5A                  <1> 		pop dx			; <D> A20 status
   822 0000049C 07                  <1> 		pop es			; <C>
   823 0000049D 1F                  <1> 		pop ds			; <B>
   824                              <1> 
   825 0000049E 21D2                <1> 		and dx,dx
   826 000004A0 7505                <1> 		jnz .skip_a20d
   827 000004A2 B80024              <1> 		mov ax,2400h		; Disable A20
   828 000004A5 CD15                <1> 		int 15h
   829                              <1> .skip_a20d:
   830 000004A7 669D                <1> 		popfd			; <A>
   831 000004A9 EB60                <1> 		jmp .done
   832                              <1> 
   833                              <1> .fakeint15:
   834                              <1> 		; We're in real mode with CONFIG_SAFEINT, invoke the
   835                              <1> 		; original INT 15h vector.  We used to test for the
   836                              <1> 		; INT 15h vector being unchanged here, but that is
   837                              <1> 		; *us*; however, the test was wrong for years (always
   838                              <1> 		; negative) so instead of fixing the test do what we
   839                              <1> 		; tested and don't bother probing.
   840 000004AB BB[1805]            <1> 		mov bx, fake_int15_stub
   841                              <1> 
   842                              <1> .protmode:
   843                              <1> 		TRACER 'p'
   844                              <1> .anymode:
   845                              <1> 
   846                              <1> .copy_loop:
   847 000004AE 6656                <1> 		push esi
   848 000004B0 6657                <1> 		push edi
   849 000004B2 6651                <1> 		push ecx
   850 000004B4 6681F900400000      <1> 		cmp ecx,4000h
   851 000004BB 7606                <1> 		jna .safe_size
   852 000004BD 66B900400000        <1> 		mov ecx,4000h
   853                              <1> .safe_size:
   854 000004C3 6651                <1> 		push ecx	; Transfer size this cycle
   855 000004C5 6689F0              <1> 		mov eax, esi
   856 000004C8 8936[C200]          <1> 		mov [Mover_src1], si
   857 000004CC 66C1E810            <1> 		shr eax, 16
   858 000004D0 A2[C400]            <1> 		mov [Mover_src1+2], al
   859 000004D3 8826[C700]          <1> 		mov [Mover_src2], ah
   860 000004D7 6689F8              <1> 		mov eax, edi
   861 000004DA 893E[CA00]          <1> 		mov [Mover_dst1], di
   862 000004DE 66C1E810            <1> 		shr eax, 16
   863 000004E2 A2[CC00]            <1> 		mov [Mover_dst1+2], al
   864 000004E5 8826[CF00]          <1> 		mov [Mover_dst2], ah
   865 000004E9 BE[B000]            <1> 		mov si,Mover
   866 000004EC B487                <1> 		mov ah, 87h
   867 000004EE D1E1                <1> 		shl cx,1	; Convert to 16-bit words
   868 000004F0 FFD3                <1> 		call bx		; INT 15h stub
   869 000004F2 6658                <1> 		pop eax		; Transfer size this cycle
   870 000004F4 6659                <1> 		pop ecx
   871 000004F6 665F                <1> 		pop edi
   872 000004F8 665E                <1> 		pop esi
   873 000004FA 720F                <1> 		jc .error
   874 000004FC 66678D3486          <1> 		lea esi,[esi+4*eax]
   875 00000501 66678D3C87          <1> 		lea edi,[edi+4*eax]
   876 00000506 6629C1              <1> 		sub ecx, eax
   877 00000509 75A3                <1> 		jnz .copy_loop
   878                              <1> 		; CF = 0
   879                              <1> .error:
   880                              <1> .done:
   881 0000050B 665D                <1> 		pop ebp
   882 0000050D 665A                <1> 		pop edx
   883 0000050F 665B                <1> 		pop ebx
   884 00000511 6658                <1> 		pop eax
   885 00000513 C3                  <1> 		ret
   886                              <1> 
   887                              <1> real_int15_stub:
   888 00000514 CD15                <1> 		int 15h
   889 00000516 FA                  <1> 		cli		; Some BIOSes enable interrupts on INT 15h
   890 00000517 C3                  <1> 		ret
   891                              <1> 
   892                              <1> fake_int15_stub:
   893 00000518 9C                  <1> 		pushf
   894 00000519 FF1E[1C01]          <1> 		call far [OldInt15]
   895 0000051D FA                  <1> 		cli
   896 0000051E C3                  <1> 		ret
   897                              <1> 
   898                              <1> %ifdef DEBUG_TRACERS
   899                              <1> debug_tracer:	pushad
   900                              <1> 		pushfd
   901                              <1> 		mov bp,sp
   902                              <1> 		mov bx,[bp+9*4]
   903                              <1> 		mov al,[cs:bx]
   904                              <1> 		inc word [bp+9*4]
   905                              <1> 		mov ah,0Eh
   906                              <1> 		mov bx,7
   907                              <1> 		int 10h
   908                              <1> 		popfd
   909                              <1> 		popad
   910                              <1> 		ret
   911                              <1> 
   912                              <1> writehex2:	pushad
   913                              <1> 		pushfd
   914                              <1> 		mov cx,2
   915                              <1> 		ror eax,4
   916                              <1> 		jmp writehex_common
   917                              <1> writehex4:	pushad
   918                              <1> 		pushfd
   919                              <1> 		mov cx,4
   920                              <1> 		ror eax,12
   921                              <1> 		jmp writehex_common
   922                              <1> writehex8:	pushad
   923                              <1> 		pushfd
   924                              <1> 		mov cx,8
   925                              <1> 		ror eax,28
   926                              <1> writehex_common:
   927                              <1> .loop:		push cx
   928                              <1> 		push eax
   929                              <1> 		and al,0Fh
   930                              <1> 		cmp al,10
   931                              <1> 		jb .isdec
   932                              <1> 		add al,'a'-'0'-10
   933                              <1> .isdec:		add al,'0'
   934                              <1> 		mov ah,0Eh
   935                              <1> 		mov bx,7
   936                              <1> 		int 10h
   937                              <1> 		pop eax
   938                              <1> 		rol eax,4
   939                              <1> 		pop cx
   940                              <1> 		loop .loop
   941                              <1> 		popfd
   942                              <1> 		popad
   943                              <1> 		ret
   944                              <1> %endif
   945                              <1> 
   946                              <1> 		section .data align=16
   947                              <1> 		alignb 2
   948 00000000 [FC00]              <1> Int13Funcs	dw Reset		; 00h - RESET
   949 00000002 [4C01]              <1> 		dw GetStatus		; 01h - GET STATUS
   950 00000004 [5701]              <1> 		dw Read			; 02h - READ
   951 00000006 [6201]              <1> 		dw Write		; 03h - WRITE
   952 00000008 [7401]              <1> 		dw Verify		; 04h - VERIFY
   953 0000000A [2701]              <1> 		dw Invalid		; 05h - FORMAT TRACK
   954 0000000C [2701]              <1> 		dw Invalid		; 06h - FORMAT TRACK AND SET BAD FLAGS
   955 0000000E [2701]              <1> 		dw Invalid		; 07h - FORMAT DRIVE AT TRACK
   956 00000010 [7A01]              <1> 		dw GetParms		; 08h - GET PARAMETERS
   957 00000012 [7701]              <1> 		dw InitWithParms	; 09h - INITIALIZE CONTROLLER WITH
   958                              <1> 					;	DRIVE PARAMETERS
   959 00000014 [2701]              <1> 		dw Invalid		; 0Ah
   960 00000016 [2701]              <1> 		dw Invalid		; 0Bh
   961 00000018 [7401]              <1> 		dw Seek			; 0Ch - SEEK TO CYLINDER
   962 0000001A [FC00]              <1> 		dw Reset		; 0Dh - RESET HARD DISKS
   963 0000001C [2701]              <1> 		dw Invalid		; 0Eh
   964 0000001E [2701]              <1> 		dw Invalid		; 0Fh
   965 00000020 [7701]              <1> 		dw CheckIfReady		; 10h - CHECK IF READY
   966 00000022 [7701]              <1> 		dw Recalibrate		; 11h - RECALIBRATE
   967 00000024 [2701]              <1> 		dw Invalid		; 12h
   968 00000026 [2701]              <1> 		dw Invalid		; 13h
   969 00000028 [2701]              <1> 		dw Invalid		; 14h
   970 0000002A [2C01]              <1> 		dw GetDriveType		; 15h - GET DRIVE TYPE
   971 0000002C [7701]              <1> 		dw DetectChange		; 16h - DETECT DRIVE CHANGE
   972                              <1> %if EDD
   973 0000002E [2701]              <1> 		dw Invalid		; 17h
   974 00000030 [2701]              <1> 		dw Invalid		; 18h
   975 00000032 [2701]              <1> 		dw Invalid		; 19h
   976 00000034 [2701]              <1> 		dw Invalid		; 1Ah
   977 00000036 [2701]              <1> 		dw Invalid		; 1Bh
   978 00000038 [2701]              <1> 		dw Invalid		; 1Ch
   979 0000003A [2701]              <1> 		dw Invalid		; 1Dh
   980 0000003C [2701]              <1> 		dw Invalid		; 1Eh
   981 0000003E [2701]              <1> 		dw Invalid		; 1Fh
   982 00000040 [2701]              <1> 		dw Invalid		; 20h
   983 00000042 [5701]              <1> 		dw ReadMult		; 21h - READ MULTIPLE
   984 00000044 [6201]              <1> 		dw WriteMult		; 22h - WRITE MULTIPLE
   985 00000046 [7701]              <1> 		dw SetMode		; 23h - SET CONTROLLER FEATURES
   986 00000048 [7701]              <1> 		dw SetMode		; 24h - SET MULTIPLE MODE
   987 0000004A [2701]              <1> 		dw Invalid		; 25h - IDENTIFY DRIVE
   988 0000004C [2701]              <1> 		dw Invalid		; 26h
   989 0000004E [2701]              <1> 		dw Invalid		; 27h
   990 00000050 [2701]              <1> 		dw Invalid		; 28h
   991 00000052 [2701]              <1> 		dw Invalid		; 29h
   992 00000054 [2701]              <1> 		dw Invalid		; 2Ah
   993 00000056 [2701]              <1> 		dw Invalid		; 2Bh
   994 00000058 [2701]              <1> 		dw Invalid		; 2Ch
   995 0000005A [2701]              <1> 		dw Invalid		; 2Dh
   996 0000005C [2701]              <1> 		dw Invalid		; 2Eh
   997 0000005E [2701]              <1> 		dw Invalid		; 2Fh
   998 00000060 [2701]              <1> 		dw Invalid		; 30h
   999 00000062 [2701]              <1> 		dw Invalid		; 31h
  1000 00000064 [2701]              <1> 		dw Invalid		; 32h
  1001 00000066 [2701]              <1> 		dw Invalid		; 33h
  1002 00000068 [2701]              <1> 		dw Invalid		; 34h
  1003 0000006A [2701]              <1> 		dw Invalid		; 35h
  1004 0000006C [2701]              <1> 		dw Invalid		; 36h
  1005 0000006E [2701]              <1> 		dw Invalid		; 37h
  1006 00000070 [2701]              <1> 		dw Invalid		; 38h
  1007 00000072 [2701]              <1> 		dw Invalid		; 39h
  1008 00000074 [2701]              <1> 		dw Invalid		; 3Ah
  1009 00000076 [2701]              <1> 		dw Invalid		; 3Bh
  1010 00000078 [2701]              <1> 		dw Invalid		; 3Ch
  1011 0000007A [2701]              <1> 		dw Invalid		; 3Dh
  1012 0000007C [2701]              <1> 		dw Invalid		; 3Eh
  1013 0000007E [2701]              <1> 		dw Invalid		; 3Fh
  1014 00000080 [2701]              <1> 		dw Invalid		; 40h
  1015 00000082 [E901]              <1> 		dw EDDPresence		; 41h - EDD PRESENCE DETECT
  1016 00000084 [0702]              <1> 		dw EDDRead		; 42h - EDD READ
  1017 00000086 [1002]              <1> 		dw EDDWrite		; 43h - EDD WRITE
  1018 00000088 [1C02]              <1> 		dw EDDVerify		; 44h - EDD VERIFY
  1019 0000008A [7701]              <1> 		dw EDDLock		; 45h - EDD LOCK/UNLOCK MEDIA
  1020 0000008C [3603]              <1> 		dw EDDEject		; 46h - EDD EJECT
  1021 0000008E [1C02]              <1> 		dw EDDSeek		; 47h - EDD SEEK
  1022 00000090 [2202]              <1> 		dw EDDGetParms		; 48h - EDD GET PARAMETERS
  1023 00000092 [7701]              <1> 		dw EDDDetectChange	; 49h - EDD MEDIA CHANGE STATUS
  1024                              <1> %if ELTORITO				; EDD El Torito Functions
  1025                              <1> 					; ELTORITO _must_ also have EDD
  1026                              <1> 		dw ElToritoEmulate	; 4Ah - Initiate Disk Emulation
  1027                              <1> 		dw ElToritoTerminate	; 4Bh - Terminate Disk Emulation
  1028                              <1> 		dw ElToritoBoot		; 4Ch - Initiate Disk Emu. and Reboot
  1029                              <1> 		dw ElToritoCatalog	; 4Dh - Return Boot Catalog
  1030                              <1> %endif ; ELTORITO
  1031                              <1> %endif ; EDD
  1032                              <1> 
  1033                              <1> Int13FuncsEnd	equ $
  1034                              <1> Int13FuncsCnt	equ (Int13FuncsEnd-Int13Funcs) >> 1
  1035                              <1> 
  1036                              <1> 
  1037 00000094 00<rept>            <1> 		alignb 8, db 0
  1038 00000098 1700                <1> Shaker		dw ShakerEnd-$-1	; Descriptor table limit
  1039 0000009A 00000000            <1> 		dd 0			; Pointer to self
  1040 0000009E 0000                <1> 		dw 0
  1041                              <1> 
  1042 000000A0 FFFF0000            <1> Shaker_RMDS:	dd 0x0000ffff		; 64K data segment
  1043 000000A4 00930000            <1> 		dd 0x00009300
  1044                              <1> 
  1045 000000A8 FFFF0000            <1> Shaker_DS:	dd 0x0000ffff		; 4GB data segment
  1046 000000AC 00938F00            <1> 		dd 0x008f9300
  1047                              <1> 
  1048                              <1> ShakerEnd	equ $
  1049                              <1> 
  1050                              <1> 		alignb 8, db 0
  1051                              <1> 
  1052 000000B0 000000000000000000- <1> Mover		dd 0, 0, 0, 0		; Must be zero
  1052 000000B9 00000000000000      <1>
  1053 000000C0 FFFF                <1> 		dw 0ffffh		; 64 K segment size
  1054 000000C2 000000              <1> Mover_src1:	db 0, 0, 0		; Low 24 bits of source addy
  1055 000000C5 93                  <1> 		db 93h			; Access rights
  1056 000000C6 00                  <1> 		db 00h			; Extended access rights
  1057 000000C7 00                  <1> Mover_src2:	db 0			; High 8 bits of source addy
  1058 000000C8 FFFF                <1> 		dw 0ffffh		; 64 K segment size
  1059 000000CA 000000              <1> Mover_dst1:	db 0, 0, 0		; Low 24 bits of target addy
  1060 000000CD 93                  <1> 		db 93h			; Access rights
  1061 000000CE 00                  <1> 		db 00h			; Extended access rights
  1062 000000CF 00                  <1> Mover_dst2:	db 0			; High 8 bits of source addy
  1063 000000D0 000000000000000000- <1> Mover_dummy2:	dd 0, 0, 0, 0		; More space for the BIOS
  1063 000000D9 00000000000000      <1>
  1064                              <1> 
  1065                              <1> 		alignb 16, db 0
  1066                              <1> mBFT:
  1067                              <1> ; Fields common to all ACPI tables
  1068 000000E0 20202020            <1> 		dd '    '		; ACPI signature ("mBFT")
  1069                              <1> 					; This is filled-in by the installer
  1070                              <1> 					; to avoid an accidentally valid mBFT
  1071 000000E4 46000000            <1> 		dd mBFT_Len		; ACPI table length
  1072 000000E8 01                  <1> 		db 1			; ACPI revision
  1073 000000E9 00                  <1> 		db 0			; ACPI table checksum
  1074 000000EA 4D454D44534B        <1> 		db 'MEMDSK'		; ACPI OEM ID
  1075 000000F0 5379736C696E7578    <1> 		db 'Syslinux'		; ACPI OEM table ID
  1076 000000F8 00000000            <1> 		dd 0			; ACPI OEM revision
  1077 000000FC 00000000            <1> 		dd 0			; ACPI ASL compiler vendor ID
  1078 00000100 00000000            <1> 		dd 0			; ACPI ASL compiler revision
  1079                              <1> ; The next field is mBFT-specific and filled-in by the installer
  1080 00000104 00000000            <1> 		dd 0			; "Safe hook" physical address
  1081                              <1> 
  1082                              <1> ; Note that the above ends on a DWORD boundary.
  1083                              <1> ; The MDI has always started at such a boundary.
  1084                              <1> ; Portions of the MDI are patched by the installer
  1085                              <1> MemDisk_Info	equ $			; Pointed to by installation check
  1086 00000108 1E00                <1> MDI_Bytes	dw MDI_Len		; Total bytes in MDI structure
  1087 0000010A 0406                <1> MDI_Version	db VERSION_MINOR, VERSION_MAJOR	; MEMDISK version
  1088                              <1> 
  1089 0000010C 00000000            <1> DiskBuf		dd 0			; Linear address of high memory disk
  1090 00000110 00000000            <1> DiskSize	dd 0			; Size of disk in blocks
  1091 00000114 00000000            <1> CommandLine	dw 0, 0			; Far pointer to saved command line
  1092                              <1> 
  1093 00000118 00000000            <1> OldInt13	dd 0			; INT 13h in chain
  1094 0000011C 00000000            <1> OldInt15	dd 0			; INT 15h in chain
  1095                              <1> 
  1096 00000120 0000                <1> OldDosMem	dw 0			; Old position of DOS mem end
  1097 00000122 00                  <1> BootLoaderID	db 0			; Boot loader ID from header
  1098 00000123 00                  <1> 		db 0			; pad
  1099                              <1> 
  1100 00000124 0000                <1> DPT_ptr		dw 0			; If nonzero, pointer to DPT
  1101                              <1> 					; Original DPT pointer follows
  1102                              <1> 
  1103                              <1> MDI_Len		equ $-MemDisk_Info
  1104                              <1> mBFT_Len	equ $-mBFT		; mBFT includes the MDI
  1105                              <1> 
  1106                              <1> ; ---- MDI structure ends here ---
  1107 00000126 FF                  <1> DriveShiftLimit	db 0ffh			; Installer will probe for
  1108                              <1> 					; a range of contiguous drives.
  1109                              <1> 					; Any BIOS drives above this region
  1110                              <1> 					; shall not be impacted by our
  1111                              <1> 					; shifting behaviour
  1112 00000127 00                  <1> 		db 0			; pad to a DWORD
  1113 00000128 0000                <1> 		dw 0			; pad to a QWORD
  1114 0000012A 0000                <1> MemInt1588	dw 0			; 1MB-65MB memory amount (1K)
  1115                              <1> 
  1116 0000012C 0000                <1> Cylinders	dw 0			; Cylinder count
  1117 0000012E 0000                <1> Heads		dw 0			; Head count
  1118 00000130 00000000            <1> Sectors		dd 0			; Sector count (zero-extended)
  1119                              <1> 
  1120 00000134 00000000            <1> Mem1MB		dd 0			; 1MB-16MB memory amount (1K)
  1121 00000138 00000000            <1> Mem16MB		dd 0			; 16MB-4G memory amount (64K)
  1122                              <1> 
  1123 0000013C 00                  <1> DriveNo		db 0			; Our drive number
  1124 0000013D 00                  <1> DriveType	db 0			; Our drive type (floppies)
  1125 0000013E 00                  <1> DriveCnt	db 0			; Drive count (from the BIOS)
  1126                              <1> 
  1127 0000013F 00                  <1> ConfigFlags	db 0			; Bit 0 - readonly
  1128                              <1> 
  1129 00000140 0000                <1> MyStack		dw 0			; Offset of stack
  1130 00000142 0000                <1> StatusPtr	dw 0			; Where to save status (zeroseg ptr)
  1131                              <1> 
  1132 00000144 00<rept>            <1> DPT		times 16 db 0		; BIOS parameter table pointer (floppies)
  1133 00000154 00000000            <1> OldInt1E	dd 0			; Previous INT 1E pointer (DPT)
  1134                              <1> 
  1135                              <1> %if EDD
  1136                              <1> EDD_DPT:
  1137 00000158 1E00                <1> .length		dw 30
  1138 0000015A 2900                <1> .info		dw 0029h
  1139                              <1> 		; Bit 0 - DMA boundaries handled transparently
  1140                              <1> 		; Bit 3 - Device supports write verify
  1141                              <1> 		; Bit 5 - Media is lockable
  1142 0000015C 00000000            <1> .cylinders	dd 0			; Filled in by installer
  1143 00000160 00000000            <1> .heads		dd 0			; Filled in by installer
  1144 00000164 00000000            <1> .sectors	dd 0			; Filled in by installer
  1145 00000168 0000000000000000    <1> .totalsize	dd 0, 0			; Filled in by installer
  1146 00000170 0002                <1> .bytespersec	dw SECTORSIZE
  1147 00000172 FFFFFFFF            <1> .eddtable	dw -1, -1		; Invalid DPTE pointer
  1148 00000176 DDBE                <1> .dpikey		dw 0BEDDh		; Device Path Info magic
  1149 00000178 2C                  <1> .dpilen		db 2ch			; DPI len
  1150 00000179 00                  <1> .res1		db 0			; Reserved
  1151 0000017A 0000                <1> .res2		dw 0			; Reserved
  1152 0000017C 4D454D20            <1> .bustype	dd 'MEM '		; Host bus type (4 bytes, space padded)
  1153 00000180 4D454D4F52592020    <1> .inttype	dd 'MEMORY  '		; Interface type (8 bytes, spc. padded)
  1154 00000188 0000000000000000    <1> .intpath	dd 0, 0			; Interface path
  1155 00000190 000000000000000000- <1> .devpath	dd 0, 0, 0, 0		; Device path
  1155 00000199 00000000000000      <1>
  1156 000001A0 00                  <1> .res3		db 0			; Reserved
  1157 000001A1 00                  <1> .chksum		db 0			; DPI checksum
  1158                              <1> 
  1159                              <1> %if ELTORITO
  1160                              <1> ; El Torito CD Specification Packet - mostly filled in by installer
  1161                              <1> CD_PKT:
  1162                              <1> .size		db 13h	; Packet size (19 bytes)
  1163                              <1> .type		db 0	; Boot media type (flags)
  1164                              <1> .driveno	db 0E0h	; INT 13h drive number
  1165                              <1> .controller	db 0	; Controller index
  1166                              <1> .start		dd 0	; Starting LBA of image
  1167                              <1> .devno		dw 0	; Device number
  1168                              <1> .user_buf	dw 0	; User buffer segment
  1169                              <1> .load_seg	dw 0	; Load segment
  1170                              <1> .sect_count	dw 0	; Emulated sectors to load
  1171                              <1> .geom1		db 0	; Cylinders bits 0 thru 7
  1172                              <1> .geom2		db 0	; Sects/track 0 thru 5, cyls 8, 9
  1173                              <1> .geom3		db 0	; Heads
  1174                              <1> %endif ; ELTORITO
  1175                              <1> 
  1176                              <1> %endif ; EDD
  1177                              <1> 
  1178                              <1> ; End patch area
  1179                              <1> 
  1180 000001A2 00<rept>            <1> 		alignb 4, db 0
  1181 000001A4 00000000            <1> Stack		dd 0			; Saved SS:ESP on invocation
  1182 000001A8 0000                <1> 		dw 0
  1183 000001AA 0000                <1> SavedAX		dw 0			; AX saved on invocation
  1184 000001AC 0000                <1> Recursive	dw 0			; Recursion counter
  1185                              <1> 
  1186 000001AE 00<rept>            <1> 		alignb 4, db 0		; We *MUST* end on a dword boundary
  1187                              <1> 
  1188                              <1> E820Table	equ $			; The installer loads the E820 table here
  1189                              <1> TotalSize	equ $			; End pointer
