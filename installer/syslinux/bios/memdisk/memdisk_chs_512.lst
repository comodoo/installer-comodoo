     1                                  	[map all memdisk_chs_512.map]
     2                                  %define EDD 0
     3                                  %define ELTORITO 0
     4                                  %define SECTORSIZE_LG2 9	; log2(sector size)
     5                                  %include "memdisk.inc"
     1                              <1> ; -*- fundamental -*- (asm-mode sucks)
     2                              <1> ; ****************************************************************************
     3                              <1> ;
     4                              <1> ;  memdisk.inc
     5                              <1> ;
     6                              <1> ;  A program to emulate an INT 13h disk BIOS from a "disk" in extended
     7                              <1> ;  memory.
     8                              <1> ;
     9                              <1> ;   Copyright 2001-2009 H. Peter Anvin - All Rights Reserved
    10                              <1> ;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
    11                              <1> ;   Portions copyright 2009 Shao Miller [El Torito code, mBFT, safe hook]
    12                              <1> ;
    13                              <1> ;  This program is free software; you can redistribute it and/or modify
    14                              <1> ;  it under the terms of the GNU General Public License as published by
    15                              <1> ;  the Free Software Foundation, Inc., 53 Temple Place Ste 330,
    16                              <1> ;  Boston MA 02111-1307, USA; either version 2 of the License, or
    17                              <1> ;  (at your option) any later version; incorporated herein by reference.
    18                              <1> ;
    19                              <1> ; ****************************************************************************
    20                              <1> 
    21                              <1> %include "../version.gen"
     1                              <2> %define VERSION 6.04
     2                              <2> %define VERSION_STR "6.04"
     3                              <2> %define VERSION_MAJOR 6
     4                              <2> %define VERSION_MINOR 4
     5                              <2> %define YEAR 2015
     6                              <2> %define YEAR_STR "2015"
    22                              <1> 
    23                              <1> ; %define DEBUG_TRACERS			; Uncomment to get debugging tracers
    24                              <1> 
    25                              <1> %ifdef DEBUG_TRACERS
    26                              <1> 
    27                              <1> %macro TRACER	1
    28                              <1> 	call debug_tracer
    29                              <1> 	db %1
    30                              <1> %endmacro
    31                              <1> %macro WRITEHEX2 0-1 al
    32                              <1> %ifnidni %1,al
    33                              <1> 	push ax
    34                              <1> 	mov al,%1
    35                              <1> 	call writehex2
    36                              <1> 	pop ax
    37                              <1> %else
    38                              <1> 	call writehex2
    39                              <1> %endif
    40                              <1> %endmacro
    41                              <1> %macro WRITEHEX4 0-1 ax
    42                              <1> %ifnidni %1,ax
    43                              <1> 	push ax
    44                              <1> 	mov ax,%1
    45                              <1> 	call writehex4
    46                              <1> 	pop ax
    47                              <1> %else
    48                              <1> 	call writehex4
    49                              <1> %endif
    50                              <1> %endmacro
    51                              <1> %macro WRITEHEX8 0-1 eax
    52                              <1> %ifnidni %1,eax
    53                              <1> 	push eax
    54                              <1> 	mov eax,%1
    55                              <1> 	call writehex8
    56                              <1> 	pop eax
    57                              <1> %else
    58                              <1> 	call writehex8
    59                              <1> %endif
    60                              <1> %endmacro
    61                              <1> 
    62                              <1> %else	; DEBUG_TRACERS
    63                              <1> 
    64                              <1> %macro	TRACER	1
    65                              <1> %endmacro
    66                              <1> %macro WRITEHEX2 0-1
    67                              <1> %endmacro
    68                              <1> %macro WRITEHEX4 0-1
    69                              <1> %endmacro
    70                              <1> %macro WRITEHEX8 0-1
    71                              <1> %endmacro
    72                              <1> 
    73                              <1> %endif	; DEBUG_TRACERS
    74                              <1> 
    75                              <1> ; Flags we test our configuration against
    76                              <1> %define CONFIG_READONLY	0x01
    77                              <1> %define CONFIG_RAW	0x02
    78                              <1> %define CONFIG_SAFEINT	0x04
    79                              <1> %define CONFIG_BIGRAW	0x08		; MUST be 8!
    80                              <1> 
    81                              <1> 		org 0h
    82                              <1> 
    83                              <1> %define	SECTORSIZE	(1 << SECTORSIZE_LG2)
    84                              <1> 
    85                              <1> 		; Parameter registers definition; this is the definition
    86                              <1> 		; of the stack frame.
    87                              <1> %define		P_DS		word [bp+34]
    88                              <1> %define		P_ES		word [bp+32]
    89                              <1> %define		P_EAX		dword [bp+28]
    90                              <1> %define		P_HAX		word [bp+30]
    91                              <1> %define		P_AX		word [bp+28]
    92                              <1> %define		P_AL		byte [bp+28]
    93                              <1> %define		P_AH		byte [bp+29]
    94                              <1> %define		P_ECX		dword [bp+24]
    95                              <1> %define		P_HCX		word [bp+26]
    96                              <1> %define		P_CX		word [bp+24]
    97                              <1> %define		P_CL		byte [bp+24]
    98                              <1> %define		P_CH		byte [bp+25]
    99                              <1> %define		P_EDX		dword [bp+20]
   100                              <1> %define		P_HDX		word [bp+22]
   101                              <1> %define		P_DX		word [bp+20]
   102                              <1> %define		P_DL		byte [bp+20]
   103                              <1> %define		P_DH		byte [bp+21]
   104                              <1> %define		P_EBX		dword [bp+16]
   105                              <1> %define		P_HBX		word [bp+18]
   106                              <1> %define		P_HBXL		byte [bp+18]
   107                              <1> %define		P_BX		word [bp+16]
   108                              <1> %define		P_BL		byte [bp+16]
   109                              <1> %define		P_BH		byte [bp+17]
   110                              <1> %define		P_EBP		dword [bp+8]
   111                              <1> %define		P_BP		word [bp+8]
   112                              <1> %define		P_ESI		dword [bp+4]
   113                              <1> %define		P_SI		word [bp+4]
   114                              <1> %define		P_EDI		dword [bp]
   115                              <1> %define		P_DI		word [bp]
   116                              <1> 
   117                              <1> 		section .text
   118                              <1> 		; These pointers are used by the installer and
   119                              <1> 		; must be first in the binary
   120 00000000 [0A00]              <1> Pointers:	dw Int13Start
   121 00000002 [D102]              <1> 		dw Int15Start
   122 00000004 [A800]              <1> 		dw MemDisk_Info		; Portions are patched by installer
   123 00000006 [0401]              <1> 		dw TotalSize
   124 00000008 [B400]              <1> 		dw IretPtr
   125                              <1> 
   126                              <1> IretPtr		equ Int13Start.iret
   127                              <1> Int13Start:
   128 0000000A E91C00              <1> 		jmp strict near .SafeHookEnd ; 3-byte jump
   129 0000000D 24494E5431335346    <1> 		db '$INT13SF'		; Signature for "safe hook"
   130 00000015 4D454D4449534B20    <1> 		db 'MEMDISK '		; Vendor ID
   131 0000001D 00000000            <1> 		dd 0			; SEG:OFF of previous INT 13h hook
   132                              <1> 					; Must be filled in by installer
   133 00000021 00000000            <1> 		dd 0			; "Safe hook" flags
   134                              <1> ; ---- "Safe hook" structure ends here ---
   135                              <1> 
   136                              <1> ; This next field should be guaranteed at this position after the
   137                              <1> ; "safe hook" structure.  This allows for a MEMDISK OS driver to
   138                              <1> ; immediately find out the particular parameters using the mBFT
   139                              <1> ; and MDI structures.  This binary will have the offset to the mBFT
   140                              <1> ; in this field to begin with, so the installer knows where the mBFT
   141                              <1> ; is.  This is akin to the "Pointers" section above.  The installer
   142                              <1> ; will refill this field with the physical address of the mBFT for
   143                              <1> ; future consumers, such as OS drivers.
   144 00000025 [80000000]          <1> 		dd mBFT			; Offset from hook to the mBFT
   145                              <1> 
   146                              <1> .SafeHookEnd:
   147 00000029 2E833E[0001]00      <1> 		cmp word [cs:Recursive],0
   148 0000002F 0F858200            <1> 		jne recursive
   149                              <1> 
   150                              <1> 		; Swap stack
   151 00000033 2E668926[F800]      <1> 		mov [cs:Stack],esp
   152 00000039 2E8C16[FC00]        <1> 		mov [cs:Stack+4],ss
   153 0000003E 2EA3[FE00]          <1> 		mov [cs:SavedAX],ax
   154 00000042 8CC8                <1> 		mov ax,cs
   155 00000044 8ED0                <1> 		mov ss,ax
   156 00000046 2E8B26[E000]        <1> 		mov sp,[cs:MyStack]
   157                              <1> 
   158                              <1> %if ELTORITO
   159                              <1> 		cmp word [cs:SavedAX],4a00h	; El Torito function?
   160                              <1> 		jae our_drive			; We grab it
   161                              <1> %endif
   162                              <1> 		; See if DL points to our class of device (FD, HD)
   163 0000004B 52                  <1> 		push dx
   164 0000004C 52                  <1> 		push dx
   165 0000004D 2E3216[DC00]        <1> 		xor dl,[cs:DriveNo]
   166 00000052 5A                  <1> 		pop dx
   167 00000053 7812                <1> 		js .nomatch		; If SF=0, we have a class match here
   168                              <1> 					; 0x00 the sign bit for FD
   169                              <1> 					; 0x80 the sign bit for HD
   170 00000055 7463                <1> 		jz our_drive		; If ZF=1, we have an exact match
   171 00000057 2E3A16[DC00]        <1> 		cmp dl,[cs:DriveNo]
   172 0000005C 7209                <1> 		jb .nomatch		; Drive < Our drive
   173 0000005E 2E3A16[C600]        <1> 		cmp dl,[cs:DriveShiftLimit]
   174 00000063 7302                <1> 		jae .nomatch		; Drive > The maximum drive
   175                              <1> 					; number that we will shift for.
   176                              <1> 					; This leaves any higher-up BIOS
   177                              <1> 					; drives alone, such as an optical
   178                              <1> 					; disc drive 0xA0 or 0xE0
   179 00000065 FECA                <1> 		dec dl			; Drive > Our drive, adjust drive #
   180                              <1> .nomatch:
   181                              <1> 		TRACER '!'
   182                              <1> 		WRITEHEX2 dl
   183                              <1> 		TRACER ','
   184 00000067 2EA1[FE00]          <1> 		mov ax,[cs:SavedAX]
   185                              <1> 		WRITEHEX4
   186 0000006B 2EFF06[0001]        <1> 		inc word [cs:Recursive]
   187 00000070 9C                  <1> 		pushf
   188 00000071 2EFF1E[B800]        <1> 		call far [cs:OldInt13]
   189 00000076 9C                  <1> 		pushf
   190 00000077 2EFF0E[0001]        <1> 		dec word [cs:Recursive]
   191 0000007C 55                  <1> 		push bp
   192 0000007D 89E5                <1> 		mov bp,sp
   193 0000007F 2E803E[FF00]08      <1> 		cmp byte [cs:SavedAX+1],08h	; Get drive params function?
   194 00000085 7411                <1> 		je .norestoredl			; DL = number of drives
   195 00000087 2E803E[FF00]15      <1> 		cmp byte [cs:SavedAX+1],15h	; Get disk type function?
   196 0000008D 7506                <1> 		jne .restoredl
   197 0000008F F6460480            <1> 		test byte [bp+4],80h		; Hard disk?
   198 00000093 7503                <1> 		jnz .norestoredl		; CX:DX = size of device
   199                              <1> .restoredl:
   200 00000095 8A5604              <1> 		mov dl,[bp+4]
   201                              <1> .norestoredl:
   202 00000098 50                  <1> 		push ax
   203 00000099 6653                <1> 		push ebx
   204 0000009B 1E                  <1> 		push ds
   205 0000009C 8B4602              <1> 		mov ax,[bp+2]		; Flags
   206 0000009F 2E66C51E[F800]      <1> 		lds ebx,[cs:Stack]
   207 000000A5 884704              <1> 		mov [bx+4],al		; Arithmetic flags
   208 000000A8 1F                  <1> 		pop ds
   209 000000A9 665B                <1> 		pop ebx
   210 000000AB 58                  <1> 		pop ax
   211 000000AC 5D                  <1> 		pop bp
   212 000000AD 2E660FB226[F800]    <1> 		lss esp,[cs:Stack]
   213 000000B4 CF                  <1> .iret:		iret
   214                              <1> 
   215                              <1> recursive:
   216                              <1> 		TRACER '@'
   217                              <1> jmp_oldint13:
   218 000000B5 2EFF2E[B800]        <1> 		jmp far [cs:OldInt13]
   219                              <1> 
   220                              <1> our_drive:
   221                              <1> 		; Set up standard entry frame
   222 000000BA 1E                  <1> 		push ds
   223 000000BB 06                  <1> 		push es
   224 000000BC 8ED8                <1> 		mov ds,ax
   225 000000BE 8EC0                <1> 		mov es,ax
   226 000000C0 A1[FE00]            <1> 		mov ax,[SavedAX]
   227 000000C3 6660                <1> 		pushad
   228 000000C5 89E5                <1> 		mov bp,sp		; Point BP to the entry stack frame
   229                              <1> 		TRACER 'F'
   230                              <1> 		WRITEHEX4
   231                              <1> 		; Note: AX == P_AX here
   232 000000C7 80FC16              <1> 		cmp ah,Int13FuncsCnt-1
   233 000000CA 775C                <1> 		ja Invalid_jump
   234                              <1> %if ELTORITO
   235                              <1> 		mov al,[CD_PKT.type]	; Check if we are in
   236                              <1> 		cmp al,0		; El Torito no emulation mode
   237                              <1> 		ja .emulation		; No.  We support the function
   238                              <1> 		cmp ah,3fh		; Yes.  We must not support functions
   239                              <1> 		jbe Invalid_jump	; 0 through 3Fh.  Check and decide
   240                              <1> .emulation:
   241                              <1> %endif
   242 000000CC 30C0                <1> 		xor al,al		; AL = 0 is standard entry condition
   243 000000CE 89C7                <1> 		mov di,ax
   244 000000D0 C1EF07              <1> 		shr di,7		; Convert AH to an offset in DI
   245 000000D3 FF95[0000]          <1> 		call [Int13Funcs+di]
   246                              <1> 
   247                              <1> Done:		; Standard routine for return
   248 000000D7 89461C              <1> 		mov P_AX,ax
   249                              <1> DoneWeird:
   250                              <1> 		TRACER 'D'
   251 000000DA 31DB                <1> 		xor bx,bx
   252 000000DC 8EC3                <1> 		mov es,bx
   253 000000DE 8B1E[E200]          <1> 		mov bx,[StatusPtr]
   254 000000E2 268827              <1> 		mov [es:bx],ah		; Save status
   255 000000E5 20E4                <1> 		and ah,ah
   256                              <1> 
   257 000000E7 66C51E[F800]        <1> 		lds ebx,[Stack]
   258                              <1> 		; This sets the low byte (the arithmetic flags) of the
   259                              <1> 		; FLAGS on stack to either 00h (no flags) or 01h (CF)
   260                              <1> 		; depending on if AH was zero or not.
   261 000000EC 0F954704            <1> 		setnz [bx+4]		; Set CF iff error
   262 000000F0 6661                <1> 		popad
   263 000000F2 07                  <1> 		pop es
   264 000000F3 1F                  <1> 		pop ds
   265 000000F4 2E660FB226[F800]    <1> 		lss esp,[cs:Stack]
   266 000000FB CF                  <1> 		iret
   267                              <1> 
   268                              <1> Reset:
   269                              <1> 		; Reset affects multiple drives, so we need to pass it on
   270                              <1> 		TRACER 'R'
   271 000000FC 31C0                <1> 		xor ax,ax		; Bottom of memory
   272 000000FE 8EC0                <1> 		mov es,ax
   273 00000100 84D2                <1> 		test dl,dl		; Always pass it on if we are
   274                              <1> 					; resetting HD
   275 00000102 780A                <1> 		js .hard_disk		; Bit 7 set
   276                              <1> 		; Some BIOSes get very unhappy if we pass a reset floppy
   277                              <1> 		; command to them and don't actually have any floppies.
   278                              <1> 		; This is a bug, but we have to deal with it nontheless.
   279                              <1> 		; Therefore, if we are the *ONLY* floppy drive, and the
   280                              <1> 		; user didn't request HD reset, then just drop the command.
   281                              <1> 		; BIOS equipment byte, top two bits + 1 == total # of floppies
   282 00000104 26F6061004C0        <1> 		test byte [es:0x410],0C0h
   283 0000010A 746B                <1> 		jz success
   284 0000010C EB08                <1> 		jmp .pass_on		; ... otherwise pass it to the BIOS
   285                              <1> .hard_disk:
   286                              <1> 		; ... same thing for hard disks, sigh ...
   287 0000010E 26803E750401        <1> 		cmp byte [es:0x475],1	; BIOS variable for number of hard
   288                              <1> 					; disks
   289 00000114 7661                <1> 		jbe success
   290                              <1> 
   291                              <1> .pass_on:
   292 00000116 58                  <1> 		pop ax			; Drop return address
   293 00000117 6661                <1> 		popad			; Restore all registers
   294 00000119 07                  <1> 		pop es
   295 0000011A 1F                  <1> 		pop ds
   296 0000011B 2E660FB226[F800]    <1> 		lss esp,[cs:Stack]	; Restore the stack
   297 00000122 80E280              <1> 		and dl,80h		; Clear all but the type bit
   298 00000125 EB8E                <1> 		jmp jmp_oldint13
   299                              <1> 
   300                              <1> 
   301                              <1> Invalid:
   302 00000127 5A                  <1> 		pop dx			; Drop return address
   303                              <1> Invalid_jump:
   304                              <1> 		TRACER 'I'
   305 00000128 B401                <1> 		mov ah,01h		; Unsupported function
   306 0000012A EBAB                <1> 		jmp short Done
   307                              <1> 
   308                              <1> GetDriveType:
   309 0000012C F606[DC00]80        <1> 		test byte [DriveNo],80h
   310 00000131 B302                <1> 		mov bl,02h		; Type 02h = floppy with changeline
   311 00000133 740F                <1> 		jz .floppy
   312                              <1> 		; Hard disks only!  DO NOT set CX:DX for floppies...
   313                              <1> 		; it apparently causes Win98SE DOS to go into an loop
   314                              <1> 		; resetting the drive over and over.  Sigh.
   315 00000135 43                  <1> 		inc bx			; Type = 03h
   316 00000136 8B16[B000]          <1> 		mov dx,[DiskSize]	; Return the disk size in sectors
   317 0000013A 895614              <1> 		mov P_DX,dx
   318 0000013D 8B0E[B200]          <1> 		mov cx,[DiskSize+2]
   319 00000141 894E18              <1> 		mov P_CX,cx
   320                              <1> .floppy:
   321 00000144 885E1D              <1> 		mov P_AH,bl		; 02h floppy, 03h hard disk
   322 00000147 58                  <1> 		pop ax			; Drop return address
   323 00000148 31C0                <1> 		xor ax,ax		; Success...
   324 0000014A EB8E                <1> 		jmp DoneWeird		; But don't stick it into P_AX
   325                              <1> 
   326                              <1> GetStatus:
   327 0000014C 31C0                <1> 		xor ax,ax
   328 0000014E 8EC0                <1> 		mov es,ax
   329 00000150 8B1E[E200]          <1> 		mov bx,[StatusPtr]
   330 00000154 8A27                <1> 		mov ah,[bx]		; Copy last status
   331 00000156 C3                  <1> 		ret
   332                              <1> 
   333                              <1> ReadMult:
   334                              <1> 		TRACER 'm'
   335                              <1> Read:
   336                              <1> 		TRACER 'R'
   337 00000157 E88F00              <1> 		call setup_regs
   338                              <1> do_copy:
   339                              <1> 		TRACER '<'
   340 0000015A E8BB01              <1> 		call bcopy
   341                              <1> 		TRACER '>'
   342 0000015D 0FB6461C            <1> 		movzx ax,P_AL		; AH = 0, AL = transfer count
   343 00000161 C3                  <1> 		ret
   344                              <1> 
   345                              <1> WriteMult:
   346                              <1> 		TRACER 'M'
   347                              <1> Write:
   348                              <1> 		TRACER 'W'
   349 00000162 F606[DF00]01        <1> 		test byte [ConfigFlags],CONFIG_READONLY
   350 00000167 7508                <1> 		jnz .readonly
   351 00000169 E87D00              <1> 		call setup_regs
   352 0000016C 6687F7              <1> 		xchg esi,edi		; Opposite direction of a Read!
   353 0000016F EBE9                <1> 		jmp short do_copy
   354 00000171 B403                <1> .readonly:	mov ah,03h		; Write protected medium
   355 00000173 C3                  <1> 		ret
   356                              <1> 
   357                              <1> 		; Verify integrity; just bounds-check
   358                              <1> Seek:
   359                              <1> Verify:
   360 00000174 E87200              <1> 		call setup_regs		; Returns error if appropriate
   361                              <1> 		; And fall through to success
   362                              <1> 
   363                              <1> CheckIfReady:				; These are always-successful noop functions
   364                              <1> Recalibrate:
   365                              <1> InitWithParms:
   366                              <1> DetectChange:
   367                              <1> EDDDetectChange:
   368                              <1> EDDLock:
   369                              <1> SetMode:
   370                              <1> success:
   371 00000177 31C0                <1> 		xor ax,ax		; Always successful
   372 00000179 C3                  <1> 		ret
   373                              <1> 
   374                              <1> GetParms:
   375                              <1> 		TRACER 'G'
   376 0000017A 8A16[DE00]          <1> 		mov dl,[DriveCnt]	; Cached data
   377 0000017E 885614              <1> 		mov P_DL,dl
   378 00000181 F606[DC00]80        <1> 		test byte [DriveNo],80h
   379 00000186 750F                <1> 		jnz .hd
   380 00000188 C74600[E400]        <1> 		mov P_DI,DPT
   381 0000018D 8C4E20              <1> 		mov P_ES,cs
   382 00000190 8A1E[DD00]          <1> 		mov bl,[DriveType]
   383 00000194 885E10              <1> 		mov P_BL,bl
   384                              <1> .hd:
   385 00000197 A1[CC00]            <1> 		mov ax,[Cylinders]
   386 0000019A 48                  <1> 		dec ax			; We report the highest #, not the count
   387 0000019B 86C4                <1> 		xchg al,ah
   388 0000019D C0E006              <1> 		shl al,6
   389 000001A0 0A06[D000]          <1> 		or al,[Sectors]
   390 000001A4 894618              <1> 		mov P_CX,ax
   391 000001A7 A1[CE00]            <1> 		mov ax,[Heads]
   392 000001AA 48                  <1> 		dec ax
   393 000001AB 884615              <1> 		mov P_DH,al
   394                              <1> 
   395                              <1> 		;
   396                              <1> 		; Is this MEMDISK installation check?
   397                              <1> 		;
   398 000001AE 817E1E4D45          <1> 		cmp P_HAX,'ME'
   399 000001B3 7531                <1> 		jne .notic
   400 000001B5 817E1A4D44          <1> 		cmp P_HCX,'MD'
   401 000001BA 752A                <1> 		jne .notic
   402 000001BC 817E164953          <1> 		cmp P_HDX,'IS'
   403 000001C1 7523                <1> 		jne .notic
   404 000001C3 817E124B3F          <1> 		cmp P_HBX,'K?'
   405 000001C8 751C                <1> 		jne .notic
   406                              <1> 
   407                              <1> 		; MEMDISK installation check...
   408 000001CA C7461E214D          <1> 		mov P_HAX,'!M'
   409 000001CF C7461A454D          <1> 		mov P_HCX,'EM'
   410 000001D4 C746164449          <1> 		mov P_HDX,'DI'
   411 000001D9 C74612534B          <1> 		mov P_HBX,'SK'
   412 000001DE 8C4E20              <1> 		mov P_ES,cs
   413 000001E1 C74600[A800]        <1> 		mov P_DI,MemDisk_Info
   414                              <1> 
   415                              <1> .notic:
   416 000001E6 31C0                <1> 		xor ax,ax
   417 000001E8 C3                  <1> 		ret
   418                              <1> ;
   419                              <1> ; EDD functions -- only if enabled
   420                              <1> ;
   421                              <1> %if EDD
   422                              <1> EDDPresence:
   423                              <1> 		TRACER 'E'
   424                              <1> 		TRACER 'c'
   425                              <1> 
   426                              <1> 		cmp P_BX,55AAh
   427                              <1> 		jne Invalid
   428                              <1> 		mov P_BX,0AA55h		; EDD signature
   429                              <1> 		mov P_AX,03000h		; EDD 3.0
   430                              <1> 		mov P_CX,0007h		; Bit 0 - Fixed disk access subset
   431                              <1> 					; Bit 1 - Locking and ejecting subset
   432                              <1> 					; Bit 2 - EDD subset
   433                              <1> 		pop ax			; Drop return address
   434                              <1> 		xor ax,ax		; Success
   435                              <1> 		jmp DoneWeird		; Success, but AH != 0, sigh...
   436                              <1> 
   437                              <1> EDDRead:
   438                              <1> 		TRACER 'E'
   439                              <1> 		TRACER 'r'
   440                              <1> 
   441                              <1> 		call edd_setup_regs
   442                              <1> 		call bcopy
   443                              <1> 		xor ax,ax
   444                              <1> 		ret
   445                              <1> 
   446                              <1> EDDWrite:
   447                              <1> 		TRACER 'E'
   448                              <1> 		TRACER 'w'
   449                              <1> 
   450                              <1> 		call edd_setup_regs
   451                              <1> 		xchg esi,edi		; Opposite direction of a Read!
   452                              <1> 		call bcopy
   453                              <1> 		xor ax,ax
   454                              <1> 		ret
   455                              <1> 
   456                              <1> EDDVerify:
   457                              <1> EDDSeek:
   458                              <1> 		call edd_setup_regs	; Just bounds checking
   459                              <1> 		xor ax,ax
   460                              <1> 		ret
   461                              <1> 
   462                              <1> EDDGetParms:
   463                              <1> 		TRACER 'E'
   464                              <1> 		TRACER 'p'
   465                              <1> 
   466                              <1> 		mov es,P_DS
   467                              <1> 		mov di,P_SI
   468                              <1> 		mov si,EDD_DPT
   469                              <1> 
   470                              <1> 		lodsw			; Length of our DPT
   471                              <1> 		mov cx,[es:di]
   472                              <1> 		cmp cx,26		; Minimum size
   473                              <1> 		jb .overrun
   474                              <1> 
   475                              <1> 		cmp cx,ax
   476                              <1> 		jb .oksize
   477                              <1> 		mov cx,ax
   478                              <1> 
   479                              <1> .oksize:
   480                              <1> 		mov ax,cx
   481                              <1> 		stosw
   482                              <1> 		dec cx
   483                              <1> 		dec cx
   484                              <1> 		rep movsb
   485                              <1> 
   486                              <1> 		xor ax,ax
   487                              <1> 		ret
   488                              <1> 
   489                              <1> .overrun:
   490                              <1> 		mov ax,0100h
   491                              <1> 		ret
   492                              <1> %endif ; EDD
   493                              <1> 
   494                              <1> 		; Set up registers as for a "Read", and compares against disk
   495                              <1> 		; size.
   496                              <1> 		; WARNING: This fails immediately, even if we can transfer some
   497                              <1> 		; sectors.  This isn't really the correct behaviour.
   498                              <1> setup_regs:
   499                              <1> 
   500                              <1> 		; Convert a CHS address in P_CX/P_DH into an LBA in eax
   501                              <1> 		; CH = cyl[7:0]
   502                              <1> 		; CL[0:5] = sector (1-based)  CL[7:6] = cyl[9:8]
   503                              <1> 		; DH = head
   504 000001E9 660FB74E18          <1> 		movzx ecx,P_CX
   505 000001EE 660FB6D9            <1> 		movzx ebx,cl		; Sector number
   506 000001F2 80E33F              <1> 		and bl,3Fh
   507 000001F5 664B                <1> 		dec ebx			; Sector number is 1-based
   508 000001F7 3B1E[D000]          <1> 		cmp bx,[Sectors]
   509 000001FB 734F                <1> 		jae .overrun
   510 000001FD 660FB67E15          <1> 		movzx edi,P_DH		; Head number
   511 00000202 660FB706[CE00]      <1> 		movzx eax,word [Heads]
   512 00000208 39C7                <1> 		cmp di,ax
   513 0000020A 7340                <1> 		jae .overrun
   514 0000020C C0E906              <1> 		shr cl,6
   515 0000020F 86CD                <1> 		xchg cl,ch		; Now (E)CX <- cylinder number
   516 00000211 66F7E1              <1> 		mul ecx			; eax <- Heads*cyl# (edx <- 0)
   517 00000214 6601F8              <1> 		add eax,edi
   518 00000217 66F726[D000]        <1> 		mul dword [Sectors]
   519 0000021C 6601D8              <1> 		add eax,ebx
   520                              <1> 		; Now eax = LBA, edx = 0
   521                              <1> 
   522                              <1> 		;
   523                              <1> 		; setup_regs continues...
   524                              <1> 		;
   525                              <1> 		; Note: edi[31:16] and ecx[31:16] = 0 already
   526 0000021F 8B7E10              <1> 		mov di,P_BX		; Get linear address of target buffer
   527 00000222 8B4E20              <1> 		mov cx,P_ES
   528 00000225 66C1E104            <1> 		shl ecx,4
   529 00000229 6601CF              <1> 		add edi,ecx		; EDI = address to fetch to
   530 0000022C 660FB64E1C          <1> 		movzx ecx,P_AL		; Sector count
   531 00000231 6689C6              <1> 		mov esi,eax
   532 00000234 6601C8              <1> 		add eax,ecx		; LBA of final sector + 1
   533 00000237 66C1E609            <1> 		shl esi,SECTORSIZE_LG2	; LBA -> byte offset
   534 0000023B 660336[AC00]        <1> 		add esi,[DiskBuf]	; Get address in high memory
   535 00000240 663B06[B000]        <1> 		cmp eax,[DiskSize]	; Check the high mark against limit
   536 00000245 7705                <1> 		ja .overrun
   537 00000247 66C1E107            <1> 		shl ecx,SECTORSIZE_LG2-2 ; Convert count to dwords
   538 0000024B C3                  <1> 		ret
   539                              <1> 
   540 0000024C 58                  <1> .overrun:	pop ax			; Drop setup_regs return address
   541 0000024D B80002              <1> 		mov ax,0200h		; Missing address mark
   542 00000250 C3                  <1> 		ret			; Return to Done
   543                              <1> 
   544                              <1> 		; Set up registers as for an EDD Read, and compares against disk size.
   545                              <1> %if EDD
   546                              <1> edd_setup_regs:
   547                              <1> 		push es
   548                              <1> 		mov si,P_SI		; DS:SI -> DAPA
   549                              <1> 		mov es,P_DS
   550                              <1> 
   551                              <1> 		mov dx,[es:si]
   552                              <1> 		cmp dx,16
   553                              <1> 		jb .baddapa
   554                              <1> 
   555                              <1> 		cmp dword [es:si+4],-1
   556                              <1> 		je .linear_address
   557                              <1> 
   558                              <1> 		movzx ebx,word [es:si+4]	; Offset
   559                              <1> 		movzx edi,word [es:si+6]	; Segment
   560                              <1> 		shl edi,4
   561                              <1> 		add ebx,edi
   562                              <1> 		jmp .got_address
   563                              <1> 
   564                              <1> .linear_address:
   565                              <1> 		cmp dx,24		; Must be large enough to hold
   566                              <1> 					; linear address
   567                              <1> 		jb .baddapa
   568                              <1> 
   569                              <1> 		cmp dword [es:si+20],0	; > 4 GB addresses not supported
   570                              <1> 		mov ax,0900h		; "Data boundary error" - bogus, but
   571                              <1> 					; no really better code available
   572                              <1> 		jne .error
   573                              <1> 
   574                              <1> 		mov ebx,[es:si+16]
   575                              <1> 
   576                              <1> .got_address:
   577                              <1> 		cmp dword [es:si+12],0		; LBA too large?
   578                              <1> 		jne .overrun
   579                              <1> 
   580                              <1> 		movzx ecx, word [es:si+2]	; Sectors to transfer
   581                              <1> 		mov esi,[es:si+8]		; Starting sector
   582                              <1> 		mov eax,esi
   583                              <1> 		add eax,ecx
   584                              <1> 		jc .overrun
   585                              <1> 		cmp eax,[DiskSize]
   586                              <1> 		ja .overrun
   587                              <1> 
   588                              <1> 		shl ecx,SECTORSIZE_LG2-2	; Convert to dwords
   589                              <1> 		shl esi,SECTORSIZE_LG2		; Convert to an offset
   590                              <1> 		add esi,[DiskBuf]
   591                              <1> 		mov edi,ebx
   592                              <1> 		pop es
   593                              <1> 		ret
   594                              <1> 
   595                              <1> .baddapa:
   596                              <1> 		mov ax,0100h		; Invalid command
   597                              <1> 		pop es
   598                              <1> 		pop ax			; Drop setup_regs return address
   599                              <1> 		ret
   600                              <1> 
   601                              <1> .overrun:
   602                              <1> 		mov ax,0200h		; "Address mark not found" =
   603                              <1> 					; LBA beyond end of disk
   604                              <1> .error:
   605                              <1> 		and word [es:si+2],0	; No sectors transferred
   606                              <1> 		pop es
   607                              <1> 		pop ax
   608                              <1> 		ret
   609                              <1> 
   610                              <1> EDDEject:
   611                              <1> 		mov ax,0B200h		; Volume Not Removable
   612                              <1> 		ret
   613                              <1> %if ELTORITO
   614                              <1> ElToritoTerminate:
   615                              <1> 		TRACER 'T'
   616                              <1> 		mov ax,[cs:SavedAX]
   617                              <1> 		cmp al,1		; We only support query, not terminate
   618                              <1> 		jne ElToritoErr		; Fail
   619                              <1> 		cmp dl,7fh		; Terminate all?
   620                              <1> 		je .doit
   621                              <1> 		cmp dl,[cs:DriveNo]	; Terminate our drive?
   622                              <1> 		je .doit
   623                              <1> 		jmp ElToritoErr		; Fail
   624                              <1> .doit:		mov es,P_DS		; Caller's DS:SI pointed to packet
   625                              <1> 		mov di,P_SI		; We'll use ES:DI
   626                              <1> 		mov si,CD_PKT.size	; First byte is packet size
   627                              <1> 		xor cx,0		; Empty our count
   628                              <1> 		;mov cl,[ds:si]		; We'll copy that many bytes
   629                              <1> 		mov cl,13h
   630                              <1> 		rep movsb		; Copy until CX is zero
   631                              <1> 		mov ax,0		; Success
   632                              <1> 		ret
   633                              <1> ElToritoEmulate:
   634                              <1> ElToritoBoot:
   635                              <1> ElToritoCatalog:
   636                              <1> ElToritoErr:
   637                              <1> 		TRACER '!'
   638                              <1> 		mov ax,100h		; Invalid parameter
   639                              <1> 		ret
   640                              <1> %endif ; ELTORITO
   641                              <1> %endif ; EDD
   642                              <1> 
   643                              <1> ;
   644                              <1> ; INT 15h intercept routines
   645                              <1> ;
   646                              <1> int15_e820:
   647 00000251 6681FA50414D53      <1> 		cmp edx,534D4150h	; "SMAP"
   648 00000258 0F858E00            <1> 		jne oldint15
   649 0000025C 6683F914            <1> 		cmp ecx,20		; Need 20 bytes
   650 00000260 7267                <1> 		jb err86
   651 00000262 1E                  <1> 		push ds
   652 00000263 0E                  <1> 		push cs
   653 00000264 1F                  <1> 		pop ds
   654 00000265 6652                <1> 		push edx		; "SMAP"
   655 00000267 6621DB              <1> 		and ebx,ebx
   656 0000026A 7506                <1> 		jne .renew
   657 0000026C 66BB[04010000]      <1> 		mov ebx,E820Table
   658                              <1> .renew:
   659 00000272 83C30C              <1> 		add bx,12		; Advance to next
   660 00000275 668B47FC            <1> 		mov eax,[bx-4]		; Type
   661 00000279 6621C0              <1> 		and eax,eax		; Null type?
   662 0000027C 74F4                <1> 		jz .renew		; If so advance to next
   663 0000027E 2666894510          <1> 		mov [es:di+16],eax
   664 00000283 668B47F4            <1> 		mov eax,[bx-12]		; Start addr (low)
   665 00000287 668B57F8            <1> 		mov edx,[bx-8]		; Start addr (high)
   666 0000028B 26668905            <1> 		mov [es:di],eax
   667 0000028F 2666895504          <1> 		mov [es:di+4],edx
   668 00000294 668B07              <1> 		mov eax,[bx]		; End addr (low)
   669 00000297 668B5704            <1> 		mov edx,[bx+4]		; End addr (high)
   670 0000029B 662B47F4            <1> 		sub eax,[bx-12]		; Derive the length
   671 0000029F 661B57F8            <1> 		sbb edx,[bx-8]
   672 000002A3 2666894508          <1> 		mov [es:di+8],eax	; Length (low)
   673 000002A8 266689550C          <1> 		mov [es:di+12],edx	; Length (high)
   674 000002AD 66837F08FF          <1> 		cmp dword [bx+8],-1	; Type of next = end?
   675 000002B2 7503                <1> 		jne .notdone
   676 000002B4 6631DB              <1> 		xor ebx,ebx		; Done with table
   677                              <1> .notdone:
   678 000002B7 6658                <1> 		pop eax			; "SMAP"
   679 000002B9 6689C2              <1> 		mov edx,eax		; Some systems expect eax = edx = SMAP
   680 000002BC 66B914000000        <1> 		mov ecx,20		; Bytes loaded
   681 000002C2 1F                  <1> 		pop ds
   682                              <1> int15_success:
   683 000002C3 C6460602            <1> 		mov byte [bp+6], 02h	; Clear CF
   684 000002C7 5D                  <1> 		pop bp
   685 000002C8 CF                  <1> 		iret
   686                              <1> 
   687                              <1> err86:
   688 000002C9 C6460603            <1> 		mov byte [bp+6], 03h	; Set CF
   689 000002CD B486                <1> 		mov ah,86h
   690 000002CF 5D                  <1> 		pop bp
   691 000002D0 CF                  <1> 		iret
   692                              <1> 
   693                              <1> Int15Start:
   694 000002D1 55                  <1> 		push bp
   695 000002D2 89E5                <1> 		mov bp,sp
   696 000002D4 3D20E8              <1> 		cmp ax,0E820h
   697 000002D7 0F8476FF            <1> 		je near int15_e820
   698 000002DB 3D01E8              <1> 		cmp ax,0E801h
   699 000002DE 7410                <1> 		je int15_e801
   700 000002E0 3D81E8              <1> 		cmp ax,0E881h
   701 000002E3 741A                <1> 		je int15_e881
   702 000002E5 80FC88              <1> 		cmp ah,88h
   703 000002E8 7428                <1> 		je int15_88
   704 000002EA 5D                  <1> oldint15:	pop bp
   705 000002EB 2EFF2E[BC00]        <1> 		jmp far [cs:OldInt15]
   706                              <1> 
   707                              <1> int15_e801:				; Get mem size for > 64 MB config
   708 000002F0 2EA1[D400]          <1> 		mov ax,[cs:Mem1MB]
   709 000002F4 89C1                <1> 		mov cx,ax
   710 000002F6 2E8B1E[D800]        <1> 		mov bx,[cs:Mem16MB]
   711 000002FB 89DA                <1> 		mov dx,bx
   712 000002FD EBC4                <1> 		jmp short int15_success
   713                              <1> 
   714                              <1> int15_e881:				; Get mem size for > 64 MB config
   715                              <1> 					; 32-bit code
   716 000002FF 2E66A1[D400]        <1> 		mov eax,[cs:Mem1MB]
   717 00000304 6689C1              <1> 		mov ecx,eax
   718 00000307 2E668B1E[D800]      <1> 		mov ebx,[cs:Mem16MB]
   719 0000030D 6689DA              <1> 		mov edx,ebx
   720 00000310 EBB1                <1> 		jmp short int15_success
   721                              <1> 
   722                              <1> int15_88:				; Get extended mem size
   723 00000312 2EA1[CA00]          <1> 		mov ax,[cs:MemInt1588]
   724 00000316 EBAB                <1> 		jmp short int15_success
   725                              <1> 
   726                              <1> ;
   727                              <1> ; Routine to copy in/out of high memory
   728                              <1> ; esi = linear source address
   729                              <1> ; edi = linear target address
   730                              <1> ; ecx = 32-bit word count
   731                              <1> ;
   732                              <1> ; Assumes cs = ds = es
   733                              <1> ;
   734                              <1> bcopy:
   735 00000318 6650                <1> 		push eax
   736 0000031A 6653                <1> 		push ebx
   737 0000031C 6652                <1> 		push edx
   738 0000031E 6655                <1> 		push ebp
   739                              <1> 
   740 00000320 BB[2B04]            <1> 		mov bx, real_int15_stub
   741                              <1> 
   742 00000323 F606[DF00]06        <1> 		test byte [ConfigFlags], CONFIG_RAW|CONFIG_SAFEINT
   743 00000328 0F849900            <1> 		jz .anymode		; Always do the real INT 15h
   744                              <1> 
   745 0000032C 0F01E0              <1> 		smsw ax			; Unprivileged!
   746 0000032F A801                <1> 		test al,01h
   747 00000331 0F859000            <1> 		jnz .protmode		; Protmode -> do real INT 15h
   748                              <1> 
   749                              <1> .realmode:
   750                              <1> 		; Raw or Safeint mode, and we're in real mode...
   751                              <1> 
   752 00000335 F606[DF00]04        <1> 		test byte [ConfigFlags], CONFIG_SAFEINT
   753 0000033A 0F858400            <1> 		jnz .fakeint15
   754                              <1> 
   755                              <1> .raw:
   756                              <1> 		TRACER 'r'
   757                              <1> 		; We're in real mode, do it outselves
   758                              <1> 
   759 0000033E 669C                <1> 		pushfd			; <A>
   760 00000340 1E                  <1> 		push ds			; <B>
   761 00000341 06                  <1> 		push es			; <C>
   762                              <1> 
   763 00000342 FA                  <1> 		cli
   764 00000343 FC                  <1> 		cld
   765                              <1> 
   766 00000344 6631DB              <1> 		xor ebx,ebx
   767 00000347 8CCB                <1> 		mov bx,cs
   768 00000349 66C1E304            <1> 		shl ebx,4
   769 0000034D 66678D93[30000000]  <1> 		lea edx,[Shaker+ebx]
   770 00000355 668916[3200]        <1> 		mov [Shaker+2],edx
   771                              <1> 
   772                              <1> 		; Test to see if A20 is enabled or not
   773 0000035A 31C0                <1> 		xor ax,ax
   774 0000035C 8ED8                <1> 		mov ds,ax
   775 0000035E 48                  <1> 		dec ax
   776 0000035F 8EC0                <1> 		mov es,ax
   777                              <1> 
   778 00000361 A10000              <1> 		mov ax,[0]
   779 00000364 89C3                <1> 		mov bx,ax
   780 00000366 26331E1000          <1> 		xor bx,[es:10h]
   781 0000036B F7D0                <1> 		not ax
   782 0000036D A30000              <1> 		mov [0],ax
   783 00000370 89C2                <1> 		mov dx,ax
   784 00000372 2633161000          <1> 		xor dx,[es:10h]
   785 00000377 F7D0                <1> 		not ax
   786 00000379 A30000              <1> 		mov [0],ax
   787                              <1> 
   788 0000037C 09DA                <1> 		or dx,bx
   789 0000037E 52                  <1> 		push dx			; <D> Save A20 status
   790 0000037F 7505                <1> 		jnz .skip_a20e
   791                              <1> 
   792 00000381 B80124              <1> 		mov ax,2401h		; Enable A20
   793 00000384 CD15                <1> 		int 15h
   794                              <1> .skip_a20e:
   795 00000386 8A16[DF00]          <1> 		mov dl,[ConfigFlags]
   796 0000038A 83E208              <1> 		and dx,CONFIG_BIGRAW
   797 0000038D 83C208              <1> 		add dx,8
   798                              <1> 		; DX = 16 for BIGRAW, 8 for RAW
   799                              <1> 		;  8 is selector for a 64K flat segment,
   800                              <1> 		; 16 is selector for a 4GB flat segment.
   801                              <1> 
   802 00000390 2E0F0116[3000]      <1> 		lgdt [cs:Shaker]
   803 00000396 0F20C0              <1> 		mov eax,cr0
   804 00000399 0C01                <1> 		or al,01h
   805 0000039B 0F22C0              <1> 		mov cr0,eax
   806                              <1> 
   807 0000039E BB1000              <1> 		mov bx,16		; Large flat segment
   808 000003A1 8EDB                <1> 		mov ds,bx
   809 000003A3 8EC3                <1> 		mov es,bx
   810                              <1> 
   811 000003A5 F36667A5            <1> 		a32 rep movsd
   812                              <1> 
   813                              <1> 		; DX has the appropriate value to put in
   814                              <1> 		; the registers on return
   815 000003A9 8EDA                <1> 		mov ds,dx
   816 000003AB 8EC2                <1> 		mov es,dx
   817                              <1> 
   818 000003AD 24FE                <1> 		and al,~01h
   819 000003AF 0F22C0              <1> 		mov cr0,eax
   820                              <1> 
   821 000003B2 5A                  <1> 		pop dx			; <D> A20 status
   822 000003B3 07                  <1> 		pop es			; <C>
   823 000003B4 1F                  <1> 		pop ds			; <B>
   824                              <1> 
   825 000003B5 21D2                <1> 		and dx,dx
   826 000003B7 7505                <1> 		jnz .skip_a20d
   827 000003B9 B80024              <1> 		mov ax,2400h		; Disable A20
   828 000003BC CD15                <1> 		int 15h
   829                              <1> .skip_a20d:
   830 000003BE 669D                <1> 		popfd			; <A>
   831 000003C0 EB60                <1> 		jmp .done
   832                              <1> 
   833                              <1> .fakeint15:
   834                              <1> 		; We're in real mode with CONFIG_SAFEINT, invoke the
   835                              <1> 		; original INT 15h vector.  We used to test for the
   836                              <1> 		; INT 15h vector being unchanged here, but that is
   837                              <1> 		; *us*; however, the test was wrong for years (always
   838                              <1> 		; negative) so instead of fixing the test do what we
   839                              <1> 		; tested and don't bother probing.
   840 000003C2 BB[2F04]            <1> 		mov bx, fake_int15_stub
   841                              <1> 
   842                              <1> .protmode:
   843                              <1> 		TRACER 'p'
   844                              <1> .anymode:
   845                              <1> 
   846                              <1> .copy_loop:
   847 000003C5 6656                <1> 		push esi
   848 000003C7 6657                <1> 		push edi
   849 000003C9 6651                <1> 		push ecx
   850 000003CB 6681F900400000      <1> 		cmp ecx,4000h
   851 000003D2 7606                <1> 		jna .safe_size
   852 000003D4 66B900400000        <1> 		mov ecx,4000h
   853                              <1> .safe_size:
   854 000003DA 6651                <1> 		push ecx	; Transfer size this cycle
   855 000003DC 6689F0              <1> 		mov eax, esi
   856 000003DF 8936[5A00]          <1> 		mov [Mover_src1], si
   857 000003E3 66C1E810            <1> 		shr eax, 16
   858 000003E7 A2[5C00]            <1> 		mov [Mover_src1+2], al
   859 000003EA 8826[5F00]          <1> 		mov [Mover_src2], ah
   860 000003EE 6689F8              <1> 		mov eax, edi
   861 000003F1 893E[6200]          <1> 		mov [Mover_dst1], di
   862 000003F5 66C1E810            <1> 		shr eax, 16
   863 000003F9 A2[6400]            <1> 		mov [Mover_dst1+2], al
   864 000003FC 8826[6700]          <1> 		mov [Mover_dst2], ah
   865 00000400 BE[4800]            <1> 		mov si,Mover
   866 00000403 B487                <1> 		mov ah, 87h
   867 00000405 D1E1                <1> 		shl cx,1	; Convert to 16-bit words
   868 00000407 FFD3                <1> 		call bx		; INT 15h stub
   869 00000409 6658                <1> 		pop eax		; Transfer size this cycle
   870 0000040B 6659                <1> 		pop ecx
   871 0000040D 665F                <1> 		pop edi
   872 0000040F 665E                <1> 		pop esi
   873 00000411 720F                <1> 		jc .error
   874 00000413 66678D3486          <1> 		lea esi,[esi+4*eax]
   875 00000418 66678D3C87          <1> 		lea edi,[edi+4*eax]
   876 0000041D 6629C1              <1> 		sub ecx, eax
   877 00000420 75A3                <1> 		jnz .copy_loop
   878                              <1> 		; CF = 0
   879                              <1> .error:
   880                              <1> .done:
   881 00000422 665D                <1> 		pop ebp
   882 00000424 665A                <1> 		pop edx
   883 00000426 665B                <1> 		pop ebx
   884 00000428 6658                <1> 		pop eax
   885 0000042A C3                  <1> 		ret
   886                              <1> 
   887                              <1> real_int15_stub:
   888 0000042B CD15                <1> 		int 15h
   889 0000042D FA                  <1> 		cli		; Some BIOSes enable interrupts on INT 15h
   890 0000042E C3                  <1> 		ret
   891                              <1> 
   892                              <1> fake_int15_stub:
   893 0000042F 9C                  <1> 		pushf
   894 00000430 FF1E[BC00]          <1> 		call far [OldInt15]
   895 00000434 FA                  <1> 		cli
   896 00000435 C3                  <1> 		ret
   897                              <1> 
   898                              <1> %ifdef DEBUG_TRACERS
   899                              <1> debug_tracer:	pushad
   900                              <1> 		pushfd
   901                              <1> 		mov bp,sp
   902                              <1> 		mov bx,[bp+9*4]
   903                              <1> 		mov al,[cs:bx]
   904                              <1> 		inc word [bp+9*4]
   905                              <1> 		mov ah,0Eh
   906                              <1> 		mov bx,7
   907                              <1> 		int 10h
   908                              <1> 		popfd
   909                              <1> 		popad
   910                              <1> 		ret
   911                              <1> 
   912                              <1> writehex2:	pushad
   913                              <1> 		pushfd
   914                              <1> 		mov cx,2
   915                              <1> 		ror eax,4
   916                              <1> 		jmp writehex_common
   917                              <1> writehex4:	pushad
   918                              <1> 		pushfd
   919                              <1> 		mov cx,4
   920                              <1> 		ror eax,12
   921                              <1> 		jmp writehex_common
   922                              <1> writehex8:	pushad
   923                              <1> 		pushfd
   924                              <1> 		mov cx,8
   925                              <1> 		ror eax,28
   926                              <1> writehex_common:
   927                              <1> .loop:		push cx
   928                              <1> 		push eax
   929                              <1> 		and al,0Fh
   930                              <1> 		cmp al,10
   931                              <1> 		jb .isdec
   932                              <1> 		add al,'a'-'0'-10
   933                              <1> .isdec:		add al,'0'
   934                              <1> 		mov ah,0Eh
   935                              <1> 		mov bx,7
   936                              <1> 		int 10h
   937                              <1> 		pop eax
   938                              <1> 		rol eax,4
   939                              <1> 		pop cx
   940                              <1> 		loop .loop
   941                              <1> 		popfd
   942                              <1> 		popad
   943                              <1> 		ret
   944                              <1> %endif
   945                              <1> 
   946                              <1> 		section .data align=16
   947                              <1> 		alignb 2
   948 00000000 [FC00]              <1> Int13Funcs	dw Reset		; 00h - RESET
   949 00000002 [4C01]              <1> 		dw GetStatus		; 01h - GET STATUS
   950 00000004 [5701]              <1> 		dw Read			; 02h - READ
   951 00000006 [6201]              <1> 		dw Write		; 03h - WRITE
   952 00000008 [7401]              <1> 		dw Verify		; 04h - VERIFY
   953 0000000A [2701]              <1> 		dw Invalid		; 05h - FORMAT TRACK
   954 0000000C [2701]              <1> 		dw Invalid		; 06h - FORMAT TRACK AND SET BAD FLAGS
   955 0000000E [2701]              <1> 		dw Invalid		; 07h - FORMAT DRIVE AT TRACK
   956 00000010 [7A01]              <1> 		dw GetParms		; 08h - GET PARAMETERS
   957 00000012 [7701]              <1> 		dw InitWithParms	; 09h - INITIALIZE CONTROLLER WITH
   958                              <1> 					;	DRIVE PARAMETERS
   959 00000014 [2701]              <1> 		dw Invalid		; 0Ah
   960 00000016 [2701]              <1> 		dw Invalid		; 0Bh
   961 00000018 [7401]              <1> 		dw Seek			; 0Ch - SEEK TO CYLINDER
   962 0000001A [FC00]              <1> 		dw Reset		; 0Dh - RESET HARD DISKS
   963 0000001C [2701]              <1> 		dw Invalid		; 0Eh
   964 0000001E [2701]              <1> 		dw Invalid		; 0Fh
   965 00000020 [7701]              <1> 		dw CheckIfReady		; 10h - CHECK IF READY
   966 00000022 [7701]              <1> 		dw Recalibrate		; 11h - RECALIBRATE
   967 00000024 [2701]              <1> 		dw Invalid		; 12h
   968 00000026 [2701]              <1> 		dw Invalid		; 13h
   969 00000028 [2701]              <1> 		dw Invalid		; 14h
   970 0000002A [2C01]              <1> 		dw GetDriveType		; 15h - GET DRIVE TYPE
   971 0000002C [7701]              <1> 		dw DetectChange		; 16h - DETECT DRIVE CHANGE
   972                              <1> %if EDD
   973                              <1> 		dw Invalid		; 17h
   974                              <1> 		dw Invalid		; 18h
   975                              <1> 		dw Invalid		; 19h
   976                              <1> 		dw Invalid		; 1Ah
   977                              <1> 		dw Invalid		; 1Bh
   978                              <1> 		dw Invalid		; 1Ch
   979                              <1> 		dw Invalid		; 1Dh
   980                              <1> 		dw Invalid		; 1Eh
   981                              <1> 		dw Invalid		; 1Fh
   982                              <1> 		dw Invalid		; 20h
   983                              <1> 		dw ReadMult		; 21h - READ MULTIPLE
   984                              <1> 		dw WriteMult		; 22h - WRITE MULTIPLE
   985                              <1> 		dw SetMode		; 23h - SET CONTROLLER FEATURES
   986                              <1> 		dw SetMode		; 24h - SET MULTIPLE MODE
   987                              <1> 		dw Invalid		; 25h - IDENTIFY DRIVE
   988                              <1> 		dw Invalid		; 26h
   989                              <1> 		dw Invalid		; 27h
   990                              <1> 		dw Invalid		; 28h
   991                              <1> 		dw Invalid		; 29h
   992                              <1> 		dw Invalid		; 2Ah
   993                              <1> 		dw Invalid		; 2Bh
   994                              <1> 		dw Invalid		; 2Ch
   995                              <1> 		dw Invalid		; 2Dh
   996                              <1> 		dw Invalid		; 2Eh
   997                              <1> 		dw Invalid		; 2Fh
   998                              <1> 		dw Invalid		; 30h
   999                              <1> 		dw Invalid		; 31h
  1000                              <1> 		dw Invalid		; 32h
  1001                              <1> 		dw Invalid		; 33h
  1002                              <1> 		dw Invalid		; 34h
  1003                              <1> 		dw Invalid		; 35h
  1004                              <1> 		dw Invalid		; 36h
  1005                              <1> 		dw Invalid		; 37h
  1006                              <1> 		dw Invalid		; 38h
  1007                              <1> 		dw Invalid		; 39h
  1008                              <1> 		dw Invalid		; 3Ah
  1009                              <1> 		dw Invalid		; 3Bh
  1010                              <1> 		dw Invalid		; 3Ch
  1011                              <1> 		dw Invalid		; 3Dh
  1012                              <1> 		dw Invalid		; 3Eh
  1013                              <1> 		dw Invalid		; 3Fh
  1014                              <1> 		dw Invalid		; 40h
  1015                              <1> 		dw EDDPresence		; 41h - EDD PRESENCE DETECT
  1016                              <1> 		dw EDDRead		; 42h - EDD READ
  1017                              <1> 		dw EDDWrite		; 43h - EDD WRITE
  1018                              <1> 		dw EDDVerify		; 44h - EDD VERIFY
  1019                              <1> 		dw EDDLock		; 45h - EDD LOCK/UNLOCK MEDIA
  1020                              <1> 		dw EDDEject		; 46h - EDD EJECT
  1021                              <1> 		dw EDDSeek		; 47h - EDD SEEK
  1022                              <1> 		dw EDDGetParms		; 48h - EDD GET PARAMETERS
  1023                              <1> 		dw EDDDetectChange	; 49h - EDD MEDIA CHANGE STATUS
  1024                              <1> %if ELTORITO				; EDD El Torito Functions
  1025                              <1> 					; ELTORITO _must_ also have EDD
  1026                              <1> 		dw ElToritoEmulate	; 4Ah - Initiate Disk Emulation
  1027                              <1> 		dw ElToritoTerminate	; 4Bh - Terminate Disk Emulation
  1028                              <1> 		dw ElToritoBoot		; 4Ch - Initiate Disk Emu. and Reboot
  1029                              <1> 		dw ElToritoCatalog	; 4Dh - Return Boot Catalog
  1030                              <1> %endif ; ELTORITO
  1031                              <1> %endif ; EDD
  1032                              <1> 
  1033                              <1> Int13FuncsEnd	equ $
  1034                              <1> Int13FuncsCnt	equ (Int13FuncsEnd-Int13Funcs) >> 1
  1035                              <1> 
  1036                              <1> 
  1037 0000002E 00<rept>            <1> 		alignb 8, db 0
  1038 00000030 1700                <1> Shaker		dw ShakerEnd-$-1	; Descriptor table limit
  1039 00000032 00000000            <1> 		dd 0			; Pointer to self
  1040 00000036 0000                <1> 		dw 0
  1041                              <1> 
  1042 00000038 FFFF0000            <1> Shaker_RMDS:	dd 0x0000ffff		; 64K data segment
  1043 0000003C 00930000            <1> 		dd 0x00009300
  1044                              <1> 
  1045 00000040 FFFF0000            <1> Shaker_DS:	dd 0x0000ffff		; 4GB data segment
  1046 00000044 00938F00            <1> 		dd 0x008f9300
  1047                              <1> 
  1048                              <1> ShakerEnd	equ $
  1049                              <1> 
  1050                              <1> 		alignb 8, db 0
  1051                              <1> 
  1052 00000048 000000000000000000- <1> Mover		dd 0, 0, 0, 0		; Must be zero
  1052 00000051 00000000000000      <1>
  1053 00000058 FFFF                <1> 		dw 0ffffh		; 64 K segment size
  1054 0000005A 000000              <1> Mover_src1:	db 0, 0, 0		; Low 24 bits of source addy
  1055 0000005D 93                  <1> 		db 93h			; Access rights
  1056 0000005E 00                  <1> 		db 00h			; Extended access rights
  1057 0000005F 00                  <1> Mover_src2:	db 0			; High 8 bits of source addy
  1058 00000060 FFFF                <1> 		dw 0ffffh		; 64 K segment size
  1059 00000062 000000              <1> Mover_dst1:	db 0, 0, 0		; Low 24 bits of target addy
  1060 00000065 93                  <1> 		db 93h			; Access rights
  1061 00000066 00                  <1> 		db 00h			; Extended access rights
  1062 00000067 00                  <1> Mover_dst2:	db 0			; High 8 bits of source addy
  1063 00000068 000000000000000000- <1> Mover_dummy2:	dd 0, 0, 0, 0		; More space for the BIOS
  1063 00000071 00000000000000      <1>
  1064                              <1> 
  1065 00000078 00<rept>            <1> 		alignb 16, db 0
  1066                              <1> mBFT:
  1067                              <1> ; Fields common to all ACPI tables
  1068 00000080 20202020            <1> 		dd '    '		; ACPI signature ("mBFT")
  1069                              <1> 					; This is filled-in by the installer
  1070                              <1> 					; to avoid an accidentally valid mBFT
  1071 00000084 46000000            <1> 		dd mBFT_Len		; ACPI table length
  1072 00000088 01                  <1> 		db 1			; ACPI revision
  1073 00000089 00                  <1> 		db 0			; ACPI table checksum
  1074 0000008A 4D454D44534B        <1> 		db 'MEMDSK'		; ACPI OEM ID
  1075 00000090 5379736C696E7578    <1> 		db 'Syslinux'		; ACPI OEM table ID
  1076 00000098 00000000            <1> 		dd 0			; ACPI OEM revision
  1077 0000009C 00000000            <1> 		dd 0			; ACPI ASL compiler vendor ID
  1078 000000A0 00000000            <1> 		dd 0			; ACPI ASL compiler revision
  1079                              <1> ; The next field is mBFT-specific and filled-in by the installer
  1080 000000A4 00000000            <1> 		dd 0			; "Safe hook" physical address
  1081                              <1> 
  1082                              <1> ; Note that the above ends on a DWORD boundary.
  1083                              <1> ; The MDI has always started at such a boundary.
  1084                              <1> ; Portions of the MDI are patched by the installer
  1085                              <1> MemDisk_Info	equ $			; Pointed to by installation check
  1086 000000A8 1E00                <1> MDI_Bytes	dw MDI_Len		; Total bytes in MDI structure
  1087 000000AA 0406                <1> MDI_Version	db VERSION_MINOR, VERSION_MAJOR	; MEMDISK version
  1088                              <1> 
  1089 000000AC 00000000            <1> DiskBuf		dd 0			; Linear address of high memory disk
  1090 000000B0 00000000            <1> DiskSize	dd 0			; Size of disk in blocks
  1091 000000B4 00000000            <1> CommandLine	dw 0, 0			; Far pointer to saved command line
  1092                              <1> 
  1093 000000B8 00000000            <1> OldInt13	dd 0			; INT 13h in chain
  1094 000000BC 00000000            <1> OldInt15	dd 0			; INT 15h in chain
  1095                              <1> 
  1096 000000C0 0000                <1> OldDosMem	dw 0			; Old position of DOS mem end
  1097 000000C2 00                  <1> BootLoaderID	db 0			; Boot loader ID from header
  1098 000000C3 00                  <1> 		db 0			; pad
  1099                              <1> 
  1100 000000C4 0000                <1> DPT_ptr		dw 0			; If nonzero, pointer to DPT
  1101                              <1> 					; Original DPT pointer follows
  1102                              <1> 
  1103                              <1> MDI_Len		equ $-MemDisk_Info
  1104                              <1> mBFT_Len	equ $-mBFT		; mBFT includes the MDI
  1105                              <1> 
  1106                              <1> ; ---- MDI structure ends here ---
  1107 000000C6 FF                  <1> DriveShiftLimit	db 0ffh			; Installer will probe for
  1108                              <1> 					; a range of contiguous drives.
  1109                              <1> 					; Any BIOS drives above this region
  1110                              <1> 					; shall not be impacted by our
  1111                              <1> 					; shifting behaviour
  1112 000000C7 00                  <1> 		db 0			; pad to a DWORD
  1113 000000C8 0000                <1> 		dw 0			; pad to a QWORD
  1114 000000CA 0000                <1> MemInt1588	dw 0			; 1MB-65MB memory amount (1K)
  1115                              <1> 
  1116 000000CC 0000                <1> Cylinders	dw 0			; Cylinder count
  1117 000000CE 0000                <1> Heads		dw 0			; Head count
  1118 000000D0 00000000            <1> Sectors		dd 0			; Sector count (zero-extended)
  1119                              <1> 
  1120 000000D4 00000000            <1> Mem1MB		dd 0			; 1MB-16MB memory amount (1K)
  1121 000000D8 00000000            <1> Mem16MB		dd 0			; 16MB-4G memory amount (64K)
  1122                              <1> 
  1123 000000DC 00                  <1> DriveNo		db 0			; Our drive number
  1124 000000DD 00                  <1> DriveType	db 0			; Our drive type (floppies)
  1125 000000DE 00                  <1> DriveCnt	db 0			; Drive count (from the BIOS)
  1126                              <1> 
  1127 000000DF 00                  <1> ConfigFlags	db 0			; Bit 0 - readonly
  1128                              <1> 
  1129 000000E0 0000                <1> MyStack		dw 0			; Offset of stack
  1130 000000E2 0000                <1> StatusPtr	dw 0			; Where to save status (zeroseg ptr)
  1131                              <1> 
  1132 000000E4 00<rept>            <1> DPT		times 16 db 0		; BIOS parameter table pointer (floppies)
  1133 000000F4 00000000            <1> OldInt1E	dd 0			; Previous INT 1E pointer (DPT)
  1134                              <1> 
  1135                              <1> %if EDD
  1136                              <1> EDD_DPT:
  1137                              <1> .length		dw 30
  1138                              <1> .info		dw 0029h
  1139                              <1> 		; Bit 0 - DMA boundaries handled transparently
  1140                              <1> 		; Bit 3 - Device supports write verify
  1141                              <1> 		; Bit 5 - Media is lockable
  1142                              <1> .cylinders	dd 0			; Filled in by installer
  1143                              <1> .heads		dd 0			; Filled in by installer
  1144                              <1> .sectors	dd 0			; Filled in by installer
  1145                              <1> .totalsize	dd 0, 0			; Filled in by installer
  1146                              <1> .bytespersec	dw SECTORSIZE
  1147                              <1> .eddtable	dw -1, -1		; Invalid DPTE pointer
  1148                              <1> .dpikey		dw 0BEDDh		; Device Path Info magic
  1149                              <1> .dpilen		db 2ch			; DPI len
  1150                              <1> .res1		db 0			; Reserved
  1151                              <1> .res2		dw 0			; Reserved
  1152                              <1> .bustype	dd 'MEM '		; Host bus type (4 bytes, space padded)
  1153                              <1> .inttype	dd 'MEMORY  '		; Interface type (8 bytes, spc. padded)
  1154                              <1> .intpath	dd 0, 0			; Interface path
  1155                              <1> .devpath	dd 0, 0, 0, 0		; Device path
  1156                              <1> .res3		db 0			; Reserved
  1157                              <1> .chksum		db 0			; DPI checksum
  1158                              <1> 
  1159                              <1> %if ELTORITO
  1160                              <1> ; El Torito CD Specification Packet - mostly filled in by installer
  1161                              <1> CD_PKT:
  1162                              <1> .size		db 13h	; Packet size (19 bytes)
  1163                              <1> .type		db 0	; Boot media type (flags)
  1164                              <1> .driveno	db 0E0h	; INT 13h drive number
  1165                              <1> .controller	db 0	; Controller index
  1166                              <1> .start		dd 0	; Starting LBA of image
  1167                              <1> .devno		dw 0	; Device number
  1168                              <1> .user_buf	dw 0	; User buffer segment
  1169                              <1> .load_seg	dw 0	; Load segment
  1170                              <1> .sect_count	dw 0	; Emulated sectors to load
  1171                              <1> .geom1		db 0	; Cylinders bits 0 thru 7
  1172                              <1> .geom2		db 0	; Sects/track 0 thru 5, cyls 8, 9
  1173                              <1> .geom3		db 0	; Heads
  1174                              <1> %endif ; ELTORITO
  1175                              <1> 
  1176                              <1> %endif ; EDD
  1177                              <1> 
  1178                              <1> ; End patch area
  1179                              <1> 
  1180                              <1> 		alignb 4, db 0
  1181 000000F8 00000000            <1> Stack		dd 0			; Saved SS:ESP on invocation
  1182 000000FC 0000                <1> 		dw 0
  1183 000000FE 0000                <1> SavedAX		dw 0			; AX saved on invocation
  1184 00000100 0000                <1> Recursive	dw 0			; Recursion counter
  1185                              <1> 
  1186 00000102 00<rept>            <1> 		alignb 4, db 0		; We *MUST* end on a dword boundary
  1187                              <1> 
  1188                              <1> E820Table	equ $			; The installer loads the E820 table here
  1189                              <1> TotalSize	equ $			; End pointer
