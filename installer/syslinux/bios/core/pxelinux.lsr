     1                                  ; -*- fundamental -*- (asm-mode sucks)
     2                                  ; ****************************************************************************
     3                                  ;
     4                                  ;  pxelinux.asm
     5                                  ;
     6                                  ;  A program to boot Linux kernels off a TFTP server using the Intel PXE
     7                                  ;  network booting API.  It is based on the SYSLINUX boot loader for
     8                                  ;  MS-DOS floppies.
     9                                  ;
    10                                  ;   Copyright 1994-2009 H. Peter Anvin - All Rights Reserved
    11                                  ;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
    12                                  ;
    13                                  ;  This program is free software; you can redistribute it and/or modify
    14                                  ;  it under the terms of the GNU General Public License as published by
    15                                  ;  the Free Software Foundation, Inc., 53 Temple Place Ste 330,
    16                                  ;  Boston MA 02111-1307, USA; either version 2 of the License, or
    17                                  ;  (at your option) any later version; incorporated herein by reference.
    18                                  ;
    19                                  ; ****************************************************************************
    20                                  
    21                                  %define IS_PXELINUX 1
    22                                  %include "head.inc"
     1                              <1> ; -*- fundamental -*- (asm-mode sucks)
     2                              <1> ; -----------------------------------------------------------------------
     3                              <1> ;
     4                              <1> ;   Copyright 2006-2008 H. Peter Anvin - All Rights Reserved
     5                              <1> ;
     6                              <1> ;   This program is free software; you can redistribute it and/or modify
     7                              <1> ;   it under the terms of the GNU General Public License as published by
     8                              <1> ;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <1> ;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <1> ;   (at your option) any later version; incorporated herein by reference.
    11                              <1> ;
    12                              <1> ; -----------------------------------------------------------------------
    13                              <1> 
    14                              <1> ;
    15                              <1> ; head.inc
    16                              <1> ;
    17                              <1> ; Common header includes
    18                              <1> ;
    19                              <1> 
    20                              <1> %ifndef _HEAD_INC
    21                              <1> %define _HEAD_INC
    22                              <1> 
    23                              <1> %if __NASM_MAJOR__ < 2 || (__NASM_MAJOR__ == 2 && __NASM_MINOR__ < 3)
    24                              <1>  %error "NASM 2.03 or later required to compile correctly"
    25                              <1> %endif
    26                              <1> 
    27                              <1> %include "macros.inc"
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 1994-2008 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
     5                              <2> ;;
     6                              <2> ;;   This program is free software; you can redistribute it and/or modify
     7                              <2> ;;   it under the terms of the GNU General Public License as published by
     8                              <2> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <2> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    11                              <2> ;;
    12                              <2> ;; -----------------------------------------------------------------------
    13                              <2> 
    14                              <2> ;;
    15                              <2> ;; macros.inc
    16                              <2> ;;
    17                              <2> ;; Convenient macros
    18                              <2> ;;
    19                              <2> 
    20                              <2> %ifndef _MACROS_INC
    21                              <2> %define _MACROS_INC
    22                              <2> 
    23                              <2> ;
    24                              <2> ; Identify the module we're compiling; the "correct" should be defined
    25                              <2> ; in the module itself to 1
    26                              <2> ;
    27                              <2> %ifdef IS_SYSLINUX
    28                              <2>  %define MY_NAME 'SYSLINUX'
    29                              <2> %else
    30                              <2>  %define IS_SYSLINUX 0
    31                              <2> %endif
    32                              <2> %ifdef IS_PXELINUX
    33                              <2>  %define MY_NAME 'PXELINUX'
    34                              <2>  %if IS_LPXELINUX > 0
    35                              <2>   %define MY_TYPE 'lwIP'
    36                              <2>  %else
    37                              <2>   %define MY_TYPE 'PXE'
    38                              <2>  %endif
    39                              <2> %else
    40                              <2>  %define IS_PXELINUX 0
    41                              <2> %endif
    42                              <2> %ifdef IS_ISOLINUX
    43                              <2>  %define MY_NAME 'ISOLINUX'
    44                              <2> %else
    45                              <2>  %define IS_ISOLINUX 0
    46                              <2> %endif
    47                              <2> %ifdef IS_EXTLINUX
    48                              <2>  %define MY_NAME 'EXTLINUX'
    49                              <2> %else
    50                              <2>  %define IS_EXTLINUX 0
    51                              <2> %endif
    52                              <2> 
    53                              <2> ;
    54                              <2> ; Macros similar to res[bwd], but which works in the code segment (after
    55                              <2> ; section .text16) or the data segment (section .data16)
    56                              <2> ;
    57                              <2> %macro	zb	1.nolist
    58                              <2> 	times %1 db 0
    59                              <2> %endmacro
    60                              <2> 
    61                              <2> %macro	zw	1.nolist
    62                              <2> 	times %1 dw 0
    63                              <2> %endmacro
    64                              <2> 
    65                              <2> %macro	zd	1.nolist
    66                              <2> 	times %1 dd 0
    67                              <2> %endmacro
    68                              <2> 
    69                              <2> ;
    70                              <2> ; Align with zero bytes in a progbits segment
    71                              <2> ;
    72                              <2> %macro	alignz	1.nolist
    73                              <2> 	times (((%1) - (($-$$) % (%1))) % (%1)) db 0
    74                              <2> %endmacro
    75                              <2> 
    76                              <2> ;
    77                              <2> ; Macro to emit an unsigned decimal number as a string
    78                              <2> ;
    79                              <2> %macro asciidec	1.nolist
    80                              <2>   %ifndef DEPEND	; Not safe for "depend"
    81                              <2>     %push asciidec
    82                              <2>       %assign %$v %1
    83                              <2>       %if %$v == 0
    84                              <2>         db '0'
    85                              <2>       %else
    86                              <2>         %assign %$dcount 0
    87                              <2>         %assign %$n %$v
    88                              <2>         %assign %$d 1
    89                              <2>         %rep 20
    90                              <2>           %if %$n != 0
    91                              <2>             %assign %$dcount %$dcount + 1
    92                              <2>             %assign %$n %$n / 10
    93                              <2>             %assign %$d %$d * 10
    94                              <2>           %endif
    95                              <2>         %endrep
    96                              <2>         %rep %$dcount
    97                              <2> 	  %assign %$d %$d / 10
    98                              <2>           db ((%$v / %$d) % 10) + '0'
    99                              <2>         %endrep
   100                              <2>       %endif
   101                              <2>     %pop
   102                              <2>   %endif
   103                              <2> %endmacro
   104                              <2> 
   105                              <2> ;
   106                              <2> ; Macros for network byte order of constants
   107                              <2> ;
   108                              <2> %define htons(x)  ( ( ((x) & 0FFh) << 8 ) + ( ((x) & 0FF00h) >> 8 ) )
   109                              <2> %define ntohs(x) htons(x)
   110                              <2> %define htonl(x)  ( ( ((x) & 0FFh) << 24) + ( ((x) & 0FF00h) << 8 ) + ( ((x) & 0FF0000h) >> 8 ) + ( ((x) & 0FF000000h) >> 24) )
   111                              <2> %define ntohl(x) htonl(x)
   112                              <2> 
   113                              <2> ;
   114                              <2> ; ASCII
   115                              <2> ;
   116                              <2> CR		equ 13		; Carriage Return
   117                              <2> LF		equ 10		; Line Feed
   118                              <2> FF		equ 12		; Form Feed
   119                              <2> BS		equ  8		; Backspace
   120                              <2> 
   121                              <2> %endif ; _MACROS_INC
    28                              <1> %include "config.inc"
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 2002-2009 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
     5                              <2> ;;
     6                              <2> ;;   This program is free software; you can redistribute it and/or modify
     7                              <2> ;;   it under the terms of the GNU General Public License as published by
     8                              <2> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <2> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    11                              <2> ;;
    12                              <2> ;; -----------------------------------------------------------------------
    13                              <2> 
    14                              <2> ;;
    15                              <2> ;; config.inc
    16                              <2> ;;
    17                              <2> ;; Common configuration options.  Some of these are imposed by the kernel.
    18                              <2> ;;
    19                              <2> 
    20                              <2> %ifndef _CONFIG_INC
    21                              <2> %define _CONFIG_INC
    22                              <2> 
    23                              <2> max_cmd_len	equ 2047		; Must be &3; 2047 is the kernel limit
    24                              <2> HIGHMEM_MAX	equ 037FFFFFFh		; DEFAULT highest address for an initrd
    25                              <2> DEFAULT_BAUD	equ 9600		; Default baud rate for serial port
    26                              <2> BAUD_DIVISOR	equ 115200		; Serial port parameter
    27                              <2> MAX_FKEYS	equ 12			; Number of F-key help files
    28                              <2> 
    29                              <2> ;
    30                              <2> ; log2(Max filename size Including final null)
    31                              <2> ;
    32                              <2> FILENAME_MAX_LG2 equ 8
    33                              <2> FILENAME_MAX	 equ (1 << FILENAME_MAX_LG2)	; Max mangled filename size
    34                              <2> 
    35                              <2> ;
    36                              <2> ; Version number definitinons
    37                              <2> ;
    38                              <2> %include "../version.gen"
     1                              <3> %define VERSION 6.04
     2                              <3> %define VERSION_STR "6.04"
     3                              <3> %define VERSION_MAJOR 6
     4                              <3> %define VERSION_MINOR 4
     5                              <3> %define YEAR 2015
     6                              <3> %define YEAR_STR "2015"
    39                              <2> 
    40                              <2> %endif ; _CONFIG_INC
    29                              <1> %include "layout.inc"
     1                              <2> ; -----------------------------------------------------------------------
     2                              <2> ;
     3                              <2> ;   Copyright 1994-2009 H. Peter Anvin - All Rights Reserved
     4                              <2> ;   Copyright 2009-2010 Intel Corporation; author: H. Peter Anvin
     5                              <2> ;
     6                              <2> ;   This program is free software; you can redistribute it and/or modify
     7                              <2> ;   it under the terms of the GNU General Public License as published by
     8                              <2> ;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <2> ;   Bostom MA 02111-1307, USA; either version 2 of the License, or
    10                              <2> ;   (at your option) any later version; incorporated herein by reference.
    11                              <2> ;
    12                              <2> ; -----------------------------------------------------------------------
    13                              <2> 
    14                              <2> ;
    15                              <2> ; layout.inc
    16                              <2> ;
    17                              <2> ; Memory layout of segments
    18                              <2> ;
    19                              <2> 
    20                              <2> 		; Default to 16-bit code
    21                              <2> 		bits 16
    22                              <2> 
    23                              <2> ; Memory below 0800h is reserved for the BIOS and the MBR.
    24                              <2> BSS_START	equ 0800h
    25                              <2> 
    26                              <2> ; Text starts at the load address of 07C00h.
    27                              <2> TEXT_START	equ 7C00h
    28                              <2> 
    29                              <2> ;
    30                              <2> ; 16-bit stack layout
    31                              <2> ;
    32                              <2> ; PXELINUX: There are apparently some AMI BIOSes in the field which
    33                              <2> ; put their BEV stack somewhere below 7C00h (and therefore don't
    34                              <2> ; handle localboot properly), so avoid that immediate memory region.
    35                              <2> ; The range that is known to be bad is approximately 75E8..7C00; the
    36                              <2> ; lower bound is tight.
    37                              <2> ; 
    38                              <2> 		global STACK_LEN, STACK_TOP, STACK_BASE
    39                              <2> STACK_LEN	equ 4096
    40                              <2> %if IS_PXELINUX
    41                              <2> STACK_TOP	equ 7000h
    42                              <2> %else
    43                              <2> STACK_TOP	equ 7c00h
    44                              <2> %endif
    45                              <2> STACK_BASE	equ STACK_TOP - STACK_LEN
    46                              <2> 
    47                              <2> ; The secondary BSS section, above the text; we really wish we could
    48                              <2> ; just make it follow .bcopy32 or hang off the end,
    49                              <2> ; but it doesn't seem to work that way.
    50                              <2> LATEBSS_START	equ 0B800h
    51                              <2> 
    52                              <2> ;
    53                              <2> ; 32-bit stack layout
    54                              <2> ;
    55                              <2> STACK32_LEN	equ 64*1024
    56                              <2> 
    57                              <2> 		section	.stack		nobits write align=4096
    58 00000000 <res 00010000>      <2> 		resb STACK32_LEN
    59                              <2> 
    60                              <2> ;
    61                              <2> ; The various sections and their relationship
    62                              <2> ;
    63                              <2> 		; Use .earlybss for things that MUST be in low memory.
    64                              <2> 		section .earlybss	nobits write
    65                              <2> 		section .config		write progbits align=4
    66                              <2> 		section .replacestub	exec write progbits align=16
    67                              <2> 		section .gentextnr	exec write nobits align=16
    68                              <2> 		section .stack16	write nobits align=16
    69                              <2> 
    70                              <2> 		; Use .bss16 for things that doesn't have to be in low memory;
    71                              <2> 		; .earlybss should be used for things that absolutely have
    72                              <2> 		; to be below 0x7c00.
    73                              <2> 		section .bss16		write nobits align=16
    74                              <2> 
    75                              <2> %if 0 ; IS_PXELINUX
    76                              <2> 		; Warning here: RBFG build 22 randomly overwrites
    77                              <2> 		; memory location [0x5680,0x576c), possibly more.  It
    78                              <2> 		; seems that it gets confused and screws up the
    79                              <2> 		; pointer to its own internal packet buffer and starts
    80                              <2> 		; writing a received ARP packet into low memory.
    81                              <2> 		section .rbfg		write nobits
    82                              <2> RBFG_brainfuck:	resb 2048		; Bigger than an Ethernet packet...
    83                              <2> %endif
    84                              <2> 
    85                              <2> 		section .init		exec write progbits align=1
    86                              <2> 		section .text16		exec write progbits align=1
    87                              <2> 		section .textnr		exec nowrite progbits align=1
    88                              <2> 		section .bcopyxx.text	exec nowrite progbits align=16
    89                              <2> 		section .bcopyxx.data	noexec write progbits align=16
    90                              <2> 		section .data16		noexec write progbits align=16
    91                              <2> 
    92                              <2> 		section .adv		write nobits align=512
    93                              <2> 
    94                              <2> 		; .uibss contains bss data which is guaranteed to be
    95                              <2> 		; safe to clobber during the loading of the image.  This
    96                              <2> 		; is because while loading the primary image we will clobber
    97                              <2> 		; the spillover from the last fractional sector load.
    98                              <2> 		section .uibss		write nobits align=16
    99                              <2> 
   100                              <2> 		section .savedata	write nobits align=16
   101                              <2> 
   102                              <2> 		; Symbols from linker script
   103                              <2> %macro SECINFO 1
   104                              <2> 		extern __%1_start, __%1_end
   105                              <2> 		extern __%1_len, __%1_dwords
   106                              <2> %endmacro
   107                              <2> 
   108                              <2> 		SECINFO bss16
   108                              <3>  extern __%1_start, __%1_end
   108                              <3>  extern __%1_len, __%1_dwords
   109                              <2> 		SECINFO uibss
   109                              <3>  extern __%1_start, __%1_end
   109                              <3>  extern __%1_len, __%1_dwords
   110                              <2> 		SECINFO config
   110                              <3>  extern __%1_start, __%1_end
   110                              <3>  extern __%1_len, __%1_dwords
   111                              <2> 		SECINFO replacestub
   111                              <3>  extern __%1_start, __%1_end
   111                              <3>  extern __%1_len, __%1_dwords
   112                              <2> 		SECINFO bcopyxx
   112                              <3>  extern __%1_start, __%1_end
   112                              <3>  extern __%1_len, __%1_dwords
   113                              <2> 
   114                              <2> 		SECINFO pm_code
   114                              <3>  extern __%1_start, __%1_end
   114                              <3>  extern __%1_len, __%1_dwords
   115                              <2> 		SECINFO high_clear
   115                              <3>  extern __%1_start, __%1_end
   115                              <3>  extern __%1_len, __%1_dwords
   116                              <2> 		extern __pm_code_lma
   117                              <2> 
   118                              <2> 		SECINFO bss
   118                              <3>  extern __%1_start, __%1_end
   118                              <3>  extern __%1_len, __%1_dwords
   119                              <2> 
   120                              <2> 		extern free_high_memory
   121                              <2> 
   122                              <2> 		global _start
   123                              <2> 
   124                              <2> 		section .text16
   125                              <2> 
   126                              <2> ;
   127                              <2> ; Segment assignments in the bottom 640K
   128                              <2> ; Keep the low-memory footprint as small as possible... overrun is a hard
   129                              <2> ; failure!
   130                              <2> ;
   131                              <2> 
   132                              <2> serial_buf_size	equ 4096		; Should be a power of 2
   133                              <2> 
   134                              <2> ;
   135                              <2> ; Transfer buffer segment: guaranteed to be aligned 64K, used for disk I/O
   136                              <2> ; One symbol for the segment number, one for the absolute address
   137                              <2> ;
   138                              <2> 		extern	xfer_buf_seg
   139                              <2> 		section .xfer_buf	write nobits align=65536
   140                              <2> 		global	core_xfer_buf:data hidden
   141 00000000 <res 00010000>      <2> core_xfer_buf	resb 65536
   142                              <2> 
   143                              <2> ;
   144                              <2> ; At the very end, the lowmem heap
   145                              <2> ;
   146                              <2> 		extern __lowmem_heap
   147                              <2> min_lowmem_heap	equ 65536
   148                              <2> 
   149                              <2> 		section .text16
    30                              <1> %include "pmcall.inc"
     1                              <2> ;;
     2                              <2> ;; pmcall.inc
     3                              <2> ;;
     4                              <2> ;; Macros for the stack frame set up by pm_call, assuming ebp is left
     5                              <2> ;; as the RM frame pointer.
     6                              <2> ;;
     7                              <2> 
     8                              <2> %ifndef PMCALL_INC
     9                              <2> %define PMCALL_INC
    10                              <2> 
    11                              <2> %define RM_GS		word [ebp]
    12                              <2> %define RM_FS		word [ebp+2]
    13                              <2> %define RM_ES		word [ebp+4]
    14                              <2> %define RM_DS		word [ebp+6]
    15                              <2> 
    16                              <2> %define RM_EDI		dword [ebp+8]
    17                              <2> %define RM_DI		word [ebp+8]
    18                              <2> %define RM_HDI		word [ebp+10]
    19                              <2> %define RM_DIL		byte [ebp+8]
    20                              <2> %define RM_DIH		byte [ebp+9]
    21                              <2> 
    22                              <2> %define RM_ESI		dword [ebp+12]
    23                              <2> %define RM_SI		word [ebp+12]
    24                              <2> %define RM_HSI		word [ebp+14]
    25                              <2> %define RM_SIL		byte [ebp+12]
    26                              <2> %define RM_SIH		byte [ebp+13]
    27                              <2> 
    28                              <2> %define RM_EBP		dword [ebp+16]
    29                              <2> %define RM_BP		word [ebp+16]
    30                              <2> %define RM_HBP		word [ebp+18]
    31                              <2> %define RM_BPL		byte [ebp+16]
    32                              <2> %define RM_BPH		byte [ebp+17]
    33                              <2> 
    34                              <2> %define RM_EBX		dword [ebp+24]
    35                              <2> %define RM_BX		word [ebp+24]
    36                              <2> %define RM_HBX		word [ebp+26]
    37                              <2> %define RM_BL		byte [ebp+24]
    38                              <2> %define RM_BH		byte [ebp+25]
    39                              <2> 
    40                              <2> %define RM_EDX		dword [ebp+28]
    41                              <2> %define RM_DX		word [ebp+28]
    42                              <2> %define RM_HDX		word [ebp+30]
    43                              <2> %define RM_DL		byte [ebp+28]
    44                              <2> %define RM_DH		byte [ebp+29]
    45                              <2> 
    46                              <2> %define RM_ECX		dword [ebp+32]
    47                              <2> %define RM_CX		word [ebp+32]
    48                              <2> %define RM_HCX		word [ebp+34]
    49                              <2> %define RM_CL		byte [ebp+32]
    50                              <2> %define RM_CH		byte [ebp+33]
    51                              <2> 
    52                              <2> %define RM_EAX		dword [ebp+36]
    53                              <2> %define RM_AX		word [ebp+36]
    54                              <2> %define RM_HAX		word [ebp+38]
    55                              <2> %define RM_AL		byte [ebp+36]
    56                              <2> %define RM_AH		byte [ebp+37]
    57                              <2> 
    58                              <2> %define RM_EFLAGS	dword [ebp+40]
    59                              <2> %define RM_FLAGS	word [ebp+40]
    60                              <2> %define RM_HFLAGS	word [ebp+42]
    61                              <2> %define RM_FLAGSL	byte [ebp+40]
    62                              <2> %define RM_FLAGSH	byte [ebp+41]
    63                              <2> 
    64                              <2> ; Convenience macro to call a PM function
    65                              <2> %macro	pm_call	1
    66                              <2> 	push dword %1
    67                              <2> 	call _pm_call
    68                              <2> %endmacro
    69                              <2> 
    70                              <2> %endif ; PMCALL_INC
    31                              <1> %include "extern.inc"
     1                              <2> ;
     2                              <2> ; extern.inc
     3                              <2> ;
     4                              <2> ; Prototypes for external functions
     5                              <2> 
     6                              <2> %ifndef EXTERN_INC
     7                              <2> %define EXTERN_INC
     8                              <2> 
     9                              <2> 	; rllpack.c
    10                              <2> 	extern rllpack, rllunpack
    11                              <2> 
    12                              <2> 	; hello.c
    13                              <2> 	extern hello
    14                              <2> 
    15                              <2> 	; elflink/load_env32.c
    16                              <2> 	extern load_env32, pm_env32_run
    17                              <2> 
    18                              <2> 	extern mp1, mp2, mp3, mp4, mp5
    19                              <2> 
    20                              <2> 	extern hexdump
    21                              <2> 
    22                              <2> 	extern mem_init
    23                              <2> 
    24                              <2> 	; fs.c
    25                              <2> 	extern pm_fs_init
    26                              <2> 	extern SectorSize, SectorShift
    27                              <2> 
    28                              <2> 	; chdir.c
    29                              <2> 	extern pm_realpath
    30                              <2> 
    31                              <2>         ; readdir.c
    32                              <2>         extern opendir, readdir, closedir
    33                              <2> 
    34                              <2> 	; idle.c
    35                              <2> 	extern __idle
    36                              <2> 
    37                              <2> %ifdef DEBUG
    38                              <2> 	; debug.c
    39                              <2> 	extern pm_debug_msg
    40                              <2> 
    41                              <2>   %macro dprint 1+
    42                              <2> 	push ax
    43                              <2> 	call %%fwd
    44                              <2> 	db %1
    45                              <2> 	db 0
    46                              <2> %%fwd:	pop ax
    47                              <2> 	pm_call pm_debug_msg
    48                              <2> 	pop ax
    49                              <2>   %endmacro
    50                              <2> %else
    51                              <2>   %macro dprint 1+
    52                              <2>   %endmacro
    53                              <2> %endif
    54                              <2> 
    55                              <2> %if IS_PXELINUX
    56                              <2> 	; pxe.c
    57                              <2> 	extern unload_pxe, reset_pxe
    58                              <2> %endif
    59                              <2> 
    60                              <2> 	; plaincon.c
    61                              <2> 	extern pm_writechr
    62                              <2> 
    63                              <2> 	; cleanup.c
    64                              <2> 	extern cleanup_hardware
    65                              <2> 
    66                              <2> 	; writestr.c
    67                              <2> 	extern pm_writestr, crlf
    68                              <2> 
    69                              <2> 	; writehex.c
    70                              <2> 	extern pm_writehex2, pm_writehex4, pm_writehex8
    71                              <2> 
    72                              <2> 	; graphics.c
    73                              <2> 	extern syslinux_force_text_mode, vgashowcursor, vgahidecursor, pm_using_vga
    74                              <2> 
    75                              <2> 	; conio.c
    76                              <2> 	extern pm_pollchar, pm_write_serial, pm_serialcfg
    77                              <2> 
    78                              <2> 	; font.c
    79                              <2> 	extern pm_getchar, pm_adjust_screen, pm_userfont
    80                              <2> 
    81                              <2> %endif ; EXTERN_INC
    32                              <1> %include "kernel.inc"
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 1994-2008 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;
     5                              <2> ;;   This program is free software; you can redistribute it and/or modify
     6                              <2> ;;   it under the terms of the GNU General Public License as published by
     7                              <2> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     8                              <2> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
     9                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    10                              <2> ;;
    11                              <2> ;; -----------------------------------------------------------------------
    12                              <2> 
    13                              <2> ;;
    14                              <2> ;; kernel.inc
    15                              <2> ;;
    16                              <2> ;; Header file for the kernel interface definitions
    17                              <2> ;;
    18                              <2> 
    19                              <2> %ifndef _KERNEL_INC
    20                              <2> %define _KERNEL_INC
    21                              <2> 
    22                              <2> ;;
    23                              <2> ;; Structure of the real_mode_seg
    24                              <2> ;;
    25                              <2> 
    26                              <2> 		struc real_mode_seg_t
    27 00000000 <res 00000020>      <2> 		resb 20h-($-$$)		; org 20h
    28 00000020 <res 00000002>      <2> kern_cmd_magic	resw 1			; 0020 Magic # for command line
    29 00000022 <res 00000002>      <2> kern_cmd_offset resw 1			; 0022 Offset for kernel command line
    30 00000024 <res 000001CD>      <2> 		resb 497-($-$$)		; org 497d
    31 000001F1 <res 00000001>      <2> bs_setupsecs	resb 1			; 01F1 Sectors for setup code (0 -> 4)
    32 000001F2 <res 00000002>      <2> bs_rootflags	resw 1			; 01F2 Root readonly flag
    33 000001F4 <res 00000002>      <2> bs_syssize	resw 1			; 01F4
    34 000001F6 <res 00000002>      <2> bs_swapdev	resw 1			; 01F6 Swap device (obsolete)
    35 000001F8 <res 00000002>      <2> bs_ramsize	resw 1			; 01F8 Ramdisk flags, formerly ramdisk size
    36 000001FA <res 00000002>      <2> bs_vidmode	resw 1			; 01FA Video mode
    37 000001FC <res 00000002>      <2> bs_rootdev	resw 1			; 01FC Root device
    38 000001FE <res 00000002>      <2> bs_bootsign	resw 1			; 01FE Boot sector signature (0AA55h)
    39 00000200 <res 00000001>      <2> su_jump		resb 1			; 0200 0EBh
    40 00000201 <res 00000001>      <2> su_jump2	resb 1			; 0201 Size of following header
    41 00000202 <res 00000004>      <2> su_header	resd 1			; 0202 New setup code: header
    42 00000206 <res 00000002>      <2> su_version	resw 1			; 0206 See linux/arch/i386/boot/setup.S
    43 00000208 <res 00000002>      <2> su_switch	resw 1			; 0208
    44 0000020A <res 00000002>      <2> su_setupseg	resw 1			; 020A
    45 0000020C <res 00000002>      <2> su_startsys	resw 1			; 020C
    46 0000020E <res 00000002>      <2> su_kver		resw 1			; 020E Kernel version pointer
    47 00000210 <res 00000001>      <2> su_loader	resb 1			; 0210 Loader ID
    48 00000211 <res 00000001>      <2> su_loadflags	resb 1			; 0211 Load high flag
    49 00000212 <res 00000002>      <2> su_movesize	resw 1			; 0212
    50 00000214 <res 00000004>      <2> su_code32start	resd 1			; 0214 Start of code loaded high
    51 00000218 <res 00000004>      <2> su_ramdiskat	resd 1			; 0218 Start of initial ramdisk
    52 0000021C <res 00000004>      <2> su_ramdisklen	resd 1			; 021C Length of initial ramdisk
    53 00000220 <res 00000002>      <2> su_bsklugeoffs	resw 1			; 0220
    54 00000222 <res 00000002>      <2> su_bsklugeseg	resw 1			; 0222
    55 00000224 <res 00000002>      <2> su_heapend	resw 1			; 0224
    56 00000226 <res 00000002>      <2> su_pad1		resw 1			; 0226
    57 00000228 <res 00000004>      <2> su_cmd_line_ptr	resd 1			; 0228
    58 0000022C <res 00000004>      <2> su_ramdisk_max	resd 1			; 022C
    59 00000230 <res 0000F5C4>      <2> 		resb (0f800h-12)-($-$$)
    60                              <2> linux_stack	equ $			; F7F4
    61 0000F7F4 <res 0000000C>      <2> linux_fdctab	resb 12
    62                              <2> cmd_line_here	equ $			; F800 Should be out of the way
    63                              <2> 		endstruc
    64                              <2> 
    65                              <2> ;
    66                              <2> ; Old kernel command line signature
    67                              <2> ;
    68                              <2> CMD_MAGIC	equ 0A33Fh		; Command line magic
    69                              <2> 
    70                              <2> ;
    71                              <2> ; If we're loading the command line old-style, we need a smaller
    72                              <2> ; heap.
    73                              <2> ;
    74                              <2> old_cmd_line_here equ 9800h
    75                              <2> old_max_cmd_len   equ 2047
    76                              <2> old_linux_fdctab  equ old_cmd_line_here-12
    77                              <2> old_linux_stack   equ old_linux_fdctab
    78                              <2> 
    79                              <2> ;
    80                              <2> ; Magic number of su_header field
    81                              <2> ;
    82                              <2> HEADER_ID       equ 'HdrS'		; HdrS (in littleendian hex)
    83                              <2> 
    84                              <2> ;
    85                              <2> ; Flags for the su_loadflags field
    86                              <2> ;
    87                              <2> LOAD_HIGH	equ 01h			; Large kernel, load high
    88                              <2> QUIET_FLAG	equ 20h			; Quiet the kernel
    89                              <2> KEEP_SEGMENTS	equ 40h			; Don't reload segments
    90                              <2> CAN_USE_HEAP    equ 80h                 ; Boot loader reports heap size
    91                              <2> 
    92                              <2> ;
    93                              <2> ; ID codes for various modules
    94                              <2> ;
    95                              <2> syslinux_id	equ 031h		; 3 = SYSLINUX family; 1 = SYSLINUX
    96                              <2> pxelinux_id	equ 032h		; 3 = SYSLINUX family; 2 = PXELINUX
    97                              <2> isolinux_id	equ 033h		; 3 = SYSLINUX family; 3 = ISOLINUX
    98                              <2> extlinux_id	equ 034h		; 3 = SYSLINUX family; 4 = EXTLINUX
    99                              <2> 
   100                              <2> ;
   101                              <2> ; Types of vkernels
   102                              <2> ;
   103                              <2> VK_LOCALBOOT	equ -1			; localboot (no actual kernel loaded)
   104                              <2> VK_KERNEL	equ 0			; Choose by filename
   105                              <2> VK_LINUX	equ 1			; Linux kernel image
   106                              <2> VK_BOOT		equ 2			; Boot sector
   107                              <2> VK_BSS		equ 3			; BSS boot sector
   108                              <2> VK_PXE		equ 4			; PXE NBP
   109                              <2> VK_FDIMAGE	equ 5			; Floppy disk image
   110                              <2> VK_COMBOOT	equ 6			; COMBOOT image
   111                              <2> VK_COM32	equ 7			; COM32 image
   112                              <2> VK_CONFIG	equ 8			; Configuration file
   113                              <2> VK_TYPES	equ 9			; Number of VK types
   114                              <2> 
   115                              <2> %endif ; _KERNEL_INC
    33                              <1> %include "bios.inc"
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 1994-2008 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;
     5                              <2> ;;   This program is free software; you can redistribute it and/or modify
     6                              <2> ;;   it under the terms of the GNU General Public License as published by
     7                              <2> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     8                              <2> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
     9                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    10                              <2> ;;
    11                              <2> ;; -----------------------------------------------------------------------
    12                              <2> 
    13                              <2> ;;
    14                              <2> ;; bios.inc
    15                              <2> ;;
    16                              <2> ;; Header file for the BIOS data structures etc.
    17                              <2> ;;
    18                              <2> 
    19                              <2> %ifndef _BIOS_INC
    20                              <2> %define _BIOS_INC
    21                              <2> 
    22                              <2> 		; Interrupt vectors
    23                              <2> 		absolute 4*1Ch
    24 00000070 <res 00000004>      <2> BIOS_timer_hook	resd 1
    25                              <2> 
    26                              <2> 		absolute 4*1Eh
    27                              <2> fdctab		equ $
    28 00000078 <res 00000002>      <2> fdctab1		resw 1
    29 0000007A <res 00000002>      <2> fdctab2		resw 1
    30                              <2> 
    31                              <2> 		absolute 0400h
    32 00000400 <res 00000008>      <2> serial_base	resw 4			; Base addresses for 4 serial ports
    33                              <2> 		absolute 0413h
    34 00000413 <res 00000002>      <2> BIOS_fbm	resw 1			; Free Base Memory (kilobytes)
    35                              <2> 		absolute 0462h
    36 00000462 <res 00000001>      <2> BIOS_page	resb 1			; Current video page
    37                              <2> 		absolute 046Ch
    38 0000046C <res 00000002>      <2> BIOS_timer	resw 1			; Timer ticks
    39                              <2> 		absolute 0472h
    40 00000472 <res 00000002>      <2> BIOS_magic	resw 1			; BIOS reset magic
    41                              <2>                 absolute 0484h
    42 00000484 <res 00000001>      <2> BIOS_vidrows    resb 1			; Number of screen rows
    43                              <2> 
    44                              <2> %endif ; _BIOS_INC
    34                              <1> %include "tracers.inc"
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 1994-2008 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;
     5                              <2> ;;   This program is free software; you can redistribute it and/or modify
     6                              <2> ;;   it under the terms of the GNU General Public License as published by
     7                              <2> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     8                              <2> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
     9                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    10                              <2> ;;
    11                              <2> ;; -----------------------------------------------------------------------
    12                              <2> 
    13                              <2> ;;
    14                              <2> ;; tracers.inc
    15                              <2> ;;
    16                              <2> ;; Debugging tracers
    17                              <2> ;;
    18                              <2> 
    19                              <2> %ifndef _TRACERS_INC
    20                              <2> %define _TRACERS_INC
    21                              <2> 
    22                              <2> ; Note: The Makefile builds one version with DEBUG_MESSAGES automatically.
    23                              <2> ; %define DEBUG_TRACERS 1		; Uncomment to get debugging tracers
    24                              <2> ; %define DEBUG_MESSAGES		; Uncomment to get debugging messages
    25                              <2> 
    26                              <2> %ifdef DEBUG_TRACERS
    27                              <2> 
    28                              <2> %macro TRACER	1
    29                              <2> 	call debug_tracer
    30                              <2> 	db %1
    31                              <2> %endmacro
    32                              <2> 
    33                              <2> %else	; DEBUG_TRACERS
    34                              <2> 
    35                              <2> %macro	TRACER	1
    36                              <2> %endmacro
    37                              <2> 
    38                              <2> %endif	; DEBUG_TRACERS
    39                              <2> 
    40                              <2> %endif ; _TRACERS_INC
    35                              <1> %include "stack.inc"
     1                              <2> ; -----------------------------------------------------------------------
     2                              <2> ;
     3                              <2> ;   Copyright 2005-2008 H. Peter Anvin - All Rights Reserved
     4                              <2> ;   Copyright 2009-2010 Intel Corporation; author: H. Peter Anvin
     5                              <2> ;
     6                              <2> ;   This program is free software; you can redistribute it and/or modify
     7                              <2> ;   it under the terms of the GNU General Public License as published by
     8                              <2> ;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <2> ;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <2> ;   (at your option) any later version; incorporated herein by reference.
    11                              <2> ;
    12                              <2> ; -----------------------------------------------------------------------
    13                              <2> 
    14                              <2> ;
    15                              <2> ; stack.inc
    16                              <2> ;
    17                              <2> ; How to reset the stack pointer
    18                              <2> ;
    19                              <2> 
    20                              <2> %ifndef _STACK_INC
    21                              <2> %define _STACK_INC
    22                              <2> 
    23                              <2> ;
    24                              <2> ; This macro resets the stack pointer (including SS), and sets
    25                              <2> ; DS == ES == 0, interrupts on, DF = 0.
    26                              <2> ;
    27                              <2> ; It takes a 16-bit register that can be safely clobbered as parameter.
    28                              <2> ;
    29                              <2> %macro RESET_STACK_AND_SEGS 1
    30                              <2> 		xor %1,%1
    31                              <2> 		mov ds,%1
    32                              <2> 		mov es,%1
    33                              <2> 		lss esp,[BaseStack]
    34                              <2> 		mov dword [PMESP],__stack_end	; Reset PM stack
    35                              <2> 		sti
    36                              <2> 		cld
    37                              <2> %endmacro
    38                              <2> 
    39                              <2> 		section .data16
    40                              <2> 		alignz 4
    41                              <2> 		global BaseStack:data hidden
    42 00000000 D46F0000            <2> BaseStack	dd StackHome		; ESP of the "home" stack pointer
    43 00000004 0000                <2> 		dw 0			; SS of the "home" stack pointer
    44                              <2> 
    45                              <2> 		section .text16
    46                              <2> 
    47                              <2> %endif ; _STACK_INC
    36                              <1> %include "io.inc"
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 1994-2009 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
     5                              <2> ;;
     6                              <2> ;;   This program is free software; you can redistribute it and/or modify
     7                              <2> ;;   it under the terms of the GNU General Public License as published by
     8                              <2> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <2> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    11                              <2> ;;
    12                              <2> ;; -----------------------------------------------------------------------
    13                              <2> 
    14                              <2> ;;
    15                              <2> ;; io.inc
    16                              <2> ;;
    17                              <2> ;; I/O related macros
    18                              <2> ;;
    19                              <2> 
    20                              <2> %ifndef _IO_INC
    21                              <2> %define _IO_INC
    22                              <2> 
    23                              <2> %define IO_DELAY_PORT	80h		; Invalid port (we hope!)
    24                              <2> 
    25                              <2> %macro io_delay 0.nolist
    26                              <2> 		out IO_DELAY_PORT,al
    27                              <2> 		out IO_DELAY_PORT,al
    28                              <2> %endmacro
    29                              <2> 
    30                              <2> %macro slow_out 2.nolist
    31                              <2> 		out %1,%2
    32                              <2> 		io_delay
    33                              <2> %endmacro
    34                              <2> 
    35                              <2> %endif ; _IO_INC
    37                              <1> 
    38                              <1> %endif ; _HEAD_INC
    23                                  %include "pxe.inc"
     1                              <1> ;; -----------------------------------------------------------------------
     2                              <1> ;;
     3                              <1> ;;   Copyright 1999-2008 H. Peter Anvin - All Rights Reserved
     4                              <1> ;;
     5                              <1> ;;   This program is free software; you can redistribute it and/or modify
     6                              <1> ;;   it under the terms of the GNU General Public License as published by
     7                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     8                              <1> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
     9                              <1> ;;   (at your option) any later version; incorporated herein by reference.
    10                              <1> ;;
    11                              <1> ;; -----------------------------------------------------------------------
    12                              <1> 
    13                              <1> ;;
    14                              <1> ;; pxe.inc
    15                              <1> ;;
    16                              <1> ;; PXE opcodes
    17                              <1> ;;
    18                              <1> 
    19                              <1> %ifndef _PXE_INC
    20                              <1> %define _PXE_INC 1
    21                              <1> 
    22                              <1> %define PXENV_TFTP_OPEN					 0x0020
    23                              <1> %define PXENV_TFTP_CLOSE				 0x0021
    24                              <1> %define PXENV_TFTP_READ					 0x0022
    25                              <1> %define PXENV_TFTP_READ_FILE				 0x0023
    26                              <1> %define PXENV_TFTP_READ_FILE_PMODE			 0x0024
    27                              <1> %define PXENV_TFTP_GET_FSIZE				 0x0025
    28                              <1> 
    29                              <1> %define PXENV_UDP_OPEN					 0x0030
    30                              <1> %define PXENV_UDP_CLOSE					 0x0031
    31                              <1> %define PXENV_UDP_READ					 0x0032
    32                              <1> %define PXENV_UDP_WRITE					 0x0033
    33                              <1> 
    34                              <1> %define PXENV_START_UNDI				 0x0000
    35                              <1> %define PXENV_UNDI_STARTUP				 0x0001
    36                              <1> %define PXENV_UNDI_CLEANUP				 0x0002
    37                              <1> %define PXENV_UNDI_INITIALIZE				 0x0003
    38                              <1> %define PXENV_UNDI_RESET_NIC				 0x0004
    39                              <1> %define PXENV_UNDI_SHUTDOWN				 0x0005
    40                              <1> %define PXENV_UNDI_OPEN					 0x0006
    41                              <1> %define PXENV_UNDI_CLOSE				 0x0007
    42                              <1> %define PXENV_UNDI_TRANSMIT				 0x0008
    43                              <1> %define PXENV_UNDI_SET_MCAST_ADDR			 0x0009
    44                              <1> %define PXENV_UNDI_SET_STATION_ADDR			 0x000A
    45                              <1> %define PXENV_UNDI_SET_PACKET_FILTER			 0x000B
    46                              <1> %define PXENV_UNDI_GET_INFORMATION			 0x000C
    47                              <1> %define PXENV_UNDI_GET_STATISTICS			 0x000D
    48                              <1> %define PXENV_UNDI_CLEAR_STATISTICS			 0x000E
    49                              <1> %define PXENV_UNDI_INITIATE_DIAGS			 0x000F
    50                              <1> %define PXENV_UNDI_FORCE_INTERRUPT			 0x0010
    51                              <1> %define PXENV_UNDI_GET_MCAST_ADDR			 0x0011
    52                              <1> %define PXENV_UNDI_GET_NIC_TYPE				 0x0012
    53                              <1> %define PXENV_UNDI_GET_IFACE_INFO			 0x0013
    54                              <1> %define PXENV_UNDI_ISR					 0x0014
    55                              <1> %define PXENV_STOP_UNDI					 0x0015	; Overlap...?
    56                              <1> %define PXENV_UNDI_GET_STATE				 0x0015	; Overlap...?
    57                              <1> 
    58                              <1> %define PXENV_UNLOAD_STACK				 0x0070
    59                              <1> %define PXENV_GET_CACHED_INFO				 0x0071
    60                              <1> %define PXENV_RESTART_DHCP				 0x0072
    61                              <1> %define PXENV_RESTART_TFTP				 0x0073
    62                              <1> %define PXENV_MODE_SWITCH				 0x0074
    63                              <1> %define PXENV_START_BASE				 0x0075
    64                              <1> %define PXENV_STOP_BASE					 0x0076
    65                              <1> 
    66                              <1> ; gPXE extensions...
    67                              <1> %define PXENV_FILE_OPEN					 0x00e0
    68                              <1> %define PXENV_FILE_CLOSE				 0x00e1
    69                              <1> %define PXENV_FILE_SELECT				 0x00e2
    70                              <1> %define PXENV_FILE_READ					 0x00e3
    71                              <1> %define PXENV_GET_FILE_SIZE				 0x00e4
    72                              <1> %define PXENV_FILE_EXEC					 0x00e5
    73                              <1> %define PXENV_FILE_API_CHECK				 0x00e6
    74                              <1> %define PXENV_FILE_EXIT_HOOK				 0x00e7
    75                              <1> 
    76                              <1> ; Exit codes
    77                              <1> %define PXENV_EXIT_SUCCESS				 0x0000
    78                              <1> %define PXENV_EXIT_FAILURE				 0x0001
    79                              <1> 
    80                              <1> ; Status codes
    81                              <1> %define PXENV_STATUS_SUCCESS				 0x00
    82                              <1> %define PXENV_STATUS_FAILURE				 0x01
    83                              <1> %define PXENV_STATUS_BAD_FUNC				 0x02
    84                              <1> %define PXENV_STATUS_UNSUPPORTED			 0x03
    85                              <1> %define PXENV_STATUS_KEEP_UNDI				 0x04
    86                              <1> %define PXENV_STATUS_KEEP_ALL				 0x05
    87                              <1> %define PXENV_STATUS_OUT_OF_RESOURCES			 0x06
    88                              <1> %define PXENV_STATUS_ARP_TIMEOUT			 0x11
    89                              <1> %define PXENV_STATUS_UDP_CLOSED				 0x18
    90                              <1> %define PXENV_STATUS_UDP_OPEN				 0x19
    91                              <1> %define PXENV_STATUS_TFTP_CLOSED			 0x1a
    92                              <1> %define PXENV_STATUS_TFTP_OPEN				 0x1b
    93                              <1> %define PXENV_STATUS_MCOPY_PROBLEM			 0x20
    94                              <1> %define PXENV_STATUS_BIS_INTEGRITY_FAILURE		 0x21
    95                              <1> %define PXENV_STATUS_BIS_VALIDATE_FAILURE		 0x22
    96                              <1> %define PXENV_STATUS_BIS_INIT_FAILURE			 0x23
    97                              <1> %define PXENV_STATUS_BIS_SHUTDOWN_FAILURE		 0x24
    98                              <1> %define PXENV_STATUS_BIS_GBOA_FAILURE			 0x25
    99                              <1> %define PXENV_STATUS_BIS_FREE_FAILURE			 0x26
   100                              <1> %define PXENV_STATUS_BIS_GSI_FAILURE			 0x27
   101                              <1> %define PXENV_STATUS_BIS_BAD_CKSUM			 0x28
   102                              <1> %define PXENV_STATUS_TFTP_CANNOT_ARP_ADDRESS		 0x30
   103                              <1> %define PXENV_STATUS_TFTP_OPEN_TIMEOUT			 0x32
   104                              <1> 
   105                              <1> %define PXENV_STATUS_TFTP_UNKNOWN_OPCODE		 0x33
   106                              <1> %define PXENV_STATUS_TFTP_READ_TIMEOUT			 0x35
   107                              <1> %define PXENV_STATUS_TFTP_ERROR_OPCODE			 0x36
   108                              <1> %define PXENV_STATUS_TFTP_CANNOT_OPEN_CONNECTION	 0x38
   109                              <1> %define PXENV_STATUS_TFTP_CANNOT_READ_FROM_CONNECTION	 0x39
   110                              <1> %define PXENV_STATUS_TFTP_TOO_MANY_PACKAGES		 0x3a
   111                              <1> %define PXENV_STATUS_TFTP_FILE_NOT_FOUND		 0x3b
   112                              <1> %define PXENV_STATUS_TFTP_ACCESS_VIOLATION		 0x3c
   113                              <1> %define PXENV_STATUS_TFTP_NO_MCAST_ADDRESS		 0x3d
   114                              <1> %define PXENV_STATUS_TFTP_NO_FILESIZE			 0x3e
   115                              <1> %define PXENV_STATUS_TFTP_INVALID_PACKET_SIZE		 0x3f
   116                              <1> %define PXENV_STATUS_DHCP_TIMEOUT			 0x51
   117                              <1> %define PXENV_STATUS_DHCP_NO_IP_ADDRESS			 0x52
   118                              <1> %define PXENV_STATUS_DHCP_NO_BOOTFILE_NAME		 0x53
   119                              <1> %define PXENV_STATUS_DHCP_BAD_IP_ADDRESS		 0x54
   120                              <1> %define PXENV_STATUS_UNDI_INVALID_FUNCTION		 0x60
   121                              <1> %define PXENV_STATUS_UNDI_MEDIATEST_FAILED		 0x61
   122                              <1> %define PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	 0x62
   123                              <1> %define PXENV_STATUS_UNDI_CANNOT_INITIALIZE_NIC		 0x63
   124                              <1> %define PXENV_STATUS_UNDI_CANNOT_INITIALIZE_PHY		 0x64
   125                              <1> %define PXENV_STATUS_UNDI_CANNOT_READ_CONFIG_DATA	 0x65
   126                              <1> %define PXENV_STATUS_UNDI_CANNOT_READ_INIT_DATA		 0x66
   127                              <1> %define PXENV_STATUS_UNDI_BAD_MAC_ADDRESS		 0x67
   128                              <1> %define PXENV_STATUS_UNDI_BAD_EEPROM_CHECKSUM		 0x68
   129                              <1> %define PXENV_STATUS_UNDI_ERROR_SETTING_ISR		 0x69
   130                              <1> %define PXENV_STATUS_UNDI_INVALID_STATE			 0x6a
   131                              <1> %define PXENV_STATUS_UNDI_TRANSMIT_ERROR		 0x6b
   132                              <1> %define PXENV_STATUS_UNDI_INVALID_PARAMETER		 0x6c
   133                              <1> %define PXENV_STATUS_BSTRAP_PROMPT_MENU			 0x74
   134                              <1> %define PXENV_STATUS_BSTRAP_MCAST_ADDR			 0x76
   135                              <1> %define PXENV_STATUS_BSTRAP_MISSING_LIST		 0x77
   136                              <1> %define PXENV_STATUS_BSTRAP_NO_RESPONSE			 0x78
   137                              <1> %define PXENV_STATUS_BSTRAP_FILE_TOO_BIG		 0x79
   138                              <1> %define PXENV_STATUS_BINL_CANCELED_BY_KEYSTROKE		 0xa0
   139                              <1> %define PXENV_STATUS_BINL_NO_PXE_SERVER			 0xa1
   140                              <1> %define PXENV_STATUS_NOT_AVAILABLE_IN_PMODE		 0xa2
   141                              <1> %define PXENV_STATUS_NOT_AVAILABLE_IN_RMODE		 0xa3
   142                              <1> %define PXENV_STATUS_BUSD_DEVICE_NOT_SUPPORTED		 0xb0
   143                              <1> %define PXENV_STATUS_LOADER_NO_FREE_BASE_MEMORY		 0xc0
   144                              <1> %define PXENV_STATUS_LOADER_NO_BC_ROMID			 0xc1
   145                              <1> %define PXENV_STATUS_LOADER_BAD_BC_ROMID		 0xc2
   146                              <1> %define PXENV_STATUS_LOADER_BAD_BC_RUNTIME_IMAGE	 0xc3
   147                              <1> %define PXENV_STATUS_LOADER_NO_UNDI_ROMID		 0xc4
   148                              <1> %define PXENV_STATUS_LOADER_BAD_UNDI_ROMID		 0xc5
   149                              <1> %define PXENV_STATUS_LOADER_BAD_UNDI_DRIVER_IMAGE	 0xc6
   150                              <1> %define PXENV_STATUS_LOADER_NO_PXE_STRUCT		 0xc8
   151                              <1> %define PXENV_STATUS_LOADER_NO_PXENV_STRUCT		 0xc9
   152                              <1> %define PXENV_STATUS_LOADER_UNDI_START			 0xca
   153                              <1> %define PXENV_STATUS_LOADER_BC_START			 0xcb
   154                              <1> 
   155                              <1> ; UNDI ISR codes
   156                              <1> %define PXENV_UNDI_ISR_IN_START				 1
   157                              <1> %define PXENV_UNDI_ISR_IN_PROCESS			 2
   158                              <1> %define PXENV_UNDI_ISR_IN_GET_NEXT			 3
   159                              <1> 
   160                              <1> %define PXENV_UNDI_ISR_OUT_OURS			         0
   161                              <1> %define PXENV_UNDI_ISR_OUT_NOT_OURS			 1
   162                              <1> 
   163                              <1> %endif ; _PXE_INC
    24                                  
    25                                  ; gPXE extensions support
    26                                  %define GPXE	1
    27                                  
    28                                  ;
    29                                  ; Some semi-configurable constants... change on your own risk.
    30                                  ;
    31                                  my_id		equ pxelinux_id
    32                                  NULLFILE	equ 0			; Zero byte == null file name
    33                                  NULLOFFSET	equ 0			; Position in which to look
    34                                  REBOOT_TIME	equ 5*60		; If failure, time until full reset
    35                                  %assign HIGHMEM_SLOP 128*1024		; Avoid this much memory near the top
    36                                  TFTP_BLOCKSIZE_LG2 equ 9		; log2(bytes/block)
    37                                  TFTP_BLOCKSIZE	equ (1 << TFTP_BLOCKSIZE_LG2)
    38                                  
    39                                  SECTOR_SHIFT	equ TFTP_BLOCKSIZE_LG2
    40                                  SECTOR_SIZE	equ TFTP_BLOCKSIZE
    41                                  
    42                                  ; ---------------------------------------------------------------------------
    43                                  ;   BEGIN CODE
    44                                  ; ---------------------------------------------------------------------------
    45                                  
    46                                  ;
    47                                  ; Memory below this point is reserved for the BIOS and the MBR
    48                                  ;
    49                                  		section .earlybss
    50                                                  global trackbuf
    51                                  trackbufsize	equ 8192
    52 00000000 <res 00002000>          trackbuf	resb trackbufsize	; Track buffer goes here
    53                                  		; ends at 2800h
    54                                  
    55                                  		; These fields save information from before the time
    56                                  		; .bss is zeroed... must be in .earlybss
    57                                  		global InitStack
    58 00002000 <res 00000004>          InitStack	resd 1
    59                                  
    60                                  		section .bss16
    61                                  		alignb FILENAME_MAX
    62 00000000 <res 00000004>          PXEStack	resd 1			; Saved stack during PXE call
    63                                  
    64                                  		alignb 4
    65                                                  global DHCPMagic, RebootTime, BIOSName
    66 00000004 <res 00000004>          RebootTime	resd 1			; Reboot timeout, if set by option
    67 00000008 <res 00000002>          LocalBootType	resw 1			; Local boot return code
    68 0000000A <res 00000001>          DHCPMagic	resb 1			; PXELINUX magic flags
    69 0000000B <res 00000002>          BIOSName	resw 1			; Dummy variable - always 0
    70                                  
    71                                  		section .text16
    72                                  		global StackBuf
    73                                  StackBuf	equ STACK_TOP-44	; Base of stack if we use our own
    74                                  StackHome	equ StackBuf
    75                                  
    76                                  		; PXE loads the whole file, but assume it can't be more
    77                                  		; than (384-31)K in size.
    78                                  MaxLMA		equ 384*1024
    79                                  
    80                                  ;
    81                                  ; Primary entry point.
    82                                  ;
    83                                  bootsec		equ $
    84                                  _start:
    85 00000000 EA[2400]0000            		jmp 0:_start1		; Canonicalize the address and skip
    86                                  					; the patch header
    87                                  
    88                                  ;
    89                                  ; Patch area for adding hardwired DHCP options
    90                                  ;
    91 00000005 90<rept>                		align 4
    92                                  
    93 00000008 ACC88329                hcdhcp_magic	dd 0x2983c8ac		; Magic number
    94 0000000C 1C000000                hcdhcp_len	dd 7*4			; Size of this structure
    95 00000010 00000000                hcdhcp_flags	dd 0			; Reserved for the future
    96                                  		global bdhcp_len, adhcp_len
    97                                  		; Parameters to be parsed before the ones from PXE
    98 00000014 00000000                bdhcp_offset	dd 0			; Offset (entered by patcher)
    99 00000018 00000000                bdhcp_len	dd 0			; Length (entered by patcher)
   100                                  		; Parameters to be parsed *after* the ones from PXE
   101 0000001C 00000000                adhcp_offset	dd 0			; Offset (entered by patcher)
   102 00000020 00000000                adhcp_len	dd 0			; Length (entered by patcher)
   103                                  
   104                                  _start1:
   105 00000024 669C                    		pushfd			; Paranoia... in case of return to PXE
   106 00000026 6660                    		pushad			; ... save as much state as possible
   107 00000028 1E                      		push ds
   108 00000029 06                      		push es
   109 0000002A 0FA0                    		push fs
   110 0000002C 0FA8                    		push gs
   111                                  
   112 0000002E FC                      		cld			; Copy upwards
   113 0000002F 31C0                    		xor ax,ax
   114 00000031 8ED8                    		mov ds,ax
   115 00000033 8EC0                    		mov es,ax
   116                                  
   117                                  %if 0 ; debugging code only... not intended for production use
   118                                  		; Clobber the stack segment, to test for specific pathologies
   119                                  		mov di,STACK_BASE
   120                                  		mov cx,STACK_LEN >> 1
   121                                  		mov ax,0xf4f4
   122                                  		rep stosw
   123                                  
   124                                  		; Clobber the tail of the 64K segment, too
   125                                  		extern __bss1_end
   126                                  		mov di,__bss1_end
   127                                  		sub cx,di		; CX = 0 previously
   128                                  		shr cx,1
   129                                  		rep stosw
   130                                  %endif
   131                                  
   132                                  		; That is all pushed onto the PXE stack.  Save the pointer
   133                                  		; to it and switch to an internal stack.
   134 00000035 8926[0020]              		mov [InitStack],sp
   135 00000039 8C16[0220]              		mov [InitStack+2],ss
   136                                  
   137 0000003D 660FB226[0000]          		lss esp,[BaseStack]
   138 00000043 FB                      		sti			; Stack set up and ready
   139                                  
   140                                  ;
   141                                  ; Initialize screen (if we're using one)
   142                                  ;
   143                                  %include "init.inc"
     1                              <1> ; -*- fundamental -*-
     2                              <1> ; -----------------------------------------------------------------------
     3                              <1> ;
     4                              <1> ;   Copyright 2004-2008 H. Peter Anvin - All Rights Reserved
     5                              <1> ;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
     6                              <1> ;
     7                              <1> ;   This program is free software; you can redistribute it and/or modify
     8                              <1> ;   it under the terms of the GNU General Public License as published by
     9                              <1> ;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
    10                              <1> ;   Boston MA 02111-1307, USA; either version 2 of the License, or
    11                              <1> ;   (at your option) any later version; incorporated herein by reference.
    12                              <1> ;
    13                              <1> ; -----------------------------------------------------------------------
    14                              <1> 
    15                              <1> ;
    16                              <1> ; init.inc
    17                              <1> ;
    18                              <1> ; Common initialization code (inline)
    19                              <1> ;
    20                              <1> 
    21                              <1> 		section .text16
    22                              <1> common_init:
    23                              <1> 		; Initialize PM invocation framework
    24 00000044 E87C03              <1> 		call pm_init
    25                              <1> 
    26                              <1> %if IS_PXELINUX
    27                              <1> 		; Save derivative-specific data
    28                              <1> 		pm_call pm_save_data
    28 00000047 6668[48000000]      <2>  push dword %1
    28 0000004D E8F001              <2>  call _pm_call
    29                              <1> %endif
    30                              <1> 
    31                              <1> 		; Decompress PM code to its target location
    32                              <1> 		pm_call pm_decompress
    32 00000050 6668[00000000]      <2>  push dword %1
    32 00000056 E8E701              <2>  call _pm_call
    33 00000059 663D[00000000]      <1> 		cmp eax,__pm_code_len
    34 0000005F 7573                <1> 		jne kaboom
    35                              <1> 
    36                              <1> 		extern syslinux_register_bios, init
    37                              <1> 
    38                              <1> 		pm_call syslinux_register_bios
    38 00000061 6668[00000000]      <2>  push dword %1
    38 00000067 E8D601              <2>  call _pm_call
    39                              <1> 		pm_call init
    39 0000006A 6668[00000000]      <2>  push dword %1
    39 00000070 E8CD01              <2>  call _pm_call
    40                              <1> 
    41                              <1> ;
    42                              <1> ; The code to decompress the PM code and initialize other segments.
    43                              <1> ;
    44                              <1> 		extern _lzo1x_decompress_asm_fast_safe
    45                              <1> 
    46                              <1> 		section .textnr
    47                              <1> 		bits 32
    48                              <1> pm_decompress:
    49 00000000 68[10000000]        <1> 		push __pm_code_len + 16		; Space for decompressed size
    50 00000005 54                  <1> 		push esp			; Pointer to previous word
    51 00000006 68[00000000]        <1> 		push __pm_code_start		; Target address
    52 0000000B FF35[06000000]      <1> 		push dword [lzo_data_size]	; Compressed size
    53 00000011 68[00000000]        <1> 		push dword __pm_code_lma
    54 00000016 E8(00000000)        <1> 		call _lzo1x_decompress_asm_fast_safe
    55 0000001B 83C410              <1> 		add esp,16
    56 0000001E 8F4524              <1> 		pop RM_EAX			; Decompressed size
    57                              <1> 
    58                              <1> 		; Zero bss sections (but not .earlybss, since it may
    59                              <1> 		; contain already-live data.)
    60 00000021 31C0                <1> 		xor eax,eax
    61 00000023 BF[00000000]        <1> 		mov edi,__bss_start
    62 00000028 B9[00000000]        <1> 		mov ecx,__bss_dwords
    63 0000002D F3AB                <1> 		rep stosd
    64 0000002F BF[00000000]        <1> 		mov edi,__bss16_start
    65 00000034 B9[00000000]        <1> 		mov ecx,__bss16_dwords
    66 00000039 F3AB                <1> 		rep stosd
    67 0000003B BF[00000000]        <1> 		mov edi,__high_clear_start	; .uibss, .lowmem
    68 00000040 B9[00000000]        <1> 		mov ecx,__high_clear_dwords
    69 00000045 F3AB                <1> 		rep stosd
    70                              <1> 
    71 00000047 C3                  <1> 		ret
    72                              <1> 
    73                              <1> 		section .data16
    74 00000006 00000000            <1> lzo_data_size	dd 0				; filled in by compressor
    75                              <1> 
    76                              <1> 		section .text16
    77                              <1> 		bits 16
   144                                  
   145                                  ;
   146                                  ; Tell the user we got this far
   147                                  ;
   148 00000073 BE[1E01]                		mov si,syslinux_banner
   149 00000076 E8A901                  		call writestr_early
   150                                  
   151 00000079 BE[9600]                		mov si,copyright_str
   152 0000007C E8A301                  		call writestr_early
   153                                  
   154                                  ;
   155                                  ; do fs initialize
   156                                  ;
   157 0000007F 66B8[00000000]          	        mov eax,ROOT_FS_OPS
   158 00000085 6631ED                  		xor ebp,ebp
   159                                                  pm_call pm_fs_init
   159 00000088 6668[00000000]      <1>  push dword %1
   159 0000008E E8AF01              <1>  call _pm_call
   160                                  
   161                                  		section .rodata
   162                                  		alignz 4
   163                                  ROOT_FS_OPS:
   164                                                  extern pxe_fs_ops
   165 00000000 [00000000]              		dd pxe_fs_ops
   166 00000004 00000000                		dd 0
   167                                  
   168                                  
   169                                  		section .text16
   170                                  ;
   171                                  ; Initialize the idle mechanism
   172                                  ;
   173                                  		extern reset_idle
   174                                  		pm_call reset_idle
   174 00000091 6668[00000000]      <1>  push dword %1
   174 00000097 E8A601              <1>  call _pm_call
   175                                  
   176                                  ;
   177                                  ; Now we're all set to start with our *real* business.
   178                                  ;
   179                                  ; In previous versions I avoided using 32-bit registers because of a
   180                                  ; rumour some BIOSes clobbered the upper half of 32-bit registers at
   181                                  ; random.  I figure, though, that if there are any of those still left
   182                                  ; they probably won't be trying to install Linux on them...
   183                                  ;
   184                                  ; The code is still ripe with 16-bitisms, though.  Not worth the hassle
   185                                  ; to take'm out.  In fact, we may want to put them back if we're going
   186                                  ; to boot ELKS at some point.
   187                                  ;
   188                                  
   189                                  ;
   190                                  ; Linux kernel loading code is common.  However, we need to define
   191                                  ; a couple of helper macros...
   192                                  ;
   193                                  
   194                                  ; Unload PXE stack
   195                                  %define HAVE_UNLOAD_PREP
   196                                  %macro	UNLOAD_PREP 0
   197                                  		pm_call unload_pxe
   198                                  %endmacro
   199                                  
   200                                  ;
   201                                  ; Jump to 32-bit ELF space
   202                                  ;
   203                                  		pm_call load_env32
   203 0000009A 6668[00000000]      <1>  push dword %1
   203 000000A0 E89D01              <1>  call _pm_call
   204 000000A3 EB2F                    		jmp kaboom		; load_env32() shouldn't return. If it does, then kaboom!
   205                                  
   206                                  print_hello:
   207                                  enter_command:
   208                                  auto_boot:
   209                                  		pm_call hello
   209 000000A5 6668[00000000]      <1>  push dword %1
   209 000000AB E89201              <1>  call _pm_call
   210                                  
   211                                  ;
   212                                  ; Save hardwired DHCP options.  This is done before the C environment
   213                                  ; is initialized, so it has to be done in assembly.
   214                                  ;
   215                                  %define MAX_DHCP_OPTS	4096
   216                                  		bits 32
   217                                  
   218                                  		section .savedata
   219                                  		global bdhcp_data, adhcp_data
   220 00000000 <res 00001000>          bdhcp_data:	resb MAX_DHCP_OPTS
   221 00001000 <res 00001000>          adhcp_data:	resb MAX_DHCP_OPTS
   222                                  
   223                                  		section .textnr
   224                                  pm_save_data:
   225 00000048 B800100000              		mov eax,MAX_DHCP_OPTS
   226 0000004D 0FB70D[18000000]        		movzx ecx,word [bdhcp_len]
   227 00000054 39C1                    		cmp ecx,eax
   228 00000056 7608                    		jna .oksize
   229 00000058 89C1                    		mov ecx,eax
   230 0000005A 66A3[18000000]          		mov [bdhcp_len],ax
   231                                  .oksize:
   232 00000060 8B35[14000000]          		mov esi,[bdhcp_offset]
   233 00000066 81C6[00000000]          		add esi,_start
   234 0000006C BF[00000000]            		mov edi,bdhcp_data
   235 00000071 83C103                  		add ecx,3
   236 00000074 C1E902                  		shr ecx,2
   237 00000077 F3A5                    		rep movsd
   238                                  
   239                                  adhcp_copy:
   240 00000079 0FB70D[20000000]        		movzx ecx,word [adhcp_len]
   241 00000080 39C1                    		cmp ecx,eax
   242 00000082 7608                    		jna .oksize
   243 00000084 89C1                    		mov ecx,eax
   244 00000086 66A3[20000000]          		mov [adhcp_len],ax
   245                                  .oksize:
   246 0000008C 8B35[1C000000]          		mov esi,[adhcp_offset]
   247 00000092 81C6[00000000]          		add esi,_start
   248 00000098 BF[00100000]            		mov edi,adhcp_data
   249 0000009D 83C103                  		add ecx,3
   250 000000A0 C1E902                  		shr ecx,2
   251 000000A3 F3A5                    		rep movsd
   252 000000A5 C3                      		ret
   253                                  
   254                                  		bits 16
   255                                  
   256                                  ; As core/ui.inc used to be included here in core/pxelinux.asm, and it's no
   257                                  ; longer used, its global variables that were previously used by
   258                                  ; core/pxelinux.asm are now declared here.
   259                                  		section .bss16
   260 0000000D <res 00000003>          		alignb 4
   261 00000010 <res 00000004>          Kernel_EAX	resd 1
   262 00000014 <res 00000002>          Kernel_SI	resw 1
   263                                  
   264                                  		section .bss16
   265 00000016 <res 00000002>          		alignb 4
   266 00000018 <res 00000004>          ThisKbdTo	resd 1			; Temporary holder for KbdTimeout
   267 0000001C <res 00000004>          ThisTotalTo	resd 1			; Temporary holder for TotalTimeout
   268 00000020 <res 00000002>          KernelExtPtr	resw 1			; During search, final null pointer
   269 00000022 <res 00000001>          FuncFlag	resb 1			; Escape sequences received from keyboard
   270 00000023 <res 00000001>          KernelType	resb 1			; Kernel type, from vkernel, if known
   271                                  		global KernelName
   272 00000024 <res 00000100>          KernelName	resb FILENAME_MAX	; Mangled name for kernel
   273                                  
   274                                  		section .text16
   275                                  ;
   276                                  ; COM32 vestigial data structure
   277                                  ;
   278                                  %include "com32.inc"
     1                              <1> ;; -----------------------------------------------------------------------
     2                              <1> ;;
     3                              <1> ;;   Copyright 1994-2009 H. Peter Anvin - All Rights Reserved
     4                              <1> ;;   Copyright 2009-2010 Intel Corporation; author: H. Peter Anvin
     5                              <1> ;;
     6                              <1> ;;   This program is free software; you can redistribute it and/or modify
     7                              <1> ;;   it under the terms of the GNU General Public License as published by
     8                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <1> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <1> ;;   (at your option) any later version; incorporated herein by reference.
    11                              <1> ;;
    12                              <1> ;; -----------------------------------------------------------------------
    13                              <1> 
    14                              <1> ;;
    15                              <1> ;; com32.inc
    16                              <1> ;;
    17                              <1> ;; Common code for running a COM32 image
    18                              <1> ;;
    19                              <1> 
    20                              <1> 		extern pm_api_vector
    21                              <1> 
    22                              <1> ;
    23                              <1> ; Load a COM32 image.  A COM32 image is the 32-bit analogue to a DOS
    24                              <1> ; .com file.  A COM32 image is loaded at address 0x101000, with %esp
    25                              <1> ; set to the high end of usable memory.
    26                              <1> ;
    27                              <1> ; A COM32 image should begin with the magic bytes:
    28                              <1> ; B8 FF 4C CD 21, which is "mov eax,0x21cd4cff" in 32-bit mode and
    29                              <1> ; "mov ax,0x4cff; int 0x21" in 16-bit mode.  This will abort the
    30                              <1> ; program with an error if run in 16-bit mode.
    31                              <1> ;
    32                              <1> 		bits 16
    33                              <1> 		section .data16
    34                              <1> 
    35                              <1> 		; Ersatz com32 invocation structure, to make libcom32
    36                              <1> 		; code run the same if linked to the core.  This is in
    37                              <1> 		; the .data16 segment so HighMemSize can live here.
    38                              <1> 		;
    39                              <1> 		; Danger, Will Robinson: it's not clear the use of
    40                              <1> 		; core_xfer_buf is safe here.
    41                              <1> 		global __com32:data hidden
    42 0000000A 00<rept>            <1> 		alignz 4
    43                              <1> __entry_esp:
    44 0000000C 00000000            <1> 		dd 0				; Dummy to avoid _exit issues
    45                              <1> __com32:
    46 00000010 09000000            <1> 		dd 9				; Argument count
    47 00000014 00000000            <1> 		dd 0				; No command line
    48 00000018 [06000000]          <1> 		dd core_intcall			; Intcall entry point
    49 0000001C 00000000            <1> 		dd 0				; Bounce buffer address
    50 00000020 00000000            <1> 		dd 0				; 64K bounce buffer
    51 00000024 [00000000]          <1> 		dd core_farcall			; Farcall entry point
    52 00000028 [A6000000]          <1> 		dd core_cfarcall		; Cfarcall entry point
    53 0000002C 00000000            <1> HighMemSize	dd 0				; End of memory pointer (bytes)
    54 00000030 00000000            <1> 		dd 0				; No module name
    55 00000034 [00000000]          <1> 		dd pm_api_vector		; Protected mode functions
    56                              <1> 
    57                              <1> 		section .uibss
    58 00000000 <res 00000100>      <1> Com32Name	resb FILENAME_MAX
    59                              <1> 
    60                              <1> 		section .bss16
    61                              <1> %ifndef HAVE_CURRENTDIRNAME
    62                              <1> 		global CurrentDirName:data hidden
    63 00000124 <res 00000100>      <1> CurrentDirName	resb FILENAME_MAX
    64                              <1> %endif
    65                              <1> 
    66                              <1> 		section .text16
   279                                  
   280                                  		section .text16
   281                                  		global local_boot16:function hidden
   282                                  local_boot16:
   283 000000AE A3[0800]                		mov [LocalBootType],ax
   284 000000B1 0FB226[0020]            		lss sp,[InitStack]
   285 000000B6 0FA9                    		pop gs
   286 000000B8 0FA1                    		pop fs
   287 000000BA 07                      		pop es
   288 000000BB 1F                      		pop ds
   289 000000BC 6661                    		popad
   290 000000BE 2EA1[0800]              		mov ax,[cs:LocalBootType]
   291 000000C2 83F8FF                  		cmp ax,-1			; localboot -1 == INT 18h
   292 000000C5 7403                    		je .int18
   293 000000C7 669D                    		popfd
   294 000000C9 CB                      		retf				; Return to PXE
   295                                  .int18:
   296 000000CA 669D                    		popfd
   297 000000CC CD18                    		int 18h
   298 000000CE EAF0FF00F0              		jmp 0F000h:0FFF0h
   299 000000D3 F4                      		hlt
   300                                  
   301                                  ;
   302                                  ; kaboom: write a message and bail out.  Wait for quite a while,
   303                                  ;	  or a user keypress, then do a hard reboot.
   304                                  ;
   305                                  ;         Note: use BIOS_timer here; we may not have jiffies set up.
   306                                  ;
   307                                                  global kaboom
   308                                  kaboom:
   309                                  		RESET_STACK_AND_SEGS AX
   309 000000D4 31C0                <1>  xor %1,%1
   309 000000D6 8ED8                <1>  mov ds,%1
   309 000000D8 8EC0                <1>  mov es,%1
   309 000000DA 660FB226[0000]      <1>  lss esp,[BaseStack]
   309 000000E0 66C706[4400]-       <1>  mov dword [PMESP],__stack_end
   309 000000E5 [00000000]          <1>
   309 000000E9 FB                  <1>  sti
   309 000000EA FC                  <1>  cld
   310 000000EB BE[C500]                .patch:		mov si,bailmsg
   311 000000EE E83101                  		call writestr_early		; Returns with AL = 0
   312 000000F1 E83801                  .drain:		call pollchar
   313 000000F4 7405                    		jz .drained
   314 000000F6 E83D01                  		call getchar
   315 000000F9 EBF6                    		jmp short .drain
   316                                  .drained:
   317 000000FB 668B3E[0400]            		mov edi,[RebootTime]
   318 00000100 A0[0A00]                		mov al,[DHCPMagic]
   319 00000103 2409                    		and al,09h		; Magic+Timeout
   320 00000105 3C09                    		cmp al,09h
   321 00000107 7406                    		je .time_set
   322 00000109 66BF2C010000            		mov edi,REBOOT_TIME
   323                                  .time_set:
   324 0000010F B91200                  		mov cx,18
   325 00000112 51                      .wait1:		push cx
   326 00000113 6689F9                  		mov ecx,edi
   327 00000116 8B166C04                .wait2:		mov dx,[BIOS_timer]
   328 0000011A E80F01                  .wait3:		call pollchar
   329 0000011D 7520                    		jnz .keypress
   330                                  		pm_call __idle
   330 0000011F 6668[00000000]      <1>  push dword %1
   330 00000125 E81801              <1>  call _pm_call
   331 00000128 3B166C04                		cmp dx,[BIOS_timer]
   332 0000012C 74EC                    		je .wait3
   333 0000012E 67E2E5                  		loop .wait2,ecx
   334 00000131 B02E                    		mov al,'.'
   335                                  		pm_call pm_writechr
   335 00000133 6668[00000000]      <1>  push dword %1
   335 00000139 E80401              <1>  call _pm_call
   336 0000013C 59                      		pop cx
   337 0000013D E2D3                    		loop .wait1
   338                                  .keypress:
   339                                  		pm_call crlf
   339 0000013F 6668[00000000]      <1>  push dword %1
   339 00000145 E8F800              <1>  call _pm_call
   340 00000148 C70672040000            		mov word [BIOS_magic],0	; Cold reboot
   341 0000014E EAF0FF00F0              		jmp 0F000h:0FFF0h	; Reset vector address
   342                                  
   343                                  ;
   344                                  ; pxenv
   345                                  ;
   346                                  ; This is the main PXENV+/!PXE entry point, using the PXENV+
   347                                  ; calling convention.  This is a separate local routine so
   348                                  ; we can hook special things from it if necessary.  In particular,
   349                                  ; some PXE stacks seem to not like being invoked from anything but
   350                                  ; the initial stack, so humour it.
   351                                  ;
   352                                  ; While we're at it, save and restore all registers.
   353                                  ;
   354                                                  global pxenv
   355                                  pxenv:
   356 00000153 669C                    		pushfd
   357 00000155 6660                    		pushad
   358                                  
   359                                  		; We may be removing ourselves from memory
   360 00000157 83FB73                  		cmp bx,PXENV_RESTART_TFTP
   361 0000015A 7406                    		jz .disable_timer
   362 0000015C 81FBE500                		cmp bx,PXENV_FILE_EXEC
   363 00000160 7503                    		jnz .store_stack
   364                                  
   365                                  .disable_timer:
   366 00000162 E87605                  		call bios_timer_cleanup
   367                                  
   368                                  .store_stack:
   369 00000165 9C                      		pushf
   370 00000166 FA                      		cli
   371 00000167 2EFF06[3800]            		inc word [cs:PXEStackLock]
   372 0000016C 7512                    		jnz .skip1
   373 0000016E 5D                      		pop bp
   374 0000016F 2E8926[0000]            		mov [cs:PXEStack],sp
   375 00000174 2E8C16[0200]            		mov [cs:PXEStack+2],ss
   376 00000179 2E0FB226[0020]          		lss sp,[cs:InitStack]
   377 0000017F 55                      		push bp
   378                                  .skip1:
   379 00000180 9D                      		popf
   380                                  
   381                                  		; Pre-clear the Status field
   382 00000181 268C0D                  		mov word [es:di],cs
   383                                  
   384                                  		; This works either for the PXENV+ or the !PXE calling
   385                                  		; convention, as long as we ignore CF (which is redundant
   386                                  		; with AX anyway.)
   387 00000184 06                      		push es
   388 00000185 57                      		push di
   389 00000186 53                      		push bx
   390 00000187 9A00000000              .jump:		call 0:0
   391 0000018C 83C406                  		add sp,6
   392 0000018F 2EA3[2402]              		mov [cs:PXEStatus],ax
   393                                  
   394 00000193 9C                      		pushf
   395 00000194 FA                      		cli
   396 00000195 2EFF0E[3800]            		dec word [cs:PXEStackLock]
   397 0000019A 7908                    		jns .skip2
   398 0000019C 5D                      		pop bp
   399 0000019D 2E0FB226[0000]          		lss sp,[cs:PXEStack]
   400 000001A3 55                      		push bp
   401                                  .skip2:
   402 000001A4 9D                      		popf
   403                                  
   404 000001A5 89E5                    		mov bp,sp
   405 000001A7 21C0                    		and ax,ax
   406 000001A9 0F954620                		setnz [bp+32]			; If AX != 0 set CF on return
   407                                  
   408                                  		; This clobbers the AX return, but we already saved it into
   409                                  		; the PXEStatus variable.
   410 000001AD 6661                    		popad
   411                                  
   412                                  		; If the call failed, it could return.
   413 000001AF 83FB73                  		cmp bx,PXENV_RESTART_TFTP
   414 000001B2 7406                    		jz .enable_timer
   415 000001B4 81FBE500                		cmp bx,PXENV_FILE_EXEC
   416 000001B8 7503                    		jnz .pop_flags
   417                                  
   418                                  .enable_timer:
   419 000001BA E80C05                  		call timer_init
   420                                  
   421                                  .pop_flags:
   422 000001BD 669D                    		popfd				; Restore flags (incl. IF, DF)
   423 000001BF C3                      		ret
   424                                  
   425                                  ; Must be after function def due to NASM bug
   426                                                  global PXEEntry
   427                                  PXEEntry	equ pxenv.jump+1
   428                                  
   429                                  ;
   430                                  ; The PXEStackLock keeps us from switching stacks if we take an interrupt
   431                                  ; (which ends up calling pxenv) while we are already on the PXE stack.
   432                                  ; It will be -1 normally, 0 inside a PXE call, and a positive value
   433                                  ; inside a *nested* PXE call.
   434                                  ;
   435                                  		section .data16
   436                                  		alignb 2
   437 00000038 FFFF                    PXEStackLock	dw -1
   438                                  
   439                                  		section .bss16
   440                                  		alignb 2
   441 00000224 <res 00000002>          PXEStatus	resb 2
   442                                  
   443                                  		section .text16
   444                                  ;
   445                                  ; Invoke INT 1Ah on the PXE stack.  This is used by the "Plan C" method
   446                                  ; for finding the PXE entry point.
   447                                  ;
   448                                                  global pxe_int1a
   449                                  pxe_int1a:
   450 000001C0 2E8926[0000]            		mov [cs:PXEStack],sp
   451 000001C5 2E8C16[0200]            		mov [cs:PXEStack+2],ss
   452 000001CA 2E0FB226[0020]          		lss sp,[cs:InitStack]
   453                                  
   454 000001D0 CD1A                    		int 1Ah			; May trash registers
   455                                  
   456 000001D2 2E0FB226[0000]          		lss sp,[cs:PXEStack]
   457 000001D8 C3                      		ret
   458                                  
   459                                  ;
   460                                  ; Special unload for gPXE: this switches the InitStack from
   461                                  ; gPXE to the ROM PXE stack.
   462                                  ;
   463                                  %if GPXE
   464                                  		global gpxe_unload
   465                                  gpxe_unload:
   466 000001D9 BBE700                  		mov bx,PXENV_FILE_EXIT_HOOK
   467 000001DC BF[3C00]                		mov di,pxe_file_exit_hook
   468 000001DF E871FF                  		call pxenv
   469 000001E2 723D                    		jc .plain
   470                                  
   471                                  		; Now we actually need to exit back to gPXE, which will
   472                                  		; give control back to us on the *new* "original stack"...
   473 000001E4 669C                    		pushfd
   474 000001E6 1E                      		push ds
   475 000001E7 06                      		push es
   476 000001E8 8926[0000]              		mov [PXEStack],sp
   477 000001EC 8C16[0200]              		mov [PXEStack+2],ss
   478 000001F0 0FB226[0020]            		lss sp,[InitStack]
   479 000001F5 0FA9                    		pop gs
   480 000001F7 0FA1                    		pop fs
   481 000001F9 07                      		pop es
   482 000001FA 1F                      		pop ds
   483 000001FB 6661                    		popad
   484 000001FD 669D                    		popfd
   485 000001FF 31C0                    		xor ax,ax
   486 00000201 CB                      		retf
   487                                  .resume:
   488 00000202 FA                      		cli
   489                                  
   490                                  		; gPXE will have a stack frame looking much like our
   491                                  		; InitStack, except it has a magic cookie at the top,
   492                                  		; and the segment registers are in reverse order.
   493 00000203 6658                    		pop eax
   494 00000205 58                      		pop ax
   495 00000206 5B                      		pop bx
   496 00000207 59                      		pop cx
   497 00000208 5A                      		pop dx
   498 00000209 50                      		push ax
   499 0000020A 53                      		push bx
   500 0000020B 51                      		push cx
   501 0000020C 52                      		push dx
   502 0000020D 2E8926[0020]            		mov [cs:InitStack],sp
   503 00000212 2E8C16[0220]            		mov [cs:InitStack+2],ss
   504 00000217 2E0FB226[0000]          		lss sp,[cs:PXEStack]
   505 0000021D 07                      		pop es
   506 0000021E 1F                      		pop ds
   507 0000021F 669D                    		popfd
   508                                  
   509                                  .plain:
   510 00000221 C3                      		ret
   511                                  
   512                                  writestr_early:
   513                                  		pm_call pm_writestr
   513 00000222 6668[00000000]      <1>  push dword %1
   513 00000228 E81500              <1>  call _pm_call
   514 0000022B C3                      		ret
   515                                  
   516                                  pollchar:
   517                                  		pm_call pm_pollchar
   517 0000022C 6668[00000000]      <1>  push dword %1
   517 00000232 E80B00              <1>  call _pm_call
   518 00000235 C3                      		ret
   519                                  
   520                                  getchar:
   521                                  		pm_call pm_getchar
   521 00000236 6668[00000000]      <1>  push dword %1
   521 0000023C E80100              <1>  call _pm_call
   522 0000023F C3                      		ret
   523                                  
   524                                  		section .data16
   525 0000003A 00<rept>                		alignz 4
   526                                  pxe_file_exit_hook:
   527 0000003C 0000                    .status:	dw 0
   528 0000003E [0202]                  .offset:	dw gpxe_unload.resume
   529 00000040 0000                    .seg:		dw 0
   530                                  %endif
   531                                  
   532                                  		section .text16
   533                                  
   534                                  ; -----------------------------------------------------------------------------
   535                                  ;  PXE modules
   536                                  ; -----------------------------------------------------------------------------
   537                                  
   538                                  %if IS_LPXELINUX
   539                                  %include "pxeisr.inc"
   540                                  %endif
   541                                  
   542                                  ; -----------------------------------------------------------------------------
   543                                  ;  Common modules
   544                                  ; -----------------------------------------------------------------------------
   545                                  
   546                                  %include "common.inc"		; Universal modules
     1                              <1> ;
     2                              <1> ; Modules common to all derivatives.  Do not include modules in this list
     3                              <1> ; which have special section requirements (i.e. need to be in .init for
     4                              <1> ; some derivatives.)
     5                              <1> ;
     6                              <1> 
     7                              <1> %include "pm.inc"		; Protected mode
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 1994-2009 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
     5                              <2> ;;
     6                              <2> ;;   This program is free software; you can redistribute it and/or modify
     7                              <2> ;;   it under the terms of the GNU General Public License as published by
     8                              <2> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <2> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    11                              <2> ;;
    12                              <2> ;; -----------------------------------------------------------------------
    13                              <2> 
    14                              <2> ;;
    15                              <2> ;; pm.inc
    16                              <2> ;;
    17                              <2> ;; Functions to enter and exit 32-bit protected mode, handle interrupts
    18                              <2> ;; and cross-mode calls.
    19                              <2> ;;
    20                              <2> ;; PM refers to 32-bit flat protected mode; RM to 16-bit real mode.
    21                              <2> ;;
    22                              <2> 
    23                              <2> 		bits 16
    24                              <2> 		section .text16
    25                              <2> ;
    26                              <2> ; _pm_call: call PM routine in low memory from RM
    27                              <2> ;
    28                              <2> ;	on stack	= PM routine to call (a 32-bit address)
    29                              <2> ;
    30                              <2> ;	ECX, ESI, EDI passed to the called function;
    31                              <2> ;	EAX = EBP in the called function points to the stack frame
    32                              <2> ;	which includes all registers (which can be changed if desired.)
    33                              <2> ;
    34                              <2> ;	All registers and the flags saved/restored
    35                              <2> ;
    36                              <2> ;	This routine is invoked by the pm_call macro.
    37                              <2> ;
    38                              <2> _pm_call:
    39 00000240 669C                <2> 		pushfd
    40 00000242 6660                <2> 		pushad
    41 00000244 1E                  <2> 		push ds
    42 00000245 06                  <2> 		push es
    43 00000246 0FA0                <2> 		push fs
    44 00000248 0FA8                <2> 		push gs
    45 0000024A 89E5                <2> 		mov bp,sp
    46 0000024C 8CC8                <2> 		mov ax,cs
    47 0000024E 66BB[A6000000]      <2> 		mov ebx,.pm
    48 00000254 8ED8                <2> 		mov ds,ax
    49 00000256 EB0D                <2> 		jmp enter_pm
    50                              <2> 
    51                              <2> 		bits 32
    52                              <2> 		section .textnr
    53                              <2> .pm:
    54                              <2> 		; EAX points to the top of the RM stack, which is EFLAGS
    55 000000A6 F6452902            <2> 		test RM_FLAGSH,02h		; RM EFLAGS.IF
    56 000000AA 7401                <2> 		jz .no_sti
    57 000000AC FB                  <2> 		sti
    58                              <2> .no_sti:
    59 000000AD FF552E              <2> 		call [ebp+4*2+9*4+2]		; Entrypoint on RM stack
    60 000000B0 66BB[5802]          <2> 		mov bx,.rm
    61 000000B4 EB20                <2> 		jmp enter_rm
    62                              <2> 
    63                              <2> 		bits 16
    64                              <2> 		section .text16
    65                              <2> .rm:
    66 00000258 0FA9                <2> 		pop gs
    67 0000025A 0FA1                <2> 		pop fs
    68 0000025C 07                  <2> 		pop es
    69 0000025D 1F                  <2> 		pop ds
    70 0000025E 6661                <2> 		popad
    71 00000260 669D                <2> 		popfd
    72 00000262 C20400              <2> 		ret 4		; Drop entrypoint
    73                              <2> 
    74                              <2> ;
    75                              <2> ; enter_pm: Go to PM with interrupt service configured
    76                              <2> ;	EBX	  = PM entry point
    77                              <2> ;	EAX = EBP = on exit, points to the RM stack as a 32-bit value
    78                              <2> ;	ECX, EDX, ESI, EDI preserved across this routine
    79                              <2> ;
    80                              <2> ;	Assumes CS == DS
    81                              <2> ;
    82                              <2> ; This routine doesn't enable interrupts, but the target routine
    83                              <2> ; can enable interrupts by executing STI.
    84                              <2> ;
    85                              <2> 		bits 16
    86                              <2> 		section .text16
    87                              <2> enter_pm:
    88 00000265 FA                  <2> 		cli
    89 00000266 6631C0              <2> 		xor eax,eax
    90 00000269 8ED8                <2> 		mov ds,ax
    91 0000026B 8CD0                <2> 		mov ax,ss
    92 0000026D 8926[0828]          <2> 		mov [RealModeSSSP],sp
    93 00000271 A3[0A28]            <2> 		mov [RealModeSSSP+2],ax
    94 00000274 660FB7EC            <2> 		movzx ebp,sp
    95 00000278 66C1E004            <2> 		shl eax,4
    96 0000027C 6601C5              <2> 		add ebp,eax		; EBP -> top of real-mode stack
    97 0000027F FC                  <2> 		cld
    98 00000280 E86400              <2> 		call enable_a20
    99                              <2> 
   100                              <2> .a20ok:
   101 00000283 C606[0D00]89        <2> 		mov byte [bcopy_gdt.TSS+5],89h	; Mark TSS unbusy
   102                              <2> 
   103 00000288 0F0116[0000]        <2> 		lgdt [bcopy_gdt]	; We can use the same GDT just fine
   104 0000028D 0F011E[4800]        <2> 		lidt [PM_IDT_ptr]	; Set up the IDT
   105 00000292 0F20C0              <2> 		mov eax,cr0
   106 00000295 0C01                <2> 		or al,1
   107 00000297 0F22C0              <2> 		mov cr0,eax		; Enter protected mode
   108 0000029A EA[B600]2000        <2> 		jmp PM_CS32:.in_pm
   109                              <2> 
   110                              <2> 		bits 32
   111                              <2> 		section .textnr
   112                              <2> .in_pm:
   113 000000B6 31C0                <2> 		xor eax,eax		; Available for future use...
   114 000000B8 8EE0                <2> 		mov fs,eax
   115 000000BA 8EE8                <2> 		mov gs,eax
   116 000000BC 0F00D0              <2> 		lldt ax
   117                              <2> 
   118 000000BF B028                <2> 		mov al,PM_DS32		; Set up data segments
   119 000000C1 8EC0                <2> 		mov es,eax
   120 000000C3 8ED8                <2> 		mov ds,eax
   121 000000C5 8ED0                <2> 		mov ss,eax
   122                              <2> 
   123 000000C7 B008                <2> 		mov al,PM_TSS		; Be nice to Intel's VT by
   124 000000C9 0F00D8              <2> 		ltr ax			; giving it a valid TR
   125                              <2> 
   126 000000CC 8B25[44000000]      <2> 		mov esp,[PMESP]		; Load protmode %esp
   127 000000D2 89E8                <2> 		mov eax,ebp		; EAX -> top of real-mode stack
   128 000000D4 FFE3                <2> 		jmp ebx			; Go to where we need to go
   129                              <2> 
   130                              <2> ;
   131                              <2> ; enter_rm: Return to RM from PM
   132                              <2> ;
   133                              <2> ;	BX	= RM entry point (CS = 0)
   134                              <2> ;	ECX, EDX, ESI, EDI preserved across this routine
   135                              <2> ;	EAX	clobbered
   136                              <2> ;	EBP	reserved
   137                              <2> ;
   138                              <2> ; This routine doesn't enable interrupts, but the target routine
   139                              <2> ; can enable interrupts by executing STI.
   140                              <2> ;
   141                              <2> 		bits 32
   142                              <2> 		section .textnr
   143                              <2> enter_rm:
   144 000000D6 FA                  <2> 		cli
   145 000000D7 FC                  <2> 		cld
   146 000000D8 8925[44000000]      <2> 		mov [PMESP],esp		; Save exit %esp
   147 000000DE EA[9F020000]1000    <2> 		jmp PM_CS16:.in_pm16	; Return to 16-bit mode first
   148                              <2> 
   149                              <2> 		bits 16
   150                              <2> 		section .text16
   151                              <2> .in_pm16:
   152 0000029F B81800              <2> 		mov ax,PM_DS16		; Real-mode-like segment
   153 000002A2 8EC0                <2> 		mov es,ax
   154 000002A4 8ED8                <2> 		mov ds,ax
   155 000002A6 8ED0                <2> 		mov ss,ax
   156 000002A8 8EE0                <2> 		mov fs,ax
   157 000002AA 8EE8                <2> 		mov gs,ax
   158                              <2> 
   159 000002AC 0F011E[3000]        <2> 		lidt [RM_IDT_ptr]	; Real-mode IDT (rm needs no GDT)
   160 000002B1 31D2                <2> 		xor dx,dx
   161 000002B3 0F20C0              <2> 		mov eax,cr0
   162 000002B6 24FE                <2> 		and al,~1
   163 000002B8 0F22C0              <2> 		mov cr0,eax
   164 000002BB EA[C002]0000        <2> 		jmp 0:.in_rm
   165                              <2> 
   166                              <2> .in_rm:					; Back in real mode
   167 000002C0 2E0FB226[0828]      <2> 		lss sp,[cs:RealModeSSSP]	; Restore stack
   168 000002C6 660FB7E4            <2> 		movzx esp,sp		; Make sure the high bits are zero
   169 000002CA 8EDA                <2> 		mov ds,dx		; Set up sane segments
   170 000002CC 8EC2                <2> 		mov es,dx
   171 000002CE 8EE2                <2> 		mov fs,dx
   172 000002D0 8EEA                <2> 		mov gs,dx
   173 000002D2 FFE3                <2> 		jmp bx			; Go to whereever we need to go...
   174                              <2> 
   175                              <2> 		section .data16
   176 00000042 00<rept>            <2> 		alignz 4
   177                              <2> 
   178                              <2> 		extern __stack_end
   179 00000044 [00000000]          <2> PMESP		dd __stack_end		; Protected-mode ESP
   180                              <2> 
   181 00000048 FF07                <2> PM_IDT_ptr:	dw 8*256-1		; Length
   182 0000004A [08200000]          <2> 		dd IDT			; Offset
   183                              <2> 
   184                              <2> ;
   185                              <2> ; This is invoked on getting an interrupt in protected mode.  At
   186                              <2> ; this point, we need to context-switch to real mode and invoke
   187                              <2> ; the interrupt routine.
   188                              <2> ;
   189                              <2> ; When this gets invoked, the registers are saved on the stack and
   190                              <2> ; AL contains the register number.
   191                              <2> ;
   192                              <2> 		bits 32
   193                              <2> 		section .textnr
   194                              <2> pm_irq:
   195 000000E5 60                  <2> 		pushad
   196 000000E6 0FB6742420          <2> 		movzx esi,byte [esp+8*4] ; Interrupt number
   197 000000EB FF05[34020000]      <2> 		inc dword [CallbackCtr]
   198 000000F1 BB[D4020000]        <2> 		mov ebx,.rm
   199 000000F6 EBDE                <2> 		jmp enter_rm		; Go to real mode
   200                              <2> 
   201                              <2> 		bits 16
   202                              <2> 		section .text16
   203                              <2> .rm:
   204 000002D4 9C                  <2> 		pushf			; Flags on stack
   205 000002D5 2E67FF1CB500000000  <2> 		call far [cs:esi*4]	; Call IVT entry
   206 000002DE 66BB[F8000000]      <2> 		mov ebx,.pm
   207 000002E4 E97EFF              <2> 		jmp enter_pm		; Go back to PM
   208                              <2> 
   209                              <2> 		bits 32
   210                              <2> 		section .textnr
   211                              <2> .pm:
   212 000000F8 FF0D[34020000]      <2> 		dec dword [CallbackCtr]
   213 000000FE 7506                <2> 		jnz .skip
   214 00000100 FF15[50000000]      <2> 		call [core_pm_hook]
   215                              <2> .skip:
   216 00000106 61                  <2> 		popad
   217 00000107 83C404              <2> 		add esp,4		; Drop interrupt number
   218 0000010A CF                  <2> 		iretd
   219                              <2> 
   220                              <2> ;
   221                              <2> ; Initially, the core_pm_hook does nothing; it is available for the
   222                              <2> ; threaded derivatives to run the scheduler, or examine the result from
   223                              <2> ; interrupt routines.
   224                              <2> ;
   225                              <2> 		global core_pm_null_hook
   226                              <2> core_pm_null_hook:
   227 0000010B C3                  <2> 		ret
   228                              <2> 
   229                              <2> 		section .data16
   230 0000004E 00<rept>            <2> 		alignz 4
   231                              <2> 		global core_pm_hook
   232 00000050 [0B010000]          <2> core_pm_hook:	dd core_pm_null_hook
   233                              <2> 
   234                              <2> 		bits 16
   235                              <2> 		section .text16
   236                              <2> ;
   237                              <2> ; Routines to enable and disable (yuck) A20.  These routines are gathered
   238                              <2> ; from tips from a couple of sources, including the Linux kernel and
   239                              <2> ; http://www.x86.org/.  The need for the delay to be as large as given here
   240                              <2> ; is indicated by Donnie Barnes of RedHat, the problematic system being an
   241                              <2> ; IBM ThinkPad 760EL.
   242                              <2> ;
   243                              <2> 
   244                              <2> 		section .data16
   245                              <2> 		alignz 2
   246 00000054 [F902]              <2> A20Ptr		dw a20_dunno
   247                              <2> 
   248                              <2> 		section .bss16
   249 00000226 <res 00000002>      <2> 		alignb 4
   250 00000228 <res 00000004>      <2> A20Test		resd 1			; Counter for testing A20 status
   251 0000022C <res 00000001>      <2> A20Tries	resb 1			; Times until giving up on A20
   252                              <2> 
   253                              <2> 		section .text16
   254                              <2> enable_a20:
   255 000002E7 6660                <2> 		pushad
   256 000002E9 2EC606[2C02]FF      <2> 		mov byte [cs:A20Tries],255 ; Times to try to make this work
   257                              <2> 
   258                              <2> try_enable_a20:
   259                              <2> 
   260                              <2> ;
   261                              <2> ; First, see if we are on a system with no A20 gate, or the A20 gate
   262                              <2> ; is already enabled for us...
   263                              <2> ;
   264                              <2> a20_none:
   265 000002EF E87C00              <2> 		call a20_test
   266 000002F2 7577                <2> 		jnz a20_done
   267                              <2> 		; Otherwise, see if we had something memorized...
   268 000002F4 2EFF26[5400]        <2> 		jmp word [cs:A20Ptr]
   269                              <2> 
   270                              <2> ;
   271                              <2> ; Next, try the BIOS (INT 15h AX=2401h)
   272                              <2> ;
   273                              <2> a20_dunno:
   274                              <2> a20_bios:
   275 000002F9 2EC706[5400][F902]  <2> 		mov word [cs:A20Ptr], a20_bios
   276 00000300 B80124              <2> 		mov ax,2401h
   277 00000303 9C                  <2> 		pushf				; Some BIOSes muck with IF
   278 00000304 CD15                <2> 		int 15h
   279 00000306 9D                  <2> 		popf
   280                              <2> 
   281 00000307 E86400              <2> 		call a20_test
   282 0000030A 755F                <2> 		jnz a20_done
   283                              <2> 
   284                              <2> ;
   285                              <2> ; Enable the keyboard controller A20 gate
   286                              <2> ;
   287                              <2> a20_kbc:
   288 0000030C B201                <2> 		mov dl, 1			; Allow early exit
   289 0000030E E88E00              <2> 		call empty_8042
   290 00000311 7558                <2> 		jnz a20_done			; A20 live, no need to use KBC
   291                              <2> 
   292 00000313 2EC706[5400][0C03]  <2> 		mov word [cs:A20Ptr], a20_kbc	; Starting KBC command sequence
   293                              <2> 
   294 0000031A B0D1                <2> 		mov al,0D1h			; Write output port
   295 0000031C E664                <2> 		out 064h, al
   296 0000031E E87C00              <2> 		call empty_8042_uncond
   297                              <2> 
   298 00000321 B0DF                <2> 		mov al,0DFh			; A20 on
   299 00000323 E660                <2> 		out 060h, al
   300 00000325 E87500              <2> 		call empty_8042_uncond
   301                              <2> 
   302                              <2> 		; Apparently the UHCI spec assumes that A20 toggle
   303                              <2> 		; ends with a null command (assumed to be for sychronization?)
   304                              <2> 		; Put it here to see if it helps anything...
   305 00000328 B0FF                <2> 		mov al,0FFh			; Null command
   306 0000032A E664                <2> 		out 064h, al
   307 0000032C E86E00              <2> 		call empty_8042_uncond
   308                              <2> 
   309                              <2> 		; Verify that A20 actually is enabled.  Do that by
   310                              <2> 		; observing a word in low memory and the same word in
   311                              <2> 		; the HMA until they are no longer coherent.  Note that
   312                              <2> 		; we don't do the same check in the disable case, because
   313                              <2> 		; we don't want to *require* A20 masking (SYSLINUX should
   314                              <2> 		; work fine without it, if the BIOS does.)
   315 0000032F 51                  <2> .kbc_wait:	push cx
   316 00000330 31C9                <2> 		xor cx,cx
   317                              <2> .kbc_wait_loop:
   318 00000332 E83900              <2> 		call a20_test
   319 00000335 7533                <2> 		jnz a20_done_pop
   320 00000337 E2F9                <2> 		loop .kbc_wait_loop
   321                              <2> 
   322 00000339 59                  <2> 		pop cx
   323                              <2> ;
   324                              <2> ; Running out of options here.  Final attempt: enable the "fast A20 gate"
   325                              <2> ;
   326                              <2> a20_fast:
   327 0000033A 2EC706[5400][3A03]  <2> 		mov word [cs:A20Ptr], a20_fast
   328 00000341 E492                <2> 		in al, 092h
   329 00000343 0C02                <2> 		or al,02h
   330 00000345 24FE                <2> 		and al,~01h			; Don't accidentally reset the machine!
   331 00000347 E692                <2> 		out 092h, al
   332                              <2> 
   333 00000349 51                  <2> .fast_wait:	push cx
   334 0000034A 31C9                <2> 		xor cx,cx
   335                              <2> .fast_wait_loop:
   336 0000034C E81F00              <2> 		call a20_test
   337 0000034F 7519                <2> 		jnz a20_done_pop
   338 00000351 E2F9                <2> 		loop .fast_wait_loop
   339                              <2> 
   340 00000353 59                  <2> 		pop cx
   341                              <2> 
   342                              <2> ;
   343                              <2> ; Oh bugger.  A20 is not responding.  Try frobbing it again; eventually give up
   344                              <2> ; and report failure to the user.
   345                              <2> ;
   346 00000354 2EFE0E[2C02]        <2> 		dec byte [cs:A20Tries]
   347 00000359 759E                <2> 		jnz a20_dunno		; Did we get the wrong type?
   348                              <2> 
   349 0000035B BE[5600]            <2> 		mov si, err_a20
   350                              <2> 		pm_call pm_writestr
   350 0000035E 6668[00000000]      <3>  push dword %1
   350 00000364 E8D9FE              <3>  call _pm_call
   351 00000367 E96AFD              <2> 		jmp kaboom
   352                              <2> 
   353                              <2> 		section .data16
   354 00000056 0D0A41323020676174- <2> err_a20		db CR, LF, 'A20 gate not responding!', CR, LF, 0
   354 0000005F 65206E6F7420726573- <2>
   354 00000068 706F6E64696E67210D- <2>
   354 00000071 0A00                <2>
   355                              <2> 		section .text16
   356                              <2> 
   357                              <2> ;
   358                              <2> ; A20 unmasked, proceed...
   359                              <2> ;
   360 0000036A 59                  <2> a20_done_pop:	pop cx
   361 0000036B 6661                <2> a20_done:	popad
   362 0000036D C3                  <2> 		ret
   363                              <2> 
   364                              <2> ;
   365                              <2> ; This routine tests if A20 is enabled (ZF = 0).  This routine
   366                              <2> ; must not destroy any register contents.
   367                              <2> ;
   368                              <2> ; The no-write early out avoids the io_delay in the (presumably common)
   369                              <2> ; case of A20 already enabled (e.g. from a previous call.)
   370                              <2> ;
   371                              <2> a20_test:
   372 0000036E 06                  <2> 		push es
   373 0000036F 51                  <2> 		push cx
   374 00000370 6650                <2> 		push eax
   375 00000372 B9FFFF              <2> 		mov cx,0FFFFh			; HMA = segment 0FFFFh
   376 00000375 8EC1                <2> 		mov es,cx
   377 00000377 2E66A1[2802]        <2> 		mov eax,[cs:A20Test]
   378 0000037C B92000              <2> 		mov cx,32			; Loop count
   379 0000037F EB0F                <2> 		jmp .test			; First iteration = early out
   380 00000381 660541EA0A43        <2> .wait:		add eax,0x430aea41		; A large prime number
   381 00000387 2E66A3[2802]        <2> 		mov [cs:A20Test],eax
   382 0000038C E680E680            <2> 		io_delay			; Serialize, and fix delay
   383 00000390 26663B06[3802]      <2> .test:		cmp eax,[es:A20Test+10h]
   384 00000396 E1E9                <2> 		loopz .wait
   385 00000398 6658                <2> .done:		pop eax
   386 0000039A 59                  <2> 		pop cx
   387 0000039B 07                  <2> 		pop es
   388 0000039C C3                  <2> 		ret
   389                              <2> 
   390                              <2> ;
   391                              <2> ; Routine to empty the 8042 KBC controller.  If dl != 0
   392                              <2> ; then we will test A20 in the loop and exit if A20 is
   393                              <2> ; suddenly enabled.
   394                              <2> ;
   395                              <2> empty_8042_uncond:
   396 0000039D 30D2                <2> 		xor dl,dl
   397                              <2> empty_8042:
   398 0000039F E8CCFF              <2> 		call a20_test
   399 000003A2 7404                <2> 		jz .a20_on
   400 000003A4 20D2                <2> 		and dl,dl
   401 000003A6 751A                <2> 		jnz .done
   402 000003A8 E680E680            <2> .a20_on:	io_delay
   403 000003AC E464                <2> 		in al, 064h		; Status port
   404 000003AE A801                <2> 		test al,1
   405 000003B0 7408                <2> 		jz .no_output
   406 000003B2 E680E680            <2> 		io_delay
   407 000003B6 E460                <2> 		in al, 060h		; Read input
   408 000003B8 EBE5                <2> 		jmp short empty_8042
   409                              <2> .no_output:
   410 000003BA A802                <2> 		test al,2
   411 000003BC 75E1                <2> 		jnz empty_8042
   412 000003BE E680E680            <2> 		io_delay
   413 000003C2 C3                  <2> .done:		ret
   414                              <2> 
   415                              <2> ;
   416                              <2> ; This initializes the protected-mode interrupt thunk set
   417                              <2> ;
   418                              <2> 		section .text16
   419                              <2> pm_init:
   420 000003C3 6631FF              <2> 		xor edi,edi
   421 000003C6 BB[0820]            <2> 		mov bx,IDT
   422 000003C9 BF[0000]            <2> 		mov di,IRQStubs
   423                              <2> 
   424 000003CC 66B86A00EB7A        <2> 		mov eax,7aeb006ah	; push byte .. jmp short ..
   425                              <2> 
   426 000003D2 B90800              <2> 		mov cx,8		; 8 groups of 32 IRQs
   427                              <2> .gloop:
   428 000003D5 51                  <2> 		push cx
   429 000003D6 B92000              <2> 		mov cx,32		; 32 entries per group
   430                              <2> .eloop:
   431 000003D9 893F                <2> 		mov [bx],di		; IDT offset [15:0]
   432 000003DB C747022000          <2> 		mov word [bx+2],PM_CS32	; IDT segment
   433 000003E0 66C74704008E0000    <2> 		mov dword [bx+4],08e00h	; IDT offset [31:16], 32-bit interrupt
   434                              <2> 					; gate, CPL 0 (we don't have a TSS
   435                              <2> 					; set up...)
   436 000003E8 83C308              <2> 		add bx,8
   437                              <2> 
   438 000003EB 66AB                <2> 		stosd
   439                              <2> 		; Increment IRQ, decrement jmp short offset
   440 000003ED 6605000100FC        <2> 		add eax,(-4 << 24)+(1 << 8)
   441                              <2> 
   442 000003F3 E2E4                <2> 		loop .eloop
   443                              <2> 
   444                              <2> 		; At the end of each group, replace the EBxx with
   445                              <2> 		; the final E9xxxxxxxx
   446 000003F5 83C703              <2> 		add di,3
   447 000003F8 C645FBE9            <2> 		mov byte [di-5],0E9h	; JMP NEAR
   448 000003FC 66BA[E5000000]      <2> 		mov edx,pm_irq
   449 00000402 6629FA              <2> 		sub edx,edi
   450 00000405 668955FC            <2> 		mov [di-4],edx
   451                              <2> 
   452 00000409 660500000080        <2> 		add eax,(0x80 << 24)	; Proper offset for the next one
   453 0000040F 59                  <2> 		pop cx
   454 00000410 E2C3                <2> 		loop .gloop
   455                              <2> 
   456 00000412 C3                  <2> 		ret
   457                              <2> 
   458                              <2> 		; pm_init is called before bss clearing, so put these
   459                              <2> 		; in .earlybss!
   460                              <2> 		section .earlybss
   461 00002004 <res 00000004>      <2> 		alignb 8
   462 00002008 <res 00000800>      <2> IDT:		resq 256
   463                              <2> 		global RealModeSSSP
   464 00002808 <res 00000004>      <2> RealModeSSSP	resd 1			; Real-mode SS:SP
   465                              <2> 
   466                              <2> 		section .gentextnr	; Autogenerated 32-bit code
   467 00000000 <res 00000418>      <2> IRQStubs:	resb 4*256+3*8
   468                              <2> 
   469                              <2> 		section .text16
   470                              <2> 
   471                              <2> %include "callback.inc"			; Real-mode callbacks
     1                              <3> ;; -----------------------------------------------------------------------
     2                              <3> ;;
     3                              <3> ;;   Copyright 1994-2009 H. Peter Anvin - All Rights Reserved
     4                              <3> ;;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
     5                              <3> ;;
     6                              <3> ;;   This program is free software; you can redistribute it and/or modify
     7                              <3> ;;   it under the terms of the GNU General Public License as published by
     8                              <3> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <3> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <3> ;;   (at your option) any later version; incorporated herein by reference.
    11                              <3> ;;
    12                              <3> ;; -----------------------------------------------------------------------
    13                              <3> 
    14                              <3> ;;
    15                              <3> ;; callback.inc
    16                              <3> ;;
    17                              <3> ;; Callbacks from 32-bit mode to 16-bit mode
    18                              <3> ;;
    19                              <3> 
    20                              <3> ;
    21                              <3> ; 16-bit intcall/farcall handling code
    22                              <3> ;
    23                              <3> 
    24                              <3> ;
    25                              <3> ; 32-bit support code
    26                              <3> ;
    27                              <3> 		bits 32
    28                              <3> 		section .text
    29                              <3> 
    30                              <3> ;
    31                              <3> ; Intcall/farcall invocation.  We manifest a structure on the real-mode stack,
    32                              <3> ; containing the com32sys_t structure from <com32.h> as well as
    33                              <3> ; the following entries (from low to high address):
    34                              <3> ; - Target offset
    35                              <3> ; - Target segment
    36                              <3> ; - Return offset
    37                              <3> ; - Return segment (== real mode cs == 0)
    38                              <3> ; - Return flags
    39                              <3> ;
    40                              <3> 		global core_farcall:function hidden
    41                              <3> core_farcall:
    42 00000000 8B442404            <3> 		mov eax,[esp+1*4]		; CS:IP
    43 00000004 EB0C                <3> 		jmp core_syscall
    44                              <3> 
    45                              <3> 		global core_intcall:function hidden
    46                              <3> core_intcall:
    47 00000006 0FB6442404          <3> 		movzx eax,byte [esp+1*4]	; INT number
    48 0000000B 8B048500000000      <3> 		mov eax,[eax*4]			; Get CS:IP from low memory
    49                              <3> 
    50                              <3> core_syscall:
    51 00000012 9C                  <3> 		pushfd				; Save IF among other things...
    52 00000013 FF05[34020000]      <3> 		inc dword [CallbackCtr]
    53 00000019 53                  <3> 		push ebx
    54 0000001A 55                  <3> 		push ebp
    55 0000001B 56                  <3> 		push esi
    56 0000001C 57                  <3> 		push edi
    57 0000001D FF35[30020000]      <3> 		push dword [CallbackSP]
    58                              <3> 
    59 00000023 FC                  <3> 		cld
    60                              <3> 
    61 00000024 670FB73E[0828]      <3> 		movzx edi,word [word RealModeSSSP]
    62 0000002A 670FB71E[0A28]      <3> 		movzx ebx,word [word RealModeSSSP+2]
    63 00000030 83EF36              <3> 		sub edi,54		; Allocate 54 bytes
    64 00000033 6667893E[0828]      <3> 		mov [word RealModeSSSP],di
    65 00000039 C1E304              <3> 		shl ebx,4
    66 0000003C 01DF                <3> 		add edi,ebx		; Create linear address
    67                              <3> 
    68 0000003E 8B742420            <3> 		mov esi,[esp+8*4]	; Source regs
    69 00000042 31C9                <3> 		xor ecx,ecx
    70 00000044 B10B                <3> 		mov cl,11		; 44 bytes to copy
    71 00000046 F3A5                <3> 		rep movsd
    72                              <3> 
    73                              <3> 		; EAX is already set up to be CS:IP
    74 00000048 AB                  <3> 		stosd			; Save in stack frame
    75 00000049 B8[26040000]        <3> 		mov eax,.rm_return	; Return seg:offs
    76 0000004E AB                  <3> 		stosd			; Save in stack frame
    77 0000004F 8B47F4              <3> 		mov eax,[edi-12]	; Return flags
    78 00000052 25D70E2000          <3> 		and eax,0x200ed7	; Mask (potentially) unsafe flags
    79 00000057 8947F4              <3> 		mov [edi-12],eax	; Primary flags entry
    80 0000005A 66AB                <3> 		stosw			; Return flags
    81                              <3> 
    82 0000005C 66BB[1304]          <3> 		mov bx,.rm
    83 00000060 E9(D6000000)        <3> 		jmp enter_rm	; Go to real mode
    84                              <3> 
    85                              <3> 		bits 16
    86                              <3> 		section .text16
    87                              <3> .rm:
    88 00000413 89E0                <3> 		mov ax,sp
    89 00000415 83C02C              <3> 		add ax,9*4+4*2
    90 00000418 A3[3002]            <3> 		mov [CallbackSP],ax
    91 0000041B 0FA9                <3> 		pop gs
    92 0000041D 0FA1                <3> 		pop fs
    93 0000041F 07                  <3> 		pop es
    94 00000420 1F                  <3> 		pop ds
    95 00000421 6661                <3> 		popad
    96 00000423 669D                <3> 		popfd
    97 00000425 CB                  <3> 		retf				; Invoke routine
    98                              <3> 
    99                              <3> .rm_return:
   100                              <3> 		; We clean up SP here because we don't know if the
   101                              <3> 		; routine returned with RET, RETF or IRET
   102 00000426 2E8B26[3002]        <3> 		mov sp,[cs:CallbackSP]
   103 0000042B 669C                <3> 		pushfd
   104 0000042D 6660                <3> 		pushad
   105 0000042F 1E                  <3> 		push ds
   106 00000430 06                  <3> 		push es
   107 00000431 0FA0                <3> 		push fs
   108 00000433 0FA8                <3> 		push gs
   109 00000435 66BB[65000000]      <3> 		mov ebx,.pm_return
   110 0000043B E927FE              <3> 		jmp enter_pm
   111                              <3> 
   112                              <3> 		; On return, the 44-byte return structure is on the
   113                              <3> 		; real-mode stack, plus the 10 additional bytes used
   114                              <3> 		; by the target address (see above.)
   115                              <3> 		bits 32
   116                              <3> 		section .text
   117                              <3> .pm_return:
   118 00000065 670FB736[0828]      <3> 		movzx esi,word [word RealModeSSSP]
   119 0000006B 670FB706[0A28]      <3> 		movzx eax,word [word RealModeSSSP+2]
   120 00000071 8B7C2424            <3> 		mov edi,[esp+9*4]	; Dest regs
   121 00000075 C1E004              <3> 		shl eax,4
   122 00000078 01C6                <3> 		add esi,eax		; Create linear address
   123 0000007A 21FF                <3> 		and edi,edi		; NULL pointer?
   124 0000007C 7502                <3> 		jnz .do_copy
   125 0000007E 89F7                <3> .no_copy:	mov edi,esi		; Do a dummy copy-to-self
   126 00000080 31C9                <3> .do_copy:	xor ecx,ecx
   127 00000082 B10B                <3> 		mov cl,11		; 44 bytes
   128 00000084 F3A5                <3> 		rep movsd		; Copy register block
   129                              <3> 
   130 00000086 678306[0828]36      <3> 		add dword [word RealModeSSSP],54
   131                              <3> 					; Remove from stack
   132                              <3> 
   133 0000008C 8F05[30020000]      <3> 		pop dword [CallbackSP]
   134 00000092 FF0D[34020000]      <3> 		dec dword [CallbackCtr]
   135 00000098 7506                <3> 		jnz .skip
   136 0000009A FF15[50000000]      <3> 		call [core_pm_hook]
   137                              <3> .skip:
   138 000000A0 5F                  <3> 		pop edi
   139 000000A1 5E                  <3> 		pop esi
   140 000000A2 5D                  <3> 		pop ebp
   141 000000A3 5B                  <3> 		pop ebx
   142 000000A4 9D                  <3> 		popfd
   143 000000A5 C3                  <3> 		ret			; Return to 32-bit program
   144                              <3> 
   145                              <3> ;
   146                              <3> ; Cfarcall invocation.  We copy the stack frame to the real-mode stack,
   147                              <3> ; followed by the return CS:IP and the CS:IP of the target function.
   148                              <3> ; The value of IF is copied from the calling routine.
   149                              <3> ;
   150                              <3> 		global core_cfarcall:function hidden
   151                              <3> core_cfarcall:
   152 000000A6 9C                  <3> 		pushfd				; Save IF among other things...
   153 000000A7 FF05[34020000]      <3> 		inc dword [CallbackCtr]
   154 000000AD 53                  <3> 		push ebx
   155 000000AE 55                  <3> 		push ebp
   156 000000AF 56                  <3> 		push esi
   157 000000B0 57                  <3> 		push edi
   158 000000B1 FF35[30020000]      <3> 		push dword [CallbackSP]
   159                              <3> 
   160 000000B7 FC                  <3> 		cld
   161 000000B8 8B4C2424            <3> 		mov ecx,[esp+9*4]		; Size of stack frame
   162                              <3> 
   163 000000BC 670FB73E[0828]      <3> 		movzx edi,word [word RealModeSSSP]
   164 000000C2 670FB71E[0A28]      <3> 		movzx ebx,word [word RealModeSSSP+2]
   165 000000C8 6667893E[3002]      <3> 		mov [word CallbackSP],di
   166 000000CE 29CF                <3> 		sub edi,ecx		; Allocate space for stack frame
   167 000000D0 83E7FC              <3> 		and edi,~3		; Round
   168 000000D3 83EF0C              <3> 		sub edi,4*3		; Return pointer, return value, EFLAGS
   169 000000D6 6667893E[0828]      <3> 		mov [word RealModeSSSP],di
   170 000000DC C1E304              <3> 		shl ebx,4
   171 000000DF 01DF                <3> 		add edi,ebx		; Create linear address
   172                              <3> 
   173 000000E1 8B442414            <3> 		mov eax,[esp+5*4]	; EFLAGS from entry
   174 000000E5 2502020000          <3> 		and eax,0x202		; IF only
   175 000000EA AB                  <3> 		stosd
   176 000000EB 8B44241C            <3> 		mov eax,[esp+7*4]	; CS:IP
   177 000000EF AB                  <3> 		stosd			; Save to stack frame
   178 000000F0 B8[41040000]        <3> 		mov eax,.rm_return	; Return seg:off
   179 000000F5 AB                  <3> 		stosd
   180 000000F6 8B742420            <3> 		mov esi,[esp+8*4]	; Stack frame
   181 000000FA 89C8                <3> 		mov eax,ecx		; Copy the stack frame
   182 000000FC C1E902              <3> 		shr ecx,2
   183 000000FF F3A5                <3> 		rep movsd
   184 00000101 89C1                <3> 		mov ecx,eax
   185 00000103 83E103              <3> 		and ecx,3
   186 00000106 F3A4                <3> 		rep movsb
   187                              <3> 
   188 00000108 66BB[3E04]          <3> 		mov bx,.rm
   189 0000010C E9(D6000000)        <3> 		jmp enter_rm
   190                              <3> 
   191                              <3> 		bits 16
   192                              <3> 		section .text16
   193                              <3> .rm:
   194 0000043E 669D                <3> 		popfd
   195 00000440 CB                  <3> 		retf
   196                              <3> .rm_return:
   197 00000441 2E8B26[3002]        <3> 		mov sp,[cs:CallbackSP]
   198 00000446 6689C6              <3> 		mov esi,eax
   199 00000449 66BB[11010000]      <3> 		mov ebx,.pm_return
   200 0000044F E913FE              <3> 		jmp enter_pm
   201                              <3> 
   202                              <3> 		bits 32
   203                              <3> 		section .text
   204                              <3> .pm_return:
   205 00000111 89F0                <3> 		mov eax,esi
   206                              <3> 		; EDX already set up to be the RM return value
   207 00000113 8F05[30020000]      <3> 		pop dword [CallbackSP]
   208 00000119 FF0D[34020000]      <3> 		dec dword [CallbackCtr]
   209 0000011F 7506                <3> 		jnz .skip
   210 00000121 FF15[50000000]      <3> 		call [core_pm_hook]
   211                              <3> .skip:
   212 00000127 5B                  <3> 		pop ebx
   213 00000128 5D                  <3> 		pop ebp
   214 00000129 5E                  <3> 		pop esi
   215 0000012A 5F                  <3> 		pop edi
   216 0000012B 9D                  <3> 		popfd
   217 0000012C C3                  <3> 		ret
   218                              <3> 
   219                              <3> 		section .bss16
   220 0000022D <res 00000003>      <3> 		alignb 4
   221                              <3> 		global core_pm_hook
   222 00000230 <res 00000004>      <3> CallbackSP	resd 1			; SP saved during callback
   223 00000234 <res 00000004>      <3> CallbackCtr	resd 1
   224                              <3> 
   225                              <3> 		bits 16
   226                              <3> 		section .text16
     8                              <1> %include "bcopy32.inc"		; 32-bit bcopy
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 1994-2009 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
     5                              <2> ;;
     6                              <2> ;;   This program is free software; you can redistribute it and/or modify
     7                              <2> ;;   it under the terms of the GNU General Public License as published by
     8                              <2> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <2> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    11                              <2> ;;
    12                              <2> ;; -----------------------------------------------------------------------
    13                              <2> 
    14                              <2> ;;
    15                              <2> ;; bcopy32.inc
    16                              <2> ;;
    17                              <2> ;; 32-bit bcopy routine for real mode
    18                              <2> ;;
    19                              <2> 
    20                              <2> ;
    21                              <2> ; 32-bit bcopy routine for real mode
    22                              <2> ;
    23                              <2> ; We enter protected mode, set up a flat 32-bit environment, run rep movsd
    24                              <2> ; and then exit.  IMPORTANT: This code assumes cs == 0.
    25                              <2> ;
    26                              <2> ; This code is probably excessively anal-retentive in its handling of
    27                              <2> ; segments, but this stuff is painful enough as it is without having to rely
    28                              <2> ; on everything happening "as it ought to."
    29                              <2> ;
    30                              <2> 
    31                              <2> 		bits 16
    32                              <2> 		section .text16
    33                              <2> 
    34                              <2> ;
    35                              <2> ; bcopy:
    36                              <2> ;	32-bit copy, overlap safe
    37                              <2> ;
    38                              <2> ; Inputs:
    39                              <2> ;	ESI	- source pointer (-1 means do bzero rather than bcopy)
    40                              <2> ;	EDI	- target pointer
    41                              <2> ;	ECX	- byte count
    42                              <2> ;
    43                              <2> ; Outputs:
    44                              <2> ;	ESI	- first byte after source (garbage if ESI == -1 on entry)
    45                              <2> ;	EDI	- first byte after target
    46                              <2> ;
    47 00000452 67E30F              <2> bcopy:		jecxz .ret
    48                              <2> 		pm_call pm_bcopy
    48 00000455 6668[00000000]      <3>  push dword %1
    48 0000045B E8E2FD              <3>  call _pm_call
    49 0000045E 6601CF              <2> 		add edi,ecx
    50 00000461 6601CE              <2> 		add esi,ecx
    51 00000464 C3                  <2> .ret:		ret
    52                              <2> 
    53                              <2> ;
    54                              <2> ; shuffle_and_boot_raw:
    55                              <2> ;	The new version of shuffle and boot.
    56                              <2> ; Inputs:
    57                              <2> ;	ESI		-> Pointer to list of (dst, src, len) pairs(*)
    58                              <2> ;	EDI		-> Pointer to safe area for list + shuffler
    59                              <2> ;			   (must not overlap this code nor the RM stack)
    60                              <2> ;	ECX		-> Byte count of list area (for initial copy)
    61                              <2> ;
    62                              <2> ;     If src == -1: then the memory pointed to by (dst, len) is bzeroed;
    63                              <2> ;		    this is handled inside the bcopy routine.
    64                              <2> ;
    65                              <2> ;     If len == 0:  this marks the end of the list; dst indicates
    66                              <2> ;		    the entry point and src the mode (0 = pm, 1 = rm)
    67                              <2> ;
    68                              <2> ;     (*) dst, src, and len are four bytes each
    69                              <2> ;
    70                              <2> shuffle_and_boot_raw:
    71 00000465 BB[BA00]            <2> 		mov bx,pm_shuffle
    72 00000468 E9FAFD              <2> 		jmp enter_pm
    73                              <2> 
    74                              <2> ;
    75                              <2> ; The 32-bit copy and shuffle code is "special", so it is in its own file
    76                              <2> ;
    77                              <2> %include "bcopyxx.inc"
     1                              <3> ;; -----------------------------------------------------------------------
     2                              <3> ;;
     3                              <3> ;;   Copyright 1994-2009 H. Peter Anvin - All Rights Reserved
     4                              <3> ;;   Copyright 2009-2010 Intel Corporation; author: H. Peter Anvin
     5                              <3> ;;
     6                              <3> ;;   This program is free software; you can redistribute it and/or modify
     7                              <3> ;;   it under the terms of the GNU General Public License as published by
     8                              <3> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
     9                              <3> ;;   Boston MA 02111-1307, USA; either version 2 of the License, or
    10                              <3> ;;   (at your option) any later version; incorporated herein by reference.
    11                              <3> ;;
    12                              <3> ;; -----------------------------------------------------------------------
    13                              <3> 
    14                              <3> ;;
    15                              <3> ;; bcopy32xx.inc
    16                              <3> ;;
    17                              <3> 
    18                              <3> 
    19                              <3> ;
    20                              <3> ; 32-bit bcopy routine
    21                              <3> ;
    22                              <3> ; This is the actual 32-bit portion of the bcopy and shuffle and boot
    23                              <3> ; routines.  ALL THIS CODE NEEDS TO BE POSITION-INDEPENDENT, with the
    24                              <3> ; sole exception being the actual relocation code at the beginning of
    25                              <3> ; pm_shuffle_boot.
    26                              <3> ;
    27                              <3> ; It also really needs to live all in a single segment, for the
    28                              <3> ; address calculcations to actually work.
    29                              <3> ;
    30                              <3> 
    31                              <3> 		bits 32
    32                              <3> 		section .bcopyxx.text
    33                              <3> 		align 16
    34                              <3> ;
    35                              <3> ; pm_bcopy:
    36                              <3> ;
    37                              <3> ;	This is the protected-mode core of the "bcopy" routine.
    38                              <3> ;	Try to do aligned transfers; if the src and dst are relatively
    39                              <3> ;	misaligned, align the dst.
    40                              <3> ;
    41                              <3> ;	ECX is guaranteed to not be zero on entry.
    42                              <3> ;
    43                              <3> ;	Clobbers ESI, EDI, ECX.
    44                              <3> ;
    45                              <3> 
    46                              <3> pm_bcopy:
    47 00000000 53                  <3> 		push ebx
    48 00000001 52                  <3> 		push edx
    49 00000002 50                  <3> 		push eax
    50                              <3> 
    51 00000003 83FEFF              <3> 		cmp esi,-1
    52 00000006 747E                <3> 		je .bzero
    53                              <3> 
    54 00000008 39FE                <3> 		cmp esi,edi		; If source < destination, we might
    55 0000000A 722E                <3> 		jb .reverse		; have to copy backwards
    56                              <3> 
    57                              <3> .forward:
    58                              <3> 		; Initial alignment
    59 0000000C 89FA                <3> 		mov edx,edi
    60 0000000E D1EA                <3> 		shr edx,1
    61 00000010 7302                <3> 		jnc .faa1
    62 00000012 A4                  <3> 		movsb
    63 00000013 49                  <3> 		dec ecx
    64                              <3> .faa1:
    65 00000014 88C8                <3> 		mov al,cl
    66 00000016 83F902              <3> 		cmp ecx,2
    67 00000019 7216                <3> 		jb .f_tiny
    68                              <3> 
    69 0000001B D1EA                <3> 		shr edx,1
    70 0000001D 7305                <3> 		jnc .faa2
    71 0000001F 66A5                <3> 		movsw
    72 00000021 83E902              <3> 		sub ecx,2
    73                              <3> .faa2:
    74                              <3> 
    75                              <3> 		; Bulk transfer
    76 00000024 88C8                <3> 		mov al,cl		; Save low bits
    77 00000026 C1E902              <3> 		shr ecx,2		; Convert to dwords
    78 00000029 F3A5                <3> 		rep movsd		; Do our business
    79                              <3> 		; At this point ecx == 0
    80                              <3> 
    81 0000002B A802                <3> 		test al,2
    82 0000002D 7402                <3> 		jz .fab2
    83 0000002F 66A5                <3> 		movsw
    84                              <3> .fab2:
    85                              <3> .f_tiny:
    86 00000031 A801                <3> 		test al,1
    87 00000033 7401                <3> 		jz .fab1
    88 00000035 A4                  <3> 		movsb
    89                              <3> .fab1:
    90                              <3> .done:
    91 00000036 58                  <3> 		pop eax
    92 00000037 5A                  <3> 		pop edx
    93 00000038 5B                  <3> 		pop ebx
    94 00000039 C3                  <3> 		ret
    95                              <3> 
    96                              <3> .reverse:
    97 0000003A 8D440EFF            <3> 		lea eax,[esi+ecx-1]	; Point to final byte
    98 0000003E 39C7                <3> 		cmp edi,eax
    99 00000040 77CA                <3> 		ja .forward		; No overlap, do forward copy
   100                              <3> 
   101 00000042 FD                  <3> 		std			; Reverse copy
   102 00000043 8D7C0FFF            <3> 		lea edi,[edi+ecx-1]
   103 00000047 89C6                <3> 		mov esi,eax
   104                              <3> 
   105                              <3> 		; Initial alignment
   106 00000049 89FA                <3> 		mov edx,edi
   107 0000004B D1EA                <3> 		shr edx,1
   108 0000004D 7202                <3> 		jc .raa1
   109 0000004F A4                  <3> 		movsb
   110 00000050 49                  <3> 		dec ecx
   111                              <3> .raa1:
   112                              <3> 
   113 00000051 4E                  <3> 		dec esi
   114 00000052 4F                  <3> 		dec edi
   115 00000053 88C8                <3> 		mov al,cl
   116 00000055 83F902              <3> 		cmp ecx,2
   117 00000058 7222                <3> 		jb .r_tiny
   118 0000005A D1EA                <3> 		shr edx,1
   119 0000005C 7205                <3> 		jc .raa2
   120 0000005E 66A5                <3> 		movsw
   121 00000060 83E902              <3> 		sub ecx,2
   122                              <3> .raa2:
   123                              <3> 
   124                              <3> 		; Bulk copy
   125 00000063 83EE02              <3> 		sub esi,2
   126 00000066 83EF02              <3> 		sub edi,2
   127 00000069 88C8                <3> 		mov al,cl		; Save low bits
   128 0000006B C1E902              <3> 		shr ecx,2
   129 0000006E F3A5                <3> 		rep movsd
   130                              <3> 
   131                              <3> 		; Final alignment
   132                              <3> .r_final:
   133 00000070 83C602              <3> 		add esi,2
   134 00000073 83C702              <3> 		add edi,2
   135 00000076 A802                <3> 		test al,2
   136 00000078 7402                <3> 		jz .rab2
   137 0000007A 66A5                <3> 		movsw
   138                              <3> .rab2:
   139                              <3> .r_tiny:
   140 0000007C 46                  <3> 		inc esi
   141 0000007D 47                  <3> 		inc edi
   142 0000007E A801                <3> 		test al,1
   143 00000080 7401                <3> 		jz .rab1
   144 00000082 A4                  <3> 		movsb
   145                              <3> .rab1:
   146 00000083 FC                  <3> 		cld
   147 00000084 EBB0                <3> 		jmp short .done
   148                              <3> 
   149                              <3> .bzero:
   150 00000086 31C0                <3> 		xor eax,eax
   151                              <3> 
   152                              <3> 		; Initial alignment
   153 00000088 89FA                <3> 		mov edx,edi
   154 0000008A D1EA                <3> 		shr edx,1
   155 0000008C 7302                <3> 		jnc .zaa1
   156 0000008E AA                  <3> 		stosb
   157 0000008F 49                  <3> 		dec ecx
   158                              <3> .zaa1:
   159                              <3> 
   160 00000090 88CB                <3> 		mov bl,cl
   161 00000092 83F902              <3> 		cmp ecx,2
   162 00000095 7217                <3> 		jb .z_tiny
   163 00000097 D1EA                <3> 		shr edx,1
   164 00000099 7305                <3> 		jnc .zaa2
   165 0000009B 66AB                <3> 		stosw
   166 0000009D 83E902              <3> 		sub ecx,2
   167                              <3> .zaa2:
   168                              <3> 
   169                              <3> 		; Bulk
   170 000000A0 88CB                <3> 		mov bl,cl		; Save low bits
   171 000000A2 C1E902              <3> 		shr ecx,2
   172 000000A5 F3AB                <3> 		rep stosd
   173                              <3> 
   174 000000A7 F6C302              <3> 		test bl,2
   175 000000AA 7402                <3> 		jz .zab2
   176 000000AC 66AB                <3> 		stosw
   177                              <3> .zab2:
   178                              <3> .z_tiny:
   179 000000AE F6C301              <3> 		test bl,1
   180 000000B1 7401                <3> 		jz .zab1
   181 000000B3 AA                  <3> 		stosb
   182                              <3> .zab1:
   183 000000B4 EB80                <3> 		jmp short .done
   184                              <3> 
   185                              <3> ;
   186                              <3> ; shuffle_and_boot:
   187                              <3> ;
   188                              <3> ; This routine is used to shuffle memory around, followed by
   189                              <3> ; invoking an entry point somewhere in low memory.  This routine
   190                              <3> ; can clobber any memory outside the bcopy special area.
   191                              <3> ;
   192                              <3> ; IMPORTANT: This routine does not set up any registers.
   193                              <3> ; It is the responsibility of the caller to generate an appropriate entry
   194                              <3> ; stub; *especially* when going to real mode.
   195                              <3> ;
   196                              <3> ; Inputs:
   197                              <3> ;	ESI		-> Pointer to list of (dst, src, len) pairs(*)
   198                              <3> ;	EDI		-> Pointer to safe area for list + shuffler
   199                              <3> ;			   (must not overlap this code nor the RM stack)
   200                              <3> ;	ECX		-> Byte count of list area (for initial copy)
   201                              <3> ;
   202                              <3> ;     If src == -1: then the memory pointed to by (dst, len) is bzeroed;
   203                              <3> ;		    this is handled inside the bcopy routine.
   204                              <3> ;
   205                              <3> ;     If len == 0:  this marks the end of the list; dst indicates
   206                              <3> ;		    the entry point and src the mode (0 = pm, 1 = rm)
   207                              <3> ;
   208                              <3> ;     (*) dst, src, and len are four bytes each
   209                              <3> ;
   210                              <3> ; do_raw_shuffle_and_boot is the same entry point, but with a C ABI:
   211                              <3> ; do_raw_shuffle_and_boot(safearea, descriptors, bytecount)
   212                              <3> ;
   213                              <3> 		global do_raw_shuffle_and_boot
   214                              <3> do_raw_shuffle_and_boot:
   215 000000B6 89C7                <3> 		mov edi,eax
   216 000000B8 89D6                <3> 		mov esi,edx
   217                              <3> 
   218                              <3> pm_shuffle:
   219 000000BA FA                  <3> 		cli			; End interrupt service (for good)
   220 000000BB 89FB                <3> 		mov ebx,edi		; EBX <- descriptor list
   221 000000BD 8D540F0F            <3> 		lea edx,[edi+ecx+15]	; EDX <- where to relocate our code to
   222 000000C1 83E2F0              <3> 		and edx,~15		; Align 16 to benefit the GDT
   223 000000C4 E837FFFFFF          <3> 		call pm_bcopy
   224 000000C9 BE[00000000]        <3> 		mov esi,__bcopyxx_start	; Absolute source address
   225 000000CE 89D7                <3> 		mov edi,edx		; Absolute target address
   226 000000D0 29F2                <3> 		sub edx,esi		; EDX <- address delta
   227 000000D2 B9[00000000]        <3> 		mov ecx,__bcopyxx_dwords
   228 000000D7 8D82[E1000000]      <3> 		lea eax,[edx+.safe]	; Resume point
   229                              <3> 		; Relocate this code
   230 000000DD F3A5                <3> 		rep movsd
   231 000000DF FFE0                <3> 		jmp eax			; Jump to safe location
   232                              <3> .safe:
   233                              <3> 		; Give ourselves a safe stack
   234 000000E1 8DA2[80000000]      <3> 		lea esp,[edx+bcopyxx_stack+__bcopyxx_end]
   235 000000E7 81C2[00000000]      <3> 		add edx,bcopy_gdt	; EDX <- new GDT
   236 000000ED 895202              <3> 		mov [edx+2],edx		; GDT self-pointer
   237 000000F0 0F0112              <3> 		lgdt [edx]		; Switch to local GDT
   238                              <3> 
   239                              <3> 		; Now for the actual shuffling...
   240                              <3> .loop:
   241 000000F3 8B3B                <3> 		mov edi,[ebx]
   242 000000F5 8B7304              <3> 		mov esi,[ebx+4]
   243 000000F8 8B4B08              <3> 		mov ecx,[ebx+8]
   244 000000FB 83C30C              <3> 		add ebx,12
   245 000000FE E307                <3> 		jecxz .done
   246 00000100 E8FBFEFFFF          <3> 		call pm_bcopy
   247 00000105 EBEC                <3> 		jmp .loop
   248                              <3> .done:
   249 00000107 0F015A30            <3> 		lidt [edx+RM_IDT_ptr-bcopy_gdt]	; RM-like IDT
   250 0000010B 51                  <3> 		push ecx		; == 0, for cleaning the flags register
   251 0000010C 21F6                <3> 		and esi,esi
   252 0000010E 7403                <3> 		jz pm_shuffle_16
   253 00000110 9D                  <3> 		popfd			; Clean the flags
   254 00000111 FFE7                <3> 		jmp edi			; Protected mode entry
   255                              <3> 
   256                              <3> 		; We have a 16-bit entry point, so we need to return
   257                              <3> 		; to 16-bit mode.  Note: EDX already points to the GDT.
   258                              <3> pm_shuffle_16:
   259 00000113 89F8                <3> 		mov eax,edi
   260 00000115 66894212            <3> 		mov [edx+PM_CS16+2],ax
   261 00000119 6689421A            <3> 		mov [edx+PM_DS16+2],ax
   262 0000011D C1E810              <3> 		shr eax,16
   263 00000120 884214              <3> 		mov [edx+PM_CS16+4],al
   264 00000123 886217              <3> 		mov [edx+PM_CS16+7],ah
   265 00000126 88421C              <3> 		mov [edx+PM_DS16+4],al
   266 00000129 88621F              <3> 		mov [edx+PM_DS16+7],ah
   267 0000012C 0F20C0              <3> 		mov eax,cr0
   268 0000012F 24FE                <3> 		and al,~1
   269 00000131 9D                  <3> 		popfd			; Clean the flags
   270                              <3> 		; No flag-changing instructions below...
   271 00000132 66BA1800            <3> 		mov dx,PM_DS16
   272 00000136 8EDA                <3> 		mov ds,edx
   273 00000138 8EC2                <3> 		mov es,edx
   274 0000013A 8EE2                <3> 		mov fs,edx
   275 0000013C 8EEA                <3> 		mov gs,edx
   276 0000013E 8ED2                <3> 		mov ss,edx
   277 00000140 EA000000001000      <3> 		jmp PM_CS16:0
   278                              <3> 
   279                              <3> 		section	.bcopyxx.data
   280                              <3> 
   281                              <3> 		alignz 16
   282                              <3> ; GDT descriptor entry
   283                              <3> %macro desc 1
   284                              <3> bcopy_gdt.%1:
   285                              <3> PM_%1		equ bcopy_gdt.%1-bcopy_gdt
   286                              <3> %endmacro
   287                              <3> 
   288                              <3> bcopy_gdt:
   289 00000000 2F00                <3> 		dw bcopy_gdt_size-1	; Null descriptor - contains GDT
   290 00000002 [00000000]          <3> 		dd bcopy_gdt		; pointer for LGDT instruction
   291 00000006 0000                <3> 		dw 0
   292                              <3> 
   293                              <3> 		; TSS segment to keep Intel VT happy.  Intel VT is
   294                              <3> 		; unhappy about anything that doesn't smell like a
   295                              <3> 		; full-blown 32-bit OS.
   296                              <3> 	desc TSS
   296                              <4> bcopy_gdt.%1:
   296                              <4> PM_%1 equ bcopy_gdt.%1-bcopy_gdt
   297 00000008 67008005            <3> 		dw 104-1, DummyTSS	; 08h 32-bit task state segment
   298 0000000C 00890000            <3> 		dd 00008900h		; present, dpl 0, 104 bytes @DummyTSS
   299                              <3> 
   300                              <3> 	desc CS16
   300                              <4> bcopy_gdt.%1:
   300                              <4> PM_%1 equ bcopy_gdt.%1-bcopy_gdt
   301 00000010 FFFF0000            <3> 		dd 0000ffffh		; 10h Code segment, use16, readable,
   302 00000014 009B0000            <3> 		dd 00009b00h		; present, dpl 0, cover 64K
   303                              <3> 	desc DS16
   303                              <4> bcopy_gdt.%1:
   303                              <4> PM_%1 equ bcopy_gdt.%1-bcopy_gdt
   304 00000018 FFFF0000            <3> 		dd 0000ffffh		; 18h Data segment, use16, read/write,
   305 0000001C 00930000            <3> 		dd 00009300h		; present, dpl 0, cover 64K
   306                              <3> 	desc CS32
   306                              <4> bcopy_gdt.%1:
   306                              <4> PM_%1 equ bcopy_gdt.%1-bcopy_gdt
   307 00000020 FFFF0000            <3> 		dd 0000ffffh		; 20h Code segment, use32, readable,
   308 00000024 009BCF00            <3> 		dd 00cf9b00h		; present, dpl 0, cover all 4G
   309                              <3> 	desc DS32
   309                              <4> bcopy_gdt.%1:
   309                              <4> PM_%1 equ bcopy_gdt.%1-bcopy_gdt
   310 00000028 FFFF0000            <3> 		dd 0000ffffh		; 28h Data segment, use32, read/write,
   311 0000002C 0093CF00            <3> 		dd 00cf9300h		; present, dpl 0, cover all 4G
   312                              <3> 
   313                              <3> bcopy_gdt_size:	equ $-bcopy_gdt
   314                              <3> ;
   315                              <3> ; Space for a dummy task state segment.  It should never be actually
   316                              <3> ; accessed, but just in case it is, point to a chunk of memory that
   317                              <3> ; has a chance to not be used for anything real...
   318                              <3> ;
   319                              <3> DummyTSS	equ 0x580
   320                              <3> 
   321                              <3> 		align 4
   322 00000030 FFFF                <3> RM_IDT_ptr:	dw 0FFFFh		; Length (nonsense, but matches CPU)
   323 00000032 00000000            <3> 		dd 0			; Offset
   324                              <3> 
   325                              <3> bcopyxx_stack	equ 128			; We want this much stack
   326                              <3> 
   327                              <3> 		section .rodata
   328                              <3> 		global __syslinux_shuffler_size
   329                              <3> 		extern __bcopyxx_len
   330                              <3> 		align 4
   331                              <3> __syslinux_shuffler_size:
   332 00000008 [00000000]          <3> 		dd __bcopyxx_len
   333                              <3> 
   334                              <3> 		bits 16
   335                              <3> 		section .text16
     9                              <1> %include "strcpy.inc"           ; strcpy()
     1                              <2> ;
     2                              <2> ; strcpy: Copy DS:SI -> ES:DI up to and including a null byte;
     3                              <2> ;	  on exit SI and DI point to the byte *after* the null byte
     4                              <2> ;
     5                              <2> 		section .text16
     6                              <2> 
     7 0000046B 50                  <2> strcpy:		push ax
     8 0000046C AC                  <2> .loop:		lodsb
     9 0000046D AA                  <2> 		stosb
    10 0000046E 20C0                <2> 		and al,al
    11 00000470 75FA                <2> 		jnz .loop
    12 00000472 58                  <2> 		pop ax
    13 00000473 C3                  <2> 		ret
    10                              <1> %include "adv.inc"		; Auxillary Data Vector
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 2007-2008 H. Peter Anvin - All Rights Reserved
     4                              <2> ;;
     5                              <2> ;;   This program is free software; you can redistribute it and/or modify
     6                              <2> ;;   it under the terms of the GNU General Public License as published by
     7                              <2> ;;   the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
     8                              <2> ;;   Boston MA 02110-1301, USA; either version 2 of the License, or
     9                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    10                              <2> ;;
    11                              <2> ;; -----------------------------------------------------------------------
    12                              <2> 
    13                              <2> ;;
    14                              <2> ;; adv.inc
    15                              <2> ;;
    16                              <2> ;; The auxillary data vector and its routines
    17                              <2> ;;
    18                              <2> ;; The auxillary data vector is a 512-byte aligned block that on the
    19                              <2> ;; disk-based derivatives can be part of the syslinux file itself.  It
    20                              <2> ;; exists in two copies; when written, both copies are written (with a
    21                              <2> ;; sync in between, if from the operating system.)  The first two
    22                              <2> ;; dwords are magic number and inverse checksum, then follows the data
    23                              <2> ;; area as a tagged array similar to BOOTP/DHCP, finally a tail
    24                              <2> ;; signature.
    25                              <2> ;;
    26                              <2> ;; Note that unlike BOOTP/DHCP, zero terminates the chain, and FF
    27                              <2> ;; has no special meaning.
    28                              <2> ;;
    29                              <2> 
    30                              <2> ;;
    31                              <2> ;; List of ADV tags...
    32                              <2> ;;
    33                              <2> ADV_BOOTONCE	equ 1
    34                              <2> 
    35                              <2> ;;
    36                              <2> ;; Other ADV data...
    37                              <2> ;;
    38                              <2> ADV_MAGIC1	equ 0x5a2d2fa5			; Head signature
    39                              <2> ADV_MAGIC2	equ 0xa3041767			; Total checksum
    40                              <2> ADV_MAGIC3	equ 0xdd28bf64			; Tail signature
    41                              <2> 
    42                              <2> ADV_LEN		equ 500				; Data bytes
    43                              <2> 
    44                              <2> adv_retries	equ 6				; Disk retries
    45                              <2> 
    46                              <2> 		section .data
    47                              <2> 		global __syslinux_adv_ptr, __syslinux_adv_size
    48                              <2> __syslinux_adv_ptr:
    49 00000000 [08000000]          <2> 		dd adv0.data
    50                              <2> __syslinux_adv_size:
    51 00000004 F4010000            <2> 		dd ADV_LEN
    52                              <2> 
    53                              <2> 		section .adv
    54                              <2> 		; Introduce the ADVs to valid but blank
    55                              <2> adv0:
    56 00000000 <res 00000004>      <2> .head		resd 1
    57 00000004 <res 00000004>      <2> .csum		resd 1
    58 00000008 <res 000001F4>      <2> .data		resb ADV_LEN
    59 000001FC <res 00000004>      <2> .tail		resd 1
    60                              <2> .end		equ $
    61                              <2> adv1:
    62 00000200 <res 00000004>      <2> .head		resd 1
    63 00000204 <res 00000004>      <2> .csum		resd 1
    64 00000208 <res 000001F4>      <2> .data		resb ADV_LEN
    65 000003FC <res 00000004>      <2> .tail		resd 1
    66                              <2> .end		equ $
    67                              <2> 		section .text16
    68                              <2> 
    69                              <2> 		;
    70                              <2> 		; This is called after config file parsing, so we know
    71                              <2> 		; the intended location of the ADV
    72                              <2> 		;
    73                              <2> 		global adv_init
    74                              <2> adv_init:
    75 00000474 803E[8800]FF        <2> 		cmp byte [ADVDrive],-1
    76 00000479 0F855901            <2> 		jne adv_read
    77                              <2> 
    78                              <2> %if IS_SYSLINUX || IS_EXTLINUX
    79                              <2> 		cmp word [ADVSectors],2		; Not present?
    80                              <2> 		jb adv_verify
    81                              <2> 
    82                              <2> 		mov eax,[Hidden]
    83                              <2> 		mov edx,[Hidden+4]
    84                              <2> 		add [ADVSec0],eax
    85                              <2> 		adc [ADVSec0+4],edx
    86                              <2> 		add [ADVSec1],eax
    87                              <2> 		adc [ADVSec1+4],edx
    88                              <2> 		mov al,[DriveNumber]
    89                              <2> 		mov [ADVDrive],al
    90                              <2> 		jmp adv_read
    91                              <2> %endif
    92                              <2> 
    93                              <2> 		;
    94                              <2> 		; Initialize the ADV data structure in memory
    95                              <2> 		;
    96                              <2> adv_verify:
    97 0000047D 803E[8800]FF        <2> 		cmp byte [ADVDrive],-1		; No ADV configured, still?
    98 00000482 7410                <2> 		je .reset			; Then unconditionally reset
    99                              <2> 
   100 00000484 BE[0000]            <2> 		mov si,adv0
   101 00000487 E83900              <2> 		call .check_adv
   102 0000048A 742C                <2> 		jz .ok				; Primary ADV okay
   103 0000048C BE[0002]            <2> 		mov si,adv1
   104 0000048F E83100              <2> 		call .check_adv
   105 00000492 7425                <2> 		jz .adv1ok
   106                              <2> 
   107                              <2> 		; Neither ADV is usable; initialize to blank
   108                              <2> .reset:
   109 00000494 BF[0000]            <2> 		mov di,adv0
   110 00000497 66B8A52F2D5A        <2> 		mov eax,ADV_MAGIC1
   111 0000049D 66AB                <2> 		stosd
   112 0000049F 66B8671704A3        <2> 		mov eax,ADV_MAGIC2
   113 000004A5 66AB                <2> 		stosd
   114 000004A7 6631C0              <2> 		xor eax,eax
   115 000004AA B97D00              <2> 		mov cx,ADV_LEN/4
   116 000004AD F366AB              <2> 		rep stosd
   117 000004B0 66B864BF28DD        <2> 		mov eax,ADV_MAGIC3
   118 000004B6 66AB                <2> 		stosd
   119                              <2> 
   120                              <2> .ok:
   121 000004B8 C3                  <2> 		ret
   122                              <2> 
   123                              <2> 		; The primary ADV is bad, but the backup is OK
   124                              <2> .adv1ok:
   125 000004B9 BF[0000]            <2> 		mov di,adv0
   126 000004BC B98000              <2> 		mov cx,512/4
   127 000004BF F366A5              <2> 		rep movsd
   128 000004C2 C3                  <2> 		ret
   129                              <2> 
   130                              <2> 
   131                              <2> 		; SI points to the putative ADV; unchanged by routine
   132                              <2> 		; ZF=1 on return if good
   133                              <2> .check_adv:
   134 000004C3 56                  <2> 		push si
   135 000004C4 66AD                <2> 		lodsd
   136 000004C6 663DA52F2D5A        <2> 		cmp eax,ADV_MAGIC1
   137 000004CC 751E                <2> 		jne .done			; ZF=0, i.e. bad
   138 000004CE 6631D2              <2> 		xor edx,edx
   139 000004D1 B97E00              <2> 		mov cx,ADV_LEN/4+1		; Remaining dwords
   140                              <2> .csum:
   141 000004D4 66AD                <2> 		lodsd
   142 000004D6 6601C2              <2> 		add edx,eax
   143 000004D9 E2F9                <2> 		loop .csum
   144 000004DB 6681FA671704A3      <2> 		cmp edx,ADV_MAGIC2
   145 000004E2 7508                <2> 		jne .done
   146 000004E4 66AD                <2> 		lodsd
   147 000004E6 663D64BF28DD        <2> 		cmp eax,ADV_MAGIC3
   148                              <2> .done:
   149 000004EC 5E                  <2> 		pop si
   150 000004ED C3                  <2> 		ret
   151                              <2> 
   152                              <2> ;
   153                              <2> ; adv_get: find an ADV string if present
   154                              <2> ;
   155                              <2> ; Input:	DL	= ADV ID
   156                              <2> ; Output:	CX	= byte count (zero on not found)
   157                              <2> ;		SI	= pointer to data
   158                              <2> ;		DL	= unchanged
   159                              <2> ;
   160                              <2> ; Assumes CS == DS.
   161                              <2> ;
   162                              <2> 
   163                              <2> adv_get:
   164 000004EE 50                  <2> 		push ax
   165 000004EF BE[0800]            <2> 		mov si,adv0.data
   166 000004F2 31C0                <2> 		xor ax,ax			; Keep AH=0 at all times
   167                              <2> .loop:
   168 000004F4 AC                  <2> 		lodsb				; Read ID
   169 000004F5 38D0                <2> 		cmp al,dl
   170 000004F7 740F                <2> 		je .found
   171 000004F9 20C0                <2> 		and al,al
   172 000004FB 7415                <2> 		jz .end
   173 000004FD AC                  <2> 		lodsb				; Read length
   174 000004FE 01C6                <2> 		add si,ax
   175 00000500 81FE[FC01]          <2> 		cmp si,adv0.tail
   176 00000504 72EE                <2> 		jb .loop
   177 00000506 EB0A                <2> 		jmp .end
   178                              <2> 
   179                              <2> .found:
   180 00000508 AC                  <2> 		lodsb
   181 00000509 89C1                <2> 		mov cx,ax
   182 0000050B 01F0                <2> 		add ax,si			; Make sure it fits
   183 0000050D 3D[FC01]            <2> 		cmp ax,adv0.tail
   184 00000510 7602                <2> 		jbe .ok
   185                              <2> .end:
   186 00000512 31C9                <2> 		xor cx,cx
   187                              <2> .ok:
   188 00000514 58                  <2> 		pop ax
   189 00000515 C3                  <2> 		ret
   190                              <2> 
   191                              <2> ;
   192                              <2> ; adv_set: insert a string into the ADV in memory
   193                              <2> ;
   194                              <2> ; Input:	DL	= ADV ID
   195                              <2> ;		FS:BX	= input buffer
   196                              <2> ;		CX	= byte count (max = 255!)
   197                              <2> ; Output:	CF=1 on error
   198                              <2> ;		CX	clobbered
   199                              <2> ;
   200                              <2> ; Assumes CS == DS == ES.
   201                              <2> ;
   202                              <2> adv_set:
   203 00000516 50                  <2> 		push ax
   204 00000517 56                  <2> 		push si
   205 00000518 57                  <2> 		push di
   206 00000519 20ED                <2> 		and ch,ch
   207 0000051B 7559                <2> 		jnz .overflow
   208                              <2> 
   209 0000051D 51                  <2> 		push cx
   210 0000051E BE[0800]            <2> 		mov si,adv0.data
   211 00000521 31C0                <2> 		xor ax,ax
   212                              <2> .loop:
   213 00000523 AC                  <2> 		lodsb
   214 00000524 38D0                <2> 		cmp al,dl
   215 00000526 740F                <2> 		je .found
   216 00000528 20C0                <2> 		and al,al
   217 0000052A 7423                <2> 		jz .endz
   218 0000052C AC                  <2> 		lodsb
   219 0000052D 01C6                <2> 		add si,ax
   220 0000052F 81FE[FC01]          <2> 		cmp si,adv0.tail
   221 00000533 72EE                <2> 		jb .loop
   222 00000535 EB19                <2> 		jmp .end
   223                              <2> 
   224                              <2> .found:		; Found, need to delete old copy
   225 00000537 AC                  <2> 		lodsb
   226 00000538 8D7CFE              <2> 		lea di,[si-2]
   227 0000053B 57                  <2> 		push di
   228 0000053C 01C6                <2> 		add si,ax
   229 0000053E B9[FC01]            <2> 		mov cx,adv0.tail
   230 00000541 29F1                <2> 		sub cx,si
   231 00000543 7207                <2> 		jb .nukeit
   232 00000545 F3A4                <2> 		rep movsb			; Remove the old one
   233 00000547 8825                <2> 		mov [di],ah			; Termination zero
   234 00000549 5E                  <2> 		pop si
   235 0000054A EBD7                <2> 		jmp .loop
   236                              <2> .nukeit:
   237 0000054C 5E                  <2> 		pop si
   238 0000054D EB01                <2> 		jmp .end
   239                              <2> .endz:
   240 0000054F 4E                  <2> 		dec si
   241                              <2> .end:
   242                              <2> 		; Now SI points to where we want to put our data
   243 00000550 59                  <2> 		pop cx
   244 00000551 89F7                <2> 		mov di,si
   245 00000553 E313                <2> 		jcxz .empty
   246 00000555 01CE                <2> 		add si,cx
   247 00000557 81FE[FA01]          <2> 		cmp si,adv0.tail-2
   248 0000055B 7319                <2> 		jae .overflow			; CF=0
   249                              <2> 
   250 0000055D 89DE                <2> 		mov si,bx
   251 0000055F 88D0                <2> 		mov al,dl
   252 00000561 AA                  <2> 		stosb
   253 00000562 88C8                <2> 		mov al,cl
   254 00000564 AA                  <2> 		stosb
   255 00000565 F364A4              <2> 		fs rep movsb
   256                              <2> 
   257                              <2> .empty:
   258 00000568 B9[FC01]            <2> 		mov cx,adv0.tail
   259 0000056B 29F9                <2> 		sub cx,di
   260 0000056D 31C0                <2> 		xor ax,ax
   261 0000056F F3AA                <2> 		rep stosb			; Zero-fill remainder
   262                              <2> 
   263 00000571 F8                  <2> 		clc
   264                              <2> .done:
   265 00000572 5F                  <2> 		pop di
   266 00000573 5E                  <2> 		pop si
   267 00000574 58                  <2> 		pop ax
   268 00000575 C3                  <2> 		ret
   269                              <2> .overflow:
   270 00000576 F9                  <2> 		stc
   271 00000577 EBF9                <2> 		jmp .done
   272                              <2> 
   273                              <2> ;
   274                              <2> ; adv_cleanup:	checksum adv0 and copy to adv1
   275                              <2> ;		Assumes CS == DS == ES.
   276                              <2> ;
   277                              <2> adv_cleanup:
   278 00000579 6660                <2> 		pushad
   279 0000057B BE[0800]            <2> 		mov si,adv0.data
   280 0000057E B97D00              <2> 		mov cx,ADV_LEN/4
   281 00000581 6631D2              <2> 		xor edx,edx
   282                              <2> .loop:
   283 00000584 66AD                <2> 		lodsd
   284 00000586 6601C2              <2> 		add edx,eax
   285 00000589 E2F9                <2> 		loop .loop
   286 0000058B 66B8671704A3        <2> 		mov eax,ADV_MAGIC2
   287 00000591 6629D0              <2> 		sub eax,edx
   288 00000594 8D7C04              <2> 		lea di,[si+4]			; adv1
   289 00000597 BE[0000]            <2> 		mov si,adv0
   290 0000059A 66894404            <2> 		mov [si+4],eax			; Store checksum
   291 0000059E B98000              <2> 		mov cx,(ADV_LEN+12)/4
   292 000005A1 F366A5              <2> 		rep movsd
   293 000005A4 6661                <2> 		popad
   294 000005A6 C3                  <2> 		ret
   295                              <2> 
   296                              <2> ;
   297                              <2> ; adv_write:	write the ADV to disk.
   298                              <2> ;
   299                              <2> ;		Location is in memory variables.
   300                              <2> ;		Assumes CS == DS == ES.
   301                              <2> ;
   302                              <2> ;		Returns CF=1 if the ADV cannot be written.
   303                              <2> ;
   304                              <2> 		global adv_write
   305                              <2> adv_write:
   306 000005A7 6650                <2> 		push eax
   307 000005A9 66A1[7800]          <2> 		mov eax,[ADVSec0]
   308 000005AD 660B06[7C00]        <2> 		or eax,[ADVSec0+4]
   309 000005B2 741E                <2> 		je .bad
   310 000005B4 66A1[8000]          <2> 		mov eax,[ADVSec1]
   311 000005B8 660B06[8400]        <2> 		or eax,[ADVSec1+4]
   312 000005BD 7413                <2> 		je .bad
   313 000005BF 803E[8800]FF        <2> 		cmp byte [ADVDrive],-1
   314 000005C4 740C                <2> 		je .bad
   315                              <2> 
   316 000005C6 E8B0FF              <2> 		call adv_cleanup
   317 000005C9 B403                <2> 		mov ah,3			; Write
   318 000005CB E81300              <2> 		call adv_read_write
   319                              <2> 
   320 000005CE F8                  <2> 		clc
   321 000005CF 6658                <2> 		pop eax
   322 000005D1 C3                  <2> 		ret
   323                              <2> .bad:						; No location for ADV set
   324 000005D2 F9                  <2> 		stc
   325 000005D3 6658                <2> 		pop eax
   326 000005D5 C3                  <2> 		ret
   327                              <2> 
   328                              <2> ;
   329                              <2> ; adv_read:	read the ADV from disk
   330                              <2> ;
   331                              <2> ;		Location is in memory variables.
   332                              <2> ;		Assumes CS == DS == ES.
   333                              <2> ;
   334                              <2> adv_read:
   335 000005D6 50                  <2> 		push ax
   336 000005D7 B402                <2> 		mov ah,2			; Read
   337 000005D9 E80500              <2> 		call adv_read_write
   338 000005DC E89EFE              <2> 		call adv_verify
   339 000005DF 58                  <2> 		pop ax
   340 000005E0 C3                  <2> 		ret
   341                              <2> 
   342                              <2> ;
   343                              <2> ; adv_read_write: disk I/O for the ADV
   344                              <2> ;
   345                              <2> ;		On input, AH=2 for read, AH=3 for write.
   346                              <2> ;		Assumes CS == DS == ES.
   347                              <2> ;
   348                              <2> adv_read_write:
   349 000005E1 8826[3802]          <2> 		mov [ADVOp],ah
   350 000005E5 6660                <2> 		pushad
   351                              <2> 
   352                              <2> 		; Check for EDD
   353 000005E7 BBAA55              <2> 		mov bx,55AAh
   354 000005EA B441                <2> 		mov ah,41h			; EDD existence query
   355 000005EC 8A16[8800]          <2> 		mov dl,[ADVDrive]
   356 000005F0 CD13                <2> 		int 13h
   357 000005F2 BE[5906]            <2> 		mov si,.cbios
   358 000005F5 720E                <2> 		jc .noedd
   359 000005F7 81FB55AA            <2> 		cmp bx,0AA55h
   360 000005FB 7508                <2> 		jne .noedd
   361 000005FD F6C101              <2> 		test cl,1
   362 00000600 7403                <2> 		jz .noedd
   363 00000602 BE[2906]            <2> 		mov si,.ebios
   364                              <2> .noedd:
   365                              <2> 
   366 00000605 66A1[7800]          <2> 		mov eax,[ADVSec0]
   367 00000609 668B16[7C00]        <2> 		mov edx,[ADVSec0+4]
   368 0000060E BB[0000]            <2> 		mov bx,adv0
   369 00000611 E81200              <2> 		call .doone
   370                              <2> 
   371 00000614 66A1[8000]          <2> 		mov eax,[ADVSec1]
   372 00000618 668B16[8400]        <2> 		mov edx,[ADVSec1+4]
   373 0000061D BB[0002]            <2> 		mov bx,adv1
   374 00000620 E80300              <2> 		call .doone
   375                              <2> 
   376 00000623 6661                <2> 		popad
   377 00000625 C3                  <2> 		ret
   378                              <2> 
   379                              <2> .doone:
   380 00000626 56                  <2> 		push si
   381 00000627 FFE6                <2> 		jmp si
   382                              <2> 
   383                              <2> .ebios:
   384 00000629 B90600              <2> 		mov cx,adv_retries
   385                              <2> .eb_retry:
   386                              <2> 		; Form DAPA on stack
   387 0000062C 6652                <2> 		push edx
   388 0000062E 6650                <2> 		push eax
   389 00000630 06                  <2> 		push es
   390 00000631 53                  <2> 		push bx
   391 00000632 6A01                <2> 		push word 1			; Sector count
   392 00000634 6A10                <2> 		push word 16			; DAPA size
   393 00000636 89E6                <2> 		mov si,sp
   394 00000638 6660                <2> 		pushad
   395 0000063A 8A16[8800]          <2> 		mov dl,[ADVDrive]
   396 0000063E B80040              <2> 		mov ax,4000h
   397 00000641 0A26[3802]          <2> 		or ah,[ADVOp]
   398 00000645 1E                  <2> 		push ds
   399 00000646 16                  <2> 		push ss
   400 00000647 1F                  <2> 		pop ds
   401 00000648 CD13                <2> 		int 13h
   402 0000064A 1F                  <2> 		pop ds
   403 0000064B 6661                <2> 		popad
   404 0000064D 8D6410              <2> 		lea sp,[si+16]			; Remove DAPA
   405 00000650 7202                <2> 		jc .eb_error
   406 00000652 5E                  <2> 		pop si
   407 00000653 C3                  <2> 		ret
   408                              <2> .eb_error:
   409 00000654 E2D6                <2> 		loop .eb_retry
   410 00000656 F9                  <2> 		stc
   411 00000657 5E                  <2> 		pop si
   412 00000658 C3                  <2> 		ret
   413                              <2> 
   414                              <2> .cbios:
   415 00000659 6652                <2> 		push edx
   416 0000065B 6650                <2> 		push eax
   417 0000065D 55                  <2> 		push bp
   418                              <2> 
   419 0000065E 6621D2              <2> 		and edx,edx			; > 2 TiB not possible
   420 00000661 7563                <2> 		jnz .cb_overflow
   421                              <2> 
   422 00000663 8A16[8800]          <2> 		mov dl,[ADVDrive]
   423 00000667 20D2                <2> 		and dl,dl
   424                              <2> 		; Floppies: can't trust INT 13h 08h, we better know
   425                              <2> 		; the geometry a priori, which means it better be our
   426                              <2> 		; boot device...
   427 00000669 791B                <2> 		jns .noparm			; Floppy drive... urk
   428                              <2> 
   429 0000066B B408                <2> 		mov ah,08h			; Get disk parameters
   430 0000066D CD13                <2> 		int 13h
   431 0000066F 7215                <2> 		jc .noparm
   432 00000671 20E4                <2> 		and ah,ah
   433 00000673 7511                <2> 		jnz .noparm
   434 00000675 C1EA08              <2> 		shr dx,8
   435 00000678 42                  <2> 		inc dx
   436 00000679 660FB7FA            <2> 		movzx edi,dx			; EDI = heads
   437 0000067D 83E13F              <2> 		and cx,3fh
   438 00000680 660FB7F1            <2> 		movzx esi,cx			; ESI = sectors/track
   439 00000684 EB02                <2> 		jmp .parmok
   440                              <2> 
   441                              <2> .noparm:
   442                              <2> 		; No CHS info... this better be our boot drive, then
   443                              <2> %if IS_SYSLINUX || IS_EXTLINUX
   444                              <2> 		cmp dl,[DriveNumber]
   445                              <2> 		jne .cb_overflow		; Fatal error!
   446                              <2> 		movzx esi,word [bsSecPerTrack]
   447                              <2> 		movzx edi,word [bsHeads]
   448                              <2> %else
   449                              <2> 		; Not a disk-based derivative... there is no hope
   450 00000686 EB3E                <2> 		jmp .cb_overflow
   451                              <2> %endif
   452                              <2> 
   453                              <2> .parmok:
   454                              <2>                 ;
   455                              <2>                 ; Dividing by sectors to get (track,sector): we may have
   456                              <2>                 ; up to 2^18 tracks, so we need to use 32-bit arithmetric.
   457                              <2>                 ;
   458 00000688 6631D2              <2> 		xor edx,edx
   459 0000068B 66F7F6              <2>                 div esi
   460 0000068E 31C9                <2>                 xor cx,cx
   461 00000690 87CA                <2>                 xchg cx,dx              ; CX <- sector index (0-based)
   462                              <2>                                         ; EDX <- 0
   463                              <2>                 ; eax = track #
   464 00000692 66F7F7              <2>                 div edi                 ; Convert track to head/cyl
   465                              <2> 
   466                              <2> 		; Watch out for overflow, we might be writing!
   467 00000695 663DFF030000        <2> 		cmp eax,1023
   468 0000069B 7729                <2>                 ja .cb_overflow
   469                              <2> 
   470                              <2>                 ;
   471                              <2>                 ; Now we have AX = cyl, DX = head, CX = sector (0-based),
   472                              <2>                 ; BP = sectors to transfer, SI = bsSecPerTrack,
   473                              <2>                 ; ES:BX = data target
   474                              <2>                 ;
   475                              <2> 
   476 0000069D C0E406              <2>                 shl ah,6                ; Because IBM was STOOPID
   477                              <2>                                         ; and thought 8 bits were enough
   478                              <2>                                         ; then thought 10 bits were enough...
   479 000006A0 41                  <2>                 inc cx                  ; Sector numbers are 1-based, sigh
   480 000006A1 08E1                <2>                 or cl,ah
   481 000006A3 88C5                <2>                 mov ch,al
   482 000006A5 88D6                <2>                 mov dh,dl
   483 000006A7 8A16[8800]          <2>                 mov dl,[ADVDrive]
   484 000006AB B001                <2> 		mov al,01h		; Transfer one sector
   485 000006AD 8A26[3802]          <2>                 mov ah,[ADVOp]		; Operation
   486                              <2> 
   487 000006B1 BD0600              <2> 		mov bp,adv_retries
   488                              <2> .cb_retry:
   489 000006B4 6660                <2>                 pushad
   490 000006B6 CD13                <2>                 int 13h
   491 000006B8 6661                <2>                 popad
   492 000006BA 7207                <2>                 jc .cb_error
   493                              <2> 
   494                              <2> .cb_done:
   495 000006BC 5D                  <2>                 pop bp
   496 000006BD 6658                <2>                 pop eax
   497 000006BF 665A                <2>                 pop edx
   498 000006C1 5E                  <2> 		pop si
   499 000006C2 C3                  <2>                 ret
   500                              <2> 
   501                              <2> .cb_error:
   502 000006C3 4D                  <2>                 dec bp
   503 000006C4 75EE                <2>                 jnz .cb_retry
   504                              <2> .cb_overflow:
   505 000006C6 F9                  <2> 		stc
   506 000006C7 EBF3                <2> 		jmp .cb_done
   507                              <2> 
   508                              <2> 		section .data16
   509 00000073 00<rept>            <2> 		alignz 8
   510 00000078 0000000000000000    <2> ADVSec0		dq 0			; Not specified
   511 00000080 0000000000000000    <2> ADVSec1		dq 0			; Not specified
   512 00000088 FF                  <2> ADVDrive	db -1			; No ADV defined
   513 00000089 FF                  <2> ADVCHSInfo	db -1			; We have CHS info for this drive
   514                              <2> 
   515                              <2> 		section .bss16
   516 00000238 <res 00000001>      <2> ADVOp		resb 1
   517                              <2> 
   518                              <2> 		section .text16
    11                              <1> %include "timer.inc"		; Timer handling
     1                              <2> ;; -----------------------------------------------------------------------
     2                              <2> ;;
     3                              <2> ;;   Copyright 2009 Intel Corporation; author: H. Peter Anvin
     4                              <2> ;;
     5                              <2> ;;   This program is free software; you can redistribute it and/or modify
     6                              <2> ;;   it under the terms of the GNU General Public License as published by
     7                              <2> ;;   the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
     8                              <2> ;;   Boston MA 02110-1301, USA; either version 2 of the License, or
     9                              <2> ;;   (at your option) any later version; incorporated herein by reference.
    10                              <2> ;;
    11                              <2> ;; -----------------------------------------------------------------------
    12                              <2> 
    13                              <2> ;;
    14                              <2> ;; timer.inc
    15                              <2> ;;
    16                              <2> ;; Very simple counting timer
    17                              <2> ;;
    18                              <2> ;; This lets us have a simple incrementing variable without worrying
    19                              <2> ;; about the BIOS_timer variable wrapping around at "midnight" and other
    20                              <2> ;; weird things.
    21                              <2> ;;
    22                              <2> ;; This also maintains a timer variable calibrated in milliseconds
    23                              <2> ;; (wraparound time = 49.7 days!)
    24                              <2> ;;
    25                              <2> 
    26                              <2> 		section .text16
    27                              <2> 
    28                              <2> timer_init:
    29                              <2> 		; Hook INT 1Ch
    30 000006C9 66A17000            <2> 		mov eax,[BIOS_timer_hook]
    31 000006CD 66A3[F906]          <2> 		mov [BIOS_timer_next],eax
    32 000006D1 66C7067000-         <2> 		mov dword [BIOS_timer_hook],timer_irq
    32 000006D6 [E4060000]          <2>
    33 000006DA C3                  <2> 		ret
    34                              <2> 
    35                              <2> 		global bios_timer_cleanup:function hidden
    36                              <2> bios_timer_cleanup:
    37                              <2> 		; Unhook INT 1Ch
    38 000006DB 66A1[F906]          <2> 		mov eax,[BIOS_timer_next]
    39 000006DF 66A37000            <2> 		mov [BIOS_timer_hook],eax
    40 000006E3 C3                  <2> 		ret
    41                              <2> 
    42                              <2> ;
    43                              <2> ; The specified frequency is 14.31818 MHz/12/65536; this turns out
    44                              <2> ; to be a period of 54.92542 ms, or 0x36.ece8(187c) hexadecimal.
    45                              <2> ;
    46                              <2> 		global timer_irq:function hidden
    47                              <2> timer_irq:
    48 000006E4 2E66FF06[8C00]      <2> 		inc dword [cs:__jiffies]
    49 000006EA 2E8106[9400]E8EC    <2> 		add word  [cs:__ms_timer_adj],0xece8
    50 000006F1 2E668316[9000]36    <2> 		adc dword [cs:__ms_timer],0x36
    51 000006F8 EA00000000          <2> 		jmp 0:0
    52                              <2> 		global BIOS_timer_next:data hidden
    53                              <2> BIOS_timer_next	equ $-4
    54                              <2> 
    55                              <2> 		section .data16
    56 0000008A 00<rept>            <2> 		alignz 4
    57                              <2> 		global __jiffies:data hidden, __ms_timer
    58 0000008C 00000000            <2> __jiffies	dd 0			; Clock tick timer
    59 00000090 00000000            <2> __ms_timer	dd 0			; Millisecond timer
    60 00000094 0000                <2> __ms_timer_adj	dw 0			; Millisecond timer correction factor
    12                              <1> 
    13                              <1> ; Note: the prefix section is included late, to avoid problems with some
    14                              <1> ; versions of NASM that had issues with forward references to EQU symbols.
    15                              <1> %include "prefix.inc"		; Prefix section for prepcore
     1                              <2> ;
     2                              <2> ; The prefix is a small structure that prefaces the actual code;
     3                              <2> ; it gives the compression program necessary information.
     4                              <2> ;
     5                              <2> 
     6                              <2> 		section .prefix		nowrite progbits align=16
     7 00000000 [00000000]          <2> pfx_start	dd _start		; Start of raw chunk
     8 00000004 [00000000]          <2> pfx_compressed	dd __pm_code_lma	; Start of compressed chunk
     9 00000008 [06000000]          <2> pfx_cdatalen	dd lzo_data_size	; Pointer to compressed size field
    10                              <2> %if IS_ISOLINUX
    11                              <2> pfx_checksum	dd bi_length		; File length and checksum fields
    12                              <2> %else
    13 0000000C 00000000            <2> pfx_checksum	dd 0			; No checksum
    14                              <2> %endif
    15 00000010 00000600            <2> pfx_maxlma	dd MaxLMA		; Maximum size
    16                              <2> 
    17                              <2> 		section .text16
   547                                  
   548                                  ; -----------------------------------------------------------------------------
   549                                  ;  Begin data section
   550                                  ; -----------------------------------------------------------------------------
   551                                  
   552                                  		section .data16
   553                                  
   554                                  		global copyright_str, syslinux_banner
   555 00000096 436F70797269676874-     copyright_str   db 'Copyright (C) 1994-'
   555 0000009F 202843292031393934-
   555 000000A8 2D                 
   556 000000A9 32303135                		asciidec YEAR
   557 000000AD 20482E205065746572-     		db ' H. Peter Anvin et al', CR, LF, 0
   557 000000B6 20416E76696E206574-
   557 000000BF 20616C0D0A00       
   558 000000C5 0D0A426F6F74206661-     err_bootfailed	db CR, LF, 'Boot failed: press a key to retry, or wait for reset...', CR, LF, 0
   558 000000CE 696C65643A20707265-
   558 000000D7 73732061206B657920-
   558 000000E0 746F2072657472792C-
   558 000000E9 206F72207761697420-
   558 000000F2 666F72207265736574-
   558 000000FB 2E2E2E0D0A00       
   559                                  bailmsg		equ err_bootfailed
   560 00000101 426F6F74696E672066-     localboot_msg	db 'Booting from local disk...', CR, LF, 0
   560 0000010A 726F6D206C6F63616C-
   560 00000113 206469736B2E2E2E0D-
   560 0000011C 0A00               
   561 0000011E 0D0A5058454C494E55-     syslinux_banner	db CR, LF, MY_NAME, ' ', VERSION_STR, ' ', MY_TYPE, ' '
   561 00000127 5820362E3034205058-
   561 00000130 4520               
   562 00000132 2000                    		db DATE_STR, ' ', 0
   563                                  
   564                                  ;
   565                                  ; Misc initialized (data) variables
   566                                  ;
   567                                  		section .data16
   568                                                  global KeepPXE
   569 00000134 00                      KeepPXE		db 0			; Should PXE be kept around?
   570                                  
   571                                  		section .bss16
   572                                  		global OrigFDCTabPtr
   573 00000239 <res 00000004>          OrigFDCTabPtr	resd 1			; Keep bios_cleanup_hardware() honest
